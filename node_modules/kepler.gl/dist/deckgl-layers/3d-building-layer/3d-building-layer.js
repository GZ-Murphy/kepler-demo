"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _core = require("@deck.gl/core");

var _geoLayers = require("@deck.gl/geo-layers");

var _dBuildingUtils = require("./3d-building-utils");

var _layers = require("@deck.gl/layers");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var ThreeDBuildingLayer =
/*#__PURE__*/
function (_CompositeLayer) {
  (0, _inherits2["default"])(ThreeDBuildingLayer, _CompositeLayer);

  function ThreeDBuildingLayer() {
    (0, _classCallCheck2["default"])(this, ThreeDBuildingLayer);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ThreeDBuildingLayer).apply(this, arguments));
  }

  (0, _createClass2["default"])(ThreeDBuildingLayer, [{
    key: "renderSubLayers",
    // this layer add its subLayers to the redux store, and push sample data
    value: function renderSubLayers(props) {
      return new _layers.SolidPolygonLayer(_objectSpread({}, props, {
        parameter: {
          blendFunc: ['SRC_ALPHA', 'ONE_MINUS_SRC_ALPHA', 'ONE', 'ONE_MINUS_SRC_ALPHA'],
          blendEquation: ['FUNC_ADD', 'FUNC_ADD']
        },
        extruded: true,
        opacity: 1,
        filled: true,
        getElevation: function getElevation(feature) {
          return feature.properties.height || 0;
        },
        getPolygon: function getPolygon(feature) {
          return feature.coordinates;
        },
        getFillColor: this.props.threeDBuildingColor
      }));
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      var _this = this;

      return [new _geoLayers.TileLayer({
        getTileData: function getTileData(args) {
          return (0, _dBuildingUtils.getTileData)(_this.props.mapboxApiUrl, _this.props.mapboxApiAccessToken, args);
        },
        minZoom: 13,
        renderSubLayers: this.renderSubLayers.bind(this),
        updateTriggers: this.props.updateTriggers
      })];
    }
  }]);
  return ThreeDBuildingLayer;
}(_core.CompositeLayer);

exports["default"] = ThreeDBuildingLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kZWNrZ2wtbGF5ZXJzLzNkLWJ1aWxkaW5nLWxheWVyLzNkLWJ1aWxkaW5nLWxheWVyLmpzIl0sIm5hbWVzIjpbIlRocmVlREJ1aWxkaW5nTGF5ZXIiLCJwcm9wcyIsIlNvbGlkUG9seWdvbkxheWVyIiwicGFyYW1ldGVyIiwiYmxlbmRGdW5jIiwiYmxlbmRFcXVhdGlvbiIsImV4dHJ1ZGVkIiwib3BhY2l0eSIsImZpbGxlZCIsImdldEVsZXZhdGlvbiIsImZlYXR1cmUiLCJwcm9wZXJ0aWVzIiwiaGVpZ2h0IiwiZ2V0UG9seWdvbiIsImNvb3JkaW5hdGVzIiwiZ2V0RmlsbENvbG9yIiwidGhyZWVEQnVpbGRpbmdDb2xvciIsIkRlY2tHTFRpbGVMYXllciIsImdldFRpbGVEYXRhIiwiYXJncyIsIm1hcGJveEFwaVVybCIsIm1hcGJveEFwaUFjY2Vzc1Rva2VuIiwibWluWm9vbSIsInJlbmRlclN1YkxheWVycyIsImJpbmQiLCJ1cGRhdGVUcmlnZ2VycyIsIkNvbXBvc2l0ZUxheWVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztJQUVxQkEsbUI7Ozs7Ozs7Ozs7OztBQUNuQjtvQ0FFZ0JDLEssRUFBTztBQUNyQixhQUFPLElBQUlDLHlCQUFKLG1CQUNGRCxLQURFO0FBRUxFLFFBQUFBLFNBQVMsRUFBRTtBQUNUQyxVQUFBQSxTQUFTLEVBQUUsQ0FDVCxXQURTLEVBRVQscUJBRlMsRUFHVCxLQUhTLEVBSVQscUJBSlMsQ0FERjtBQU9UQyxVQUFBQSxhQUFhLEVBQUUsQ0FBQyxVQUFELEVBQWEsVUFBYjtBQVBOLFNBRk47QUFXTEMsUUFBQUEsUUFBUSxFQUFFLElBWEw7QUFZTEMsUUFBQUEsT0FBTyxFQUFFLENBWko7QUFhTEMsUUFBQUEsTUFBTSxFQUFFLElBYkg7QUFjTEMsUUFBQUEsWUFBWSxFQUFFLHNCQUFDQyxPQUFEO0FBQUEsaUJBQWFBLE9BQU8sQ0FBQ0MsVUFBUixDQUFtQkMsTUFBbkIsSUFBNkIsQ0FBMUM7QUFBQSxTQWRUO0FBZUxDLFFBQUFBLFVBQVUsRUFBRSxvQkFBQ0gsT0FBRDtBQUFBLGlCQUFhQSxPQUFPLENBQUNJLFdBQXJCO0FBQUEsU0FmUDtBQWdCTEMsUUFBQUEsWUFBWSxFQUFFLEtBQUtkLEtBQUwsQ0FBV2U7QUFoQnBCLFNBQVA7QUFrQkQ7OzttQ0FFYztBQUFBOztBQUNiLGFBQU8sQ0FDTCxJQUFJQyxvQkFBSixDQUFvQjtBQUNsQkMsUUFBQUEsV0FBVyxFQUFFLHFCQUFDQyxJQUFEO0FBQUEsaUJBQVUsaUNBQVksS0FBSSxDQUFDbEIsS0FBTCxDQUFXbUIsWUFBdkIsRUFBcUMsS0FBSSxDQUFDbkIsS0FBTCxDQUFXb0Isb0JBQWhELEVBQXNFRixJQUF0RSxDQUFWO0FBQUEsU0FESztBQUVsQkcsUUFBQUEsT0FBTyxFQUFFLEVBRlM7QUFHbEJDLFFBQUFBLGVBQWUsRUFBRSxLQUFLQSxlQUFMLENBQXFCQyxJQUFyQixDQUEwQixJQUExQixDQUhDO0FBSWxCQyxRQUFBQSxjQUFjLEVBQUUsS0FBS3hCLEtBQUwsQ0FBV3dCO0FBSlQsT0FBcEIsQ0FESyxDQUFQO0FBUUQ7OztFQWpDOENDLG9CIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE5IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtDb21wb3NpdGVMYXllcn0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5pbXBvcnQge1RpbGVMYXllciBhcyBEZWNrR0xUaWxlTGF5ZXJ9IGZyb20gJ0BkZWNrLmdsL2dlby1sYXllcnMnO1xuaW1wb3J0IHtnZXRUaWxlRGF0YX0gZnJvbSAnLi8zZC1idWlsZGluZy11dGlscyc7XG5pbXBvcnQge1NvbGlkUG9seWdvbkxheWVyfSBmcm9tICdAZGVjay5nbC9sYXllcnMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaHJlZURCdWlsZGluZ0xheWVyIGV4dGVuZHMgQ29tcG9zaXRlTGF5ZXIge1xuICAvLyB0aGlzIGxheWVyIGFkZCBpdHMgc3ViTGF5ZXJzIHRvIHRoZSByZWR1eCBzdG9yZSwgYW5kIHB1c2ggc2FtcGxlIGRhdGFcblxuICByZW5kZXJTdWJMYXllcnMocHJvcHMpIHtcbiAgICByZXR1cm4gbmV3IFNvbGlkUG9seWdvbkxheWVyKHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgcGFyYW1ldGVyOiB7XG4gICAgICAgIGJsZW5kRnVuYzogW1xuICAgICAgICAgICdTUkNfQUxQSEEnLFxuICAgICAgICAgICdPTkVfTUlOVVNfU1JDX0FMUEhBJyxcbiAgICAgICAgICAnT05FJyxcbiAgICAgICAgICAnT05FX01JTlVTX1NSQ19BTFBIQSdcbiAgICAgICAgXSxcbiAgICAgICAgYmxlbmRFcXVhdGlvbjogWydGVU5DX0FERCcsICdGVU5DX0FERCddXG4gICAgICB9LFxuICAgICAgZXh0cnVkZWQ6IHRydWUsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgZmlsbGVkOiB0cnVlLFxuICAgICAgZ2V0RWxldmF0aW9uOiAoZmVhdHVyZSkgPT4gZmVhdHVyZS5wcm9wZXJ0aWVzLmhlaWdodCB8fCAwLFxuICAgICAgZ2V0UG9seWdvbjogKGZlYXR1cmUpID0+IGZlYXR1cmUuY29vcmRpbmF0ZXMsXG4gICAgICBnZXRGaWxsQ29sb3I6IHRoaXMucHJvcHMudGhyZWVEQnVpbGRpbmdDb2xvclxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXJzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgRGVja0dMVGlsZUxheWVyKHtcbiAgICAgICAgZ2V0VGlsZURhdGE6IChhcmdzKSA9PiBnZXRUaWxlRGF0YSh0aGlzLnByb3BzLm1hcGJveEFwaVVybCwgdGhpcy5wcm9wcy5tYXBib3hBcGlBY2Nlc3NUb2tlbiwgYXJncyksXG4gICAgICAgIG1pblpvb206IDEzLFxuICAgICAgICByZW5kZXJTdWJMYXllcnM6IHRoaXMucmVuZGVyU3ViTGF5ZXJzLmJpbmQodGhpcyksXG4gICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB0aGlzLnByb3BzLnVwZGF0ZVRyaWdnZXJzXG4gICAgICB9KVxuICAgIF07XG4gIH1cbn1cbiJdfQ==