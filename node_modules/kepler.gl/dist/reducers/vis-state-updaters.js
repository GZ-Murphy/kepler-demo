"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateStateOnLayerVisibilityChange = updateStateOnLayerVisibilityChange;
exports.layerConfigChangeUpdater = layerConfigChangeUpdater;
exports.layerTextLabelChangeUpdater = layerTextLabelChangeUpdater;
exports.layerTypeChangeUpdater = layerTypeChangeUpdater;
exports.layerVisualChannelChangeUpdater = layerVisualChannelChangeUpdater;
exports.layerVisConfigChangeUpdater = layerVisConfigChangeUpdater;
exports.interactionConfigChangeUpdater = interactionConfigChangeUpdater;
exports.setFilterUpdater = setFilterUpdater;
exports.addDefaultLayers = addDefaultLayers;
exports.addDefaultTooltips = addDefaultTooltips;
exports.updateAllLayerDomainData = updateAllLayerDomainData;
exports.updateAnimationDomain = updateAnimationDomain;
exports.loadFilesUpdater = exports.updateVisDataUpdater = exports.toggleLayerForMapUpdater = exports.toggleSplitMapUpdater = exports.mouseMoveUpdater = exports.mapClickUpdater = exports.layerClickUpdater = exports.layerHoverUpdater = exports.receiveMapConfigUpdater = exports.resetMapConfigUpdater = exports.showDatasetTableUpdater = exports.updateLayerBlendingUpdater = exports.removeDatasetUpdater = exports.reorderLayerUpdater = exports.removeLayerUpdater = exports.addLayerUpdater = exports.removeFilterUpdater = exports.enlargeFilterUpdater = exports.updateLayerAnimationSpeedUpdater = exports.updateAnimationTimeUpdater = exports.updateFilterAnimationSpeedUpdater = exports.toggleFilterAnimationUpdater = exports.layerColorUIChangeUpdater = exports.addFilterUpdater = exports.setFilterPlotUpdater = exports.INITIAL_VIS_STATE = exports.defaultAnimationConfig = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _window = require("global/window");

var _tasks = _interopRequireWildcard(require("react-palm/tasks"));

var _lodash = _interopRequireDefault(require("lodash.clonedeep"));

var _tasks2 = require("../tasks/tasks");

var _visStateActions = require("../actions/vis-state-actions");

var _actions = require("../actions");

var _interactionUtils = require("../utils/interaction-utils");

var _filterUtils = require("../utils/filter-utils");

var _datasetUtils = require("../utils/dataset-utils");

var _layerUtils = require("../utils/layer-utils/layer-utils");

var _visStateMerger = require("./vis-state-merger");

var _splitMapUtils = require("../utils/split-map-utils");

var _layers = require("../layers");

var _fileUtils = require("../utils/file-utils");

var _layerFactory = require("../layers/layer-factory");

function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return (0, _typeof2["default"])(key) === "symbol" ? key : String(key); }

function _toPrimitive(input, hint) { if ((0, _typeof2["default"])(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if ((0, _typeof2["default"])(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// react-palm
// disable capture exception for react-palm call to withTask
(0, _tasks.disableStackCapturing)();
/**
 * Updaters for `visState` reducer. Can be used in your root reducer to directly modify kepler.gl's state.
 * Read more about [Using updaters](../advanced-usage/using-updaters.md)
 *
 * @public
 * @example
 *
 * import keplerGlReducer, {visStateUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    case 'CLICK_BUTTON':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          foo: {
 *             ...state.keplerGl.foo,
 *             visState: visStateUpdaters.enlargeFilterUpdater(
 *               state.keplerGl.foo.visState,
 *               {idx: 0}
 *             )
 *          }
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable no-unused-vars */

var visStateUpdaters = null;
/* eslint-enable no-unused-vars */

var defaultAnimationConfig = {
  domain: null,
  currentTime: null,
  speed: 1
};
/**
 * Default initial `visState`
 * @memberof visStateUpdaters
 * @constant
 * @type {Object}
 * @property {Array} layers
 * @property {Array} layerData
 * @property {Array} layerToBeMerged
 * @property {Array} layerOrder
 * @property {Array} filters
 * @property {Array} filterToBeMerged
 * @property {Array} datasets
 * @property {string} editingDataset
 * @property {Object} interactionConfig
 * @property {Object} interactionToBeMerged
 * @property {string} layerBlending
 * @property {Object} hoverInfo
 * @property {Object} clicked
 * @property {Object} mousePos
 * @property {Array} splitMaps - a list of objects of layer availabilities and visibilities for each map
 * @property {Object} layerClasses
 * @property {Object} animationConfig
 * @public
 */

exports.defaultAnimationConfig = defaultAnimationConfig;
var INITIAL_VIS_STATE = {
  // layers
  layers: [],
  layerData: [],
  layerToBeMerged: [],
  layerOrder: [],
  // filters
  filters: [],
  filterToBeMerged: [],
  // a collection of multiple dataset
  datasets: {},
  editingDataset: undefined,
  interactionConfig: (0, _interactionUtils.getDefaultInteraction)(),
  interactionToBeMerged: undefined,
  layerBlending: 'normal',
  hoverInfo: undefined,
  clicked: undefined,
  mousePos: {},
  // this is used when user split maps
  splitMaps: [// this will contain a list of objects to
    // describe the state of layer availability and visibility for each map
    // [
    //   {
    //      layers: {layer_id: true | false}
    //   }
    // ]
  ],
  //
  // defaults layer classes
  layerClasses: _layers.LayerClasses,
  // default animation
  // time in unix timestamp (milliseconds) (the number of seconds since the Unix Epoch)
  animationConfig: defaultAnimationConfig
};
exports.INITIAL_VIS_STATE = INITIAL_VIS_STATE;

function updateStateWithLayerAndData(state, _ref) {
  var layerData = _ref.layerData,
      layer = _ref.layer,
      idx = _ref.idx;
  return _objectSpread({}, state, {
    layers: state.layers.map(function (lyr, i) {
      return i === idx ? layer : lyr;
    }),
    layerData: layerData ? state.layerData.map(function (d, i) {
      return i === idx ? layerData : d;
    }) : state.layerData
  });
}

function updateStateOnLayerVisibilityChange(state, layer) {
  var newState = state;

  if (state.splitMaps.length) {
    newState = _objectSpread({}, state, {
      splitMaps: layer.config.isVisible ? (0, _splitMapUtils.addNewLayersToSplitMap)(state.splitMaps, layer) : (0, _splitMapUtils.removeLayerFromSplitMaps)(state.splitMaps, layer)
    });
  }

  if (layer.config.animation.enabled) {
    newState = updateAnimationDomain(state);
  }

  return newState;
}
/**
 * Update layer base config: dataId, label, column, isVisible
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.oldLayer layer to be updated
 * @param {Object} action.newConfig new config
 * @returns {Object} nextState
 */


function layerConfigChangeUpdater(state, action) {
  var oldLayer = action.oldLayer;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var props = Object.keys(action.newConfig);
  var newLayer = oldLayer.updateLayerConfig(action.newConfig);
  var layerData; // let newLayer;

  if (newLayer.shouldCalculateLayerData(props)) {
    var oldLayerData = state.layerData[idx];
    var updateLayerDataResult = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData, {
      sameData: true
    });
    layerData = updateLayerDataResult.layerData;
    newLayer = updateLayerDataResult.layer;
  }

  var newState = state;

  if ('isVisible' in action.newConfig) {
    newState = updateStateOnLayerVisibilityChange(state, newLayer);
  }

  return updateStateWithLayerAndData(newState, {
    layer: newLayer,
    layerData: layerData,
    idx: idx
  });
}

function addOrRemoveTextLabels(newFields, textLabel) {
  var newTextLabel = textLabel.slice();
  var currentFields = textLabel.map(function (tl) {
    return tl.field && tl.field.name;
  }).filter(function (d) {
    return d;
  });
  var addFields = newFields.filter(function (f) {
    return !currentFields.includes(f.name);
  });
  var deleteFields = currentFields.filter(function (f) {
    return !newFields.find(function (fd) {
      return fd.name === f;
    });
  }); // delete

  newTextLabel = newTextLabel.filter(function (tl) {
    return tl.field && !deleteFields.includes(tl.field.name);
  });
  newTextLabel = !newTextLabel.length ? [_layerFactory.DEFAULT_TEXT_LABEL] : newTextLabel; // add

  newTextLabel = [].concat((0, _toConsumableArray2["default"])(newTextLabel.filter(function (tl) {
    return tl.field;
  })), (0, _toConsumableArray2["default"])(addFields.map(function (af) {
    return _objectSpread({}, _layerFactory.DEFAULT_TEXT_LABEL, {
      field: af
    });
  })));
  return newTextLabel;
}

function updateTextLabelPropAndValue(idx, prop, value, textLabel) {
  if (!textLabel[idx].hasOwnProperty(prop)) {
    return textLabel;
  }

  var newTextLabel = textLabel.slice();

  if (prop && (value || textLabel.length === 1)) {
    newTextLabel = textLabel.map(function (tl, i) {
      return i === idx ? _objectSpread({}, tl, (0, _defineProperty2["default"])({}, prop, value)) : tl;
    });
  } else if (prop === 'field' && value === null && textLabel.length > 1) {
    // remove label when field value is set to null
    newTextLabel.splice(idx, 1);
  }

  return newTextLabel;
}

function layerTextLabelChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
      idx = action.idx,
      prop = action.prop,
      value = action.value;
  var textLabel = oldLayer.config.textLabel;
  var newTextLabel = textLabel.slice();

  if (!textLabel[idx] && idx === textLabel.length) {
    // if idx is set to length, add empty text label
    newTextLabel = [].concat((0, _toConsumableArray2["default"])(textLabel), [_layerFactory.DEFAULT_TEXT_LABEL]);
  }

  if (idx === 'all' && prop === 'fields') {
    newTextLabel = addOrRemoveTextLabels(value, textLabel);
  } else {
    newTextLabel = updateTextLabelPropAndValue(idx, prop, value, newTextLabel);
  } // update text label prop and value


  return layerConfigChangeUpdater(state, {
    oldLayer: oldLayer,
    newConfig: {
      textLabel: newTextLabel
    }
  });
}
/**
 * Update layer type. Previews layer config will be copied if applicable.
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.oldLayer layer to be updated
 * @param {string} action.newType new type
 * @returns {Object} nextState
 * @public
 */


function layerTypeChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
      newType = action.newType;

  if (!oldLayer) {
    return state;
  }

  var oldId = oldLayer.id;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldId;
  });

  if (!state.layerClasses[newType]) {
    _window.console.error("".concat(newType, " is not a valid layer type"));

    return state;
  } // get a mint layer, with new id and type
  // because deck.gl uses id to match between new and old layer.
  // If type has changed but id is the same, it will break


  var newLayer = new state.layerClasses[newType]();
  newLayer.assignConfigToLayer(oldLayer.config, oldLayer.visConfigSettings);

  if (newLayer.config.dataId) {
    var dataset = state.datasets[newLayer.config.dataId];
    newLayer.updateLayerDomain(dataset);
  }

  var _calculateLayerData = (0, _layerUtils.calculateLayerData)(newLayer, state),
      layerData = _calculateLayerData.layerData,
      layer = _calculateLayerData.layer;

  var newState = updateStateWithLayerAndData(state, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });

  if (layer.config.animation.enabled || oldLayer.config.animation.enabled) {
    newState = updateAnimationDomain(newState);
  } // update splitMap layer id


  if (state.splitMaps.length) {
    newState = _objectSpread({}, newState, {
      splitMaps: newState.splitMaps.map(function (settings) {
        var _settings$layers = settings.layers,
            oldLayerMap = _settings$layers[oldId],
            otherLayers = (0, _objectWithoutProperties2["default"])(_settings$layers, [oldId].map(_toPropertyKey));
        return oldId in settings.layers ? _objectSpread({}, settings, {
          layers: _objectSpread({}, otherLayers, (0, _defineProperty2["default"])({}, layer.id, oldLayerMap))
        }) : settings;
      })
    });
  }

  return newState;
}
/**
 * Update layer visual channel
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.oldLayer layer to be updated
 * @param {Object} action.newConfig new visual channel config
 * @param {string} action.channel channel to be updated
 * @returns {Object} nextState
 * @public
 */


function layerVisualChannelChangeUpdater(state, action) {
  var oldLayer = action.oldLayer,
      newConfig = action.newConfig,
      channel = action.channel;
  var dataset = state.datasets[oldLayer.config.dataId];
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var newLayer = oldLayer.updateLayerConfig(newConfig);
  newLayer.updateLayerVisualChannel(dataset, channel);
  var oldLayerData = state.layerData[idx];

  var _calculateLayerData2 = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData, {
    sameData: true
  }),
      layerData = _calculateLayerData2.layerData,
      layer = _calculateLayerData2.layer;

  return updateStateWithLayerAndData(state, {
    layerData: layerData,
    layer: layer,
    idx: idx
  });
}
/**
 * Update layer `visConfig`
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.oldLayer layer to be updated
 * @param {Object} action.newVisConfig new visConfig as a key value map: e.g. `{opacity: 0.8}`
 * @returns {Object} nextState
 * @public
 */


function layerVisConfigChangeUpdater(state, action) {
  var oldLayer = action.oldLayer;
  var idx = state.layers.findIndex(function (l) {
    return l.id === oldLayer.id;
  });
  var props = Object.keys(action.newVisConfig);

  var newVisConfig = _objectSpread({}, oldLayer.config.visConfig, {}, action.newVisConfig);

  var newLayer = oldLayer.updateLayerConfig({
    visConfig: newVisConfig
  });

  if (newLayer.shouldCalculateLayerData(props)) {
    var oldLayerData = state.layerData[idx];

    var _calculateLayerData3 = (0, _layerUtils.calculateLayerData)(newLayer, state, oldLayerData, {
      sameData: true
    }),
        layerData = _calculateLayerData3.layerData,
        layer = _calculateLayerData3.layer;

    return updateStateWithLayerAndData(state, {
      layerData: layerData,
      layer: layer,
      idx: idx
    });
  }

  return updateStateWithLayerAndData(state, {
    layer: newLayer,
    idx: idx
  });
}
/* eslint-enable max-statements */

/**
 * Update `interactionConfig`
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.config new config as key value map: `{tooltip: {enabled: true}}`
 * @returns {Object} nextState
 * @public
 */


function interactionConfigChangeUpdater(state, action) {
  var config = action.config;

  var interactionConfig = _objectSpread({}, state.interactionConfig, {}, (0, _defineProperty2["default"])({}, config.id, config)); // Don't enable tooltip and brush at the same time
  // but coordinates can be shown at all time


  var contradict = ['brush', 'tooltip'];

  if (contradict.includes(config.id) && config.enabled && !state.interactionConfig[config.id].enabled) {
    // only enable one interaction at a time
    contradict.forEach(function (k) {
      if (k !== config.id) {
        interactionConfig[k] = _objectSpread({}, interactionConfig[k], {
          enabled: false
        });
      }
    });
  }

  return _objectSpread({}, state, {
    interactionConfig: interactionConfig
  });
}
/**
 * Update filter property
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.idx `idx` of filter to be updated
 * @param {string} action.prop `prop` of filter, e,g, `dataId`, `name`, `value`
 * @param {*} action.value new value
 * @returns {Object} nextState
 * @public
 */


function setFilterUpdater(state, action) {
  var idx = action.idx,
      prop = action.prop,
      value = action.value;
  var newState = state;

  var newFilter = _objectSpread({}, state.filters[idx], (0, _defineProperty2["default"])({}, prop, value));

  var _newFilter = newFilter,
      dataId = _newFilter.dataId;

  if (!dataId) {
    return state;
  }

  var _state$datasets$dataI = state.datasets[dataId],
      fields = _state$datasets$dataI.fields,
      allData = _state$datasets$dataI.allData;

  switch (prop) {
    case 'dataId':
      // if trying to update filter dataId. create an empty new filter
      newFilter = (0, _filterUtils.getDefaultFilter)(dataId);
      break;

    case 'name':
      // find the field
      var fieldIdx = fields.findIndex(function (f) {
        return f.name === value;
      });
      var field = fields[fieldIdx];

      if (!field.filterProp) {
        // get filter domain from field
        // save filterProps: {domain, steps, value} to field, avoid recalculate
        field = _objectSpread({}, field, {
          filterProp: (0, _filterUtils.getFilterProps)(allData, field)
        });
      }

      newFilter = _objectSpread({}, newFilter, {}, field.filterProp, {
        name: field.name,
        // can't edit dataId once name is selected
        freeze: true,
        fieldIdx: fieldIdx
      });
      var enlargedFilterIdx = state.filters.findIndex(function (f) {
        return f.enlarged;
      });

      if (enlargedFilterIdx > -1 && enlargedFilterIdx !== idx) {
        // there should be only one enlarged filter
        newFilter.enlarged = false;
      }

      newState = _objectSpread({}, state, {
        datasets: _objectSpread({}, state.datasets, (0, _defineProperty2["default"])({}, dataId, _objectSpread({}, state.datasets[dataId], {
          fields: fields.map(function (d, i) {
            return i === fieldIdx ? field : d;
          })
        })))
      });
      break;

    case 'value':
    default:
      break;
  } // save new filters to newState


  newState = _objectSpread({}, newState, {
    filters: state.filters.map(function (f, i) {
      return i === idx ? newFilter : f;
    })
  }); // filter data

  newState = _objectSpread({}, newState, {
    datasets: _objectSpread({}, newState.datasets, (0, _defineProperty2["default"])({}, dataId, _objectSpread({}, newState.datasets[dataId], {}, (0, _filterUtils.filterData)(allData, dataId, newState.filters))))
  });
  newState = updateAllLayerDomainData(newState, dataId, newFilter);
  return newState;
}
/**
 * Set the property of a filter plot
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.idx
 * @param {Object} action.newProp key value mapping of new prop `{yAxis: 'histogram'}`
 * @returns {Object} nextState
 * @public
 */


var setFilterPlotUpdater = function setFilterPlotUpdater(state, _ref2) {
  var idx = _ref2.idx,
      newProp = _ref2.newProp;

  var newFilter = _objectSpread({}, state.filters[idx], {}, newProp);

  var prop = Object.keys(newProp)[0];

  if (prop === 'yAxis') {
    var plotType = (0, _filterUtils.getDefaultFilterPlotType)(newFilter);

    if (plotType) {
      newFilter = _objectSpread({}, newFilter, {}, (0, _filterUtils.getFilterPlot)(_objectSpread({}, newFilter, {
        plotType: plotType
      }), state.datasets[newFilter.dataId].allData), {
        plotType: plotType
      });
    }
  }

  return _objectSpread({}, state, {
    filters: state.filters.map(function (f, i) {
      return i === idx ? newFilter : f;
    })
  });
};
/**
 * Add a new filter
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {string} action.dataId dataset `id` this new filter is associated with
 * @returns {Object} nextState
 * @public
 */


exports.setFilterPlotUpdater = setFilterPlotUpdater;

var addFilterUpdater = function addFilterUpdater(state, action) {
  return !action.dataId ? state : _objectSpread({}, state, {
    filters: [].concat((0, _toConsumableArray2["default"])(state.filters), [(0, _filterUtils.getDefaultFilter)(action.dataId)])
  });
};
/**
 * Set layer color palette ui state
 * @memberof visStateUpdaters
 * @param {Object} state
 * @param {Object} action
 * @param {Object} action.prop
 * @param {Object} action.newConfig
 */


exports.addFilterUpdater = addFilterUpdater;

var layerColorUIChangeUpdater = function layerColorUIChangeUpdater(state, _ref3) {
  var oldLayer = _ref3.oldLayer,
      prop = _ref3.prop,
      newConfig = _ref3.newConfig;
  var newLayer = oldLayer.updateLayerColorUI(prop, newConfig);
  return _objectSpread({}, state, {
    layers: state.layers.map(function (l) {
      return l.id === oldLayer.id ? newLayer : l;
    })
  });
};
/**
 * Start and end filter animation
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.idx idx of filter
 * @returns {Object} nextState
 * @public
 */


exports.layerColorUIChangeUpdater = layerColorUIChangeUpdater;

var toggleFilterAnimationUpdater = function toggleFilterAnimationUpdater(state, action) {
  return _objectSpread({}, state, {
    filters: state.filters.map(function (f, i) {
      return i === action.idx ? _objectSpread({}, f, {
        isAnimating: !f.isAnimating
      }) : f;
    })
  });
};
/**
 * Change filter animation speed
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.idx  `idx` of filter
 * @param {Number} action.speed `speed` to change it to. `speed` is a multiplier
 * @returns {Object} nextState
 * @public
 */


exports.toggleFilterAnimationUpdater = toggleFilterAnimationUpdater;

var updateFilterAnimationSpeedUpdater = function updateFilterAnimationSpeedUpdater(state, action) {
  return _objectSpread({}, state, {
    filters: state.filters.map(function (f, i) {
      return i === action.idx ? _objectSpread({}, f, {
        speed: action.speed
      }) : f;
    })
  });
};
/**
 * Reset animation config current time to a specified value
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.value the value current time will be set to
 * @returns {Object} nextState
 * @public
 *
 */


exports.updateFilterAnimationSpeedUpdater = updateFilterAnimationSpeedUpdater;

var updateAnimationTimeUpdater = function updateAnimationTimeUpdater(state, _ref4) {
  var value = _ref4.value;
  return _objectSpread({}, state, {
    animationConfig: _objectSpread({}, state.animationConfig, {
      currentTime: value
    })
  });
};
/**
 * Update animation speed with the vertical speed slider
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.speed the updated speed of the animation
 * @returns {Object} nextState
 * @public
 *
 */


exports.updateAnimationTimeUpdater = updateAnimationTimeUpdater;

var updateLayerAnimationSpeedUpdater = function updateLayerAnimationSpeedUpdater(state, _ref5) {
  var speed = _ref5.speed;
  return _objectSpread({}, state, {
    animationConfig: _objectSpread({}, state.animationConfig, {
      speed: speed
    })
  });
};
/**
 * Show larger time filter at bottom for time playback (apply to time filter only)
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.idx index of filter to enlarge
 * @returns {Object} nextState
 * @public
 */


exports.updateLayerAnimationSpeedUpdater = updateLayerAnimationSpeedUpdater;

var enlargeFilterUpdater = function enlargeFilterUpdater(state, action) {
  var isEnlarged = state.filters[action.idx].enlarged;
  return _objectSpread({}, state, {
    filters: state.filters.map(function (f, i) {
      f.enlarged = !isEnlarged && i === action.idx;
      return f;
    })
  });
};
/**
 * Remove a filter
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.idx index of filter to b e removed
 * @returns {Object} nextState
 * @public
 */


exports.enlargeFilterUpdater = enlargeFilterUpdater;

var removeFilterUpdater = function removeFilterUpdater(state, action) {
  var idx = action.idx;
  var dataId = state.filters[idx].dataId;
  var newFilters = [].concat((0, _toConsumableArray2["default"])(state.filters.slice(0, idx)), (0, _toConsumableArray2["default"])(state.filters.slice(idx + 1, state.filters.length)));

  var newState = _objectSpread({}, state, {
    datasets: _objectSpread({}, state.datasets, (0, _defineProperty2["default"])({}, dataId, _objectSpread({}, state.datasets[dataId], {}, (0, _filterUtils.filterData)(state.datasets[dataId].allData, dataId, newFilters)))),
    filters: newFilters
  });

  return updateAllLayerDomainData(newState, dataId);
};
/**
 * Add a new layer
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.props - new layer props
 * @returns {Object} nextState
 * @public
 */


exports.removeFilterUpdater = removeFilterUpdater;

var addLayerUpdater = function addLayerUpdater(state, action) {
  var defaultDataset = Object.keys(state.datasets)[0];
  var newLayer = new _layers.Layer(_objectSpread({
    isVisible: true,
    isConfigActive: true,
    dataId: defaultDataset
  }, action.props));
  return _objectSpread({}, state, {
    layers: [].concat((0, _toConsumableArray2["default"])(state.layers), [newLayer]),
    layerData: [].concat((0, _toConsumableArray2["default"])(state.layerData), [{}]),
    layerOrder: [].concat((0, _toConsumableArray2["default"])(state.layerOrder), [state.layerOrder.length]),
    splitMaps: (0, _splitMapUtils.addNewLayersToSplitMap)(state.splitMaps, newLayer)
  });
};
/**
 * remove layer
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number} action.idx index of layer to b e removed
 * @returns {Object} nextState
 * @public
 */


exports.addLayerUpdater = addLayerUpdater;

var removeLayerUpdater = function removeLayerUpdater(state, _ref6) {
  var idx = _ref6.idx;
  var layers = state.layers,
      layerData = state.layerData,
      clicked = state.clicked,
      hoverInfo = state.hoverInfo;
  var layerToRemove = state.layers[idx];
  var newMaps = (0, _splitMapUtils.removeLayerFromSplitMaps)(state.splitMaps, layerToRemove);

  var newState = _objectSpread({}, state, {
    layers: [].concat((0, _toConsumableArray2["default"])(layers.slice(0, idx)), (0, _toConsumableArray2["default"])(layers.slice(idx + 1, layers.length))),
    layerData: [].concat((0, _toConsumableArray2["default"])(layerData.slice(0, idx)), (0, _toConsumableArray2["default"])(layerData.slice(idx + 1, layerData.length))),
    layerOrder: state.layerOrder.filter(function (i) {
      return i !== idx;
    }).map(function (pid) {
      return pid > idx ? pid - 1 : pid;
    }),
    clicked: layerToRemove.isLayerHovered(clicked) ? undefined : clicked,
    hoverInfo: layerToRemove.isLayerHovered(hoverInfo) ? undefined : hoverInfo,
    splitMaps: newMaps
  });

  return updateAnimationDomain(newState);
};
/**
 * Reorder layer
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Array<Number>} action.order an array of layer indexes
 * @returns {Object} nextState
 * @public
 */


exports.removeLayerUpdater = removeLayerUpdater;

var reorderLayerUpdater = function reorderLayerUpdater(state, _ref7) {
  var order = _ref7.order;
  return _objectSpread({}, state, {
    layerOrder: order
  });
};
/**
 * Remove a dataset and all layers, filters, tooltip configs that based on it
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {string} action.key dataset id
 * @returns {Object} nextState
 * @public
 */


exports.reorderLayerUpdater = reorderLayerUpdater;

var removeDatasetUpdater = function removeDatasetUpdater(state, action) {
  // extract dataset key
  var datasetKey = action.key;
  var datasets = state.datasets; // check if dataset is present

  if (!datasets[datasetKey]) {
    return state;
  }
  /* eslint-disable no-unused-vars */


  var layers = state.layers,
      _state$datasets = state.datasets,
      dataset = _state$datasets[datasetKey],
      newDatasets = (0, _objectWithoutProperties2["default"])(_state$datasets, [datasetKey].map(_toPropertyKey));
  /* eslint-enable no-unused-vars */

  var indexes = layers.reduce(function (listOfIndexes, layer, index) {
    if (layer.config.dataId === datasetKey) {
      listOfIndexes.push(index);
    }

    return listOfIndexes;
  }, []); // remove layers and datasets

  var _indexes$reduce = indexes.reduce(function (_ref8, idx) {
    var currentState = _ref8.newState,
        indexCounter = _ref8.indexCounter;
    var currentIndex = idx - indexCounter;
    currentState = removeLayerUpdater(currentState, {
      idx: currentIndex
    });
    indexCounter++;
    return {
      newState: currentState,
      indexCounter: indexCounter
    };
  }, {
    newState: _objectSpread({}, state, {
      datasets: newDatasets
    }),
    indexCounter: 0
  }),
      newState = _indexes$reduce.newState; // remove filters


  var filters = state.filters.filter(function (filter) {
    return filter.dataId !== datasetKey;
  }); // update interactionConfig

  var interactionConfig = state.interactionConfig;
  var _interactionConfig = interactionConfig,
      tooltip = _interactionConfig.tooltip;

  if (tooltip) {
    var config = tooltip.config;
    /* eslint-disable no-unused-vars */

    var _config$fieldsToShow = config.fieldsToShow,
        fields = _config$fieldsToShow[datasetKey],
        fieldsToShow = (0, _objectWithoutProperties2["default"])(_config$fieldsToShow, [datasetKey].map(_toPropertyKey));
    /* eslint-enable no-unused-vars */

    interactionConfig = _objectSpread({}, interactionConfig, {
      tooltip: _objectSpread({}, tooltip, {
        config: _objectSpread({}, config, {
          fieldsToShow: fieldsToShow
        })
      })
    });
  }

  return _objectSpread({}, newState, {
    filters: filters,
    interactionConfig: interactionConfig
  });
};
/**
 * update layer blending mode
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {string} action.mode one of `additive`, `normal` and `subtractive`
 * @returns {Object} nextState
 * @public
 */


exports.removeDatasetUpdater = removeDatasetUpdater;

var updateLayerBlendingUpdater = function updateLayerBlendingUpdater(state, action) {
  return _objectSpread({}, state, {
    layerBlending: action.mode
  });
};
/**
 * Display dataset table in a modal
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {string} action.dataId dataset id to show in table
 * @returns {Object} nextState
 * @public
 */


exports.updateLayerBlendingUpdater = updateLayerBlendingUpdater;

var showDatasetTableUpdater = function showDatasetTableUpdater(state, action) {
  return _objectSpread({}, state, {
    editingDataset: action.dataId
  });
};
/**
 * reset visState to initial State
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @returns {Object} nextState
 * @public
 */


exports.showDatasetTableUpdater = showDatasetTableUpdater;

var resetMapConfigUpdater = function resetMapConfigUpdater(state) {
  return _objectSpread({}, INITIAL_VIS_STATE, {}, state.initialState, {
    initialState: state.initialState
  });
};
/**
 * Propagate `visState` reducer with a new configuration. Current config will be override.
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.payload map config to be propagated
 * @param {Object} action.payload.config map config to be propagated
 * @param {Object} action.payload.option {keepExistingConfig: true | false}
 * @returns {Object} nextState
 * @public
 */


exports.resetMapConfigUpdater = resetMapConfigUpdater;

var receiveMapConfigUpdater = function receiveMapConfigUpdater(state, _ref9) {
  var _ref9$payload = _ref9.payload,
      _ref9$payload$config = _ref9$payload.config,
      config = _ref9$payload$config === void 0 ? {} : _ref9$payload$config,
      _ref9$payload$options = _ref9$payload.options,
      options = _ref9$payload$options === void 0 ? {} : _ref9$payload$options;

  if (!config.visState) {
    return state;
  }

  var _config$visState = config.visState,
      filters = _config$visState.filters,
      layers = _config$visState.layers,
      interactionConfig = _config$visState.interactionConfig,
      layerBlending = _config$visState.layerBlending,
      splitMaps = _config$visState.splitMaps,
      animationConfig = _config$visState.animationConfig;
  var keepExistingConfig = options.keepExistingConfig; // reset config if keepExistingConfig is falsy

  var mergedState = !keepExistingConfig ? resetMapConfigUpdater(state) : state;
  mergedState = (0, _visStateMerger.mergeFilters)(mergedState, filters);
  mergedState = (0, _visStateMerger.mergeLayers)(mergedState, layers);
  mergedState = (0, _visStateMerger.mergeInteractions)(mergedState, interactionConfig);
  mergedState = (0, _visStateMerger.mergeLayerBlending)(mergedState, layerBlending);
  mergedState = (0, _visStateMerger.mergeSplitMaps)(mergedState, splitMaps);
  mergedState = (0, _visStateMerger.mergeAnimationConfig)(mergedState, animationConfig);
  return mergedState;
};
/**
 * Trigger layer hover event with hovered object
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.info Object hovered, returned by deck.gl
 * @returns {Object} nextState
 * @public
 */


exports.receiveMapConfigUpdater = receiveMapConfigUpdater;

var layerHoverUpdater = function layerHoverUpdater(state, action) {
  return _objectSpread({}, state, {
    hoverInfo: action.info
  });
};
/**
 * Trigger layer click event with clicked object
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Object} action.info Object clicked, returned by deck.gl
 * @returns {Object} nextState
 * @public
 */


exports.layerHoverUpdater = layerHoverUpdater;

var layerClickUpdater = function layerClickUpdater(state, action) {
  return _objectSpread({}, state, {
    mousePos: state.interactionConfig.coordinate.enabled ? _objectSpread({}, state.mousePos, {
      pinned: state.mousePos.pinned ? null : (0, _lodash["default"])(state.mousePos)
    }) : state.mousePos,
    clicked: action.info && action.info.picked ? action.info : null
  });
};
/**
 * Trigger map click event, unselect clicked object
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @returns {Object} nextState
 * @public
 */


exports.layerClickUpdater = layerClickUpdater;

var mapClickUpdater = function mapClickUpdater(state) {
  return _objectSpread({}, state, {
    clicked: null
  });
};

exports.mapClickUpdater = mapClickUpdater;

var mouseMoveUpdater = function mouseMoveUpdater(state, _ref10) {
  var evt = _ref10.evt;

  if (Object.values(state.interactionConfig).some(function (config) {
    return config.enabled;
  })) {
    return _objectSpread({}, state, {
      mousePos: _objectSpread({}, state.mousePos, {
        mousePosition: (0, _toConsumableArray2["default"])(evt.point),
        coordinate: (0, _toConsumableArray2["default"])(evt.lngLat)
      })
    });
  }

  return state;
};
/**
 * Toggle visibility of a layer for a split map
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Number|undefined} action.payload index of the split map
 * @returns {Object} nextState
 * @public
 */


exports.mouseMoveUpdater = mouseMoveUpdater;

var toggleSplitMapUpdater = function toggleSplitMapUpdater(state, action) {
  return state.splitMaps && state.splitMaps.length === 0 ? _objectSpread({}, state, {
    // maybe we should use an array to store state for a single map as well
    // if current maps length is equal to 0 it means that we are about to split the view
    splitMaps: (0, _splitMapUtils.computeSplitMapLayers)(state.layers)
  }) : closeSpecificMapAtIndex(state, action);
};
/**
 * Toggle visibility of a layer in a split map
 * @memberof visStateUpdaters
 * @param {Object} state
 * @param {Object} action
 * @param {Number} action.mapIndex index of the split map
 * @param {string} action.layerId id of the layer
 * @returns {Object} nextState
 * @public
 */


exports.toggleSplitMapUpdater = toggleSplitMapUpdater;

var toggleLayerForMapUpdater = function toggleLayerForMapUpdater(state, _ref11) {
  var mapIndex = _ref11.mapIndex,
      layerId = _ref11.layerId;
  var splitMaps = state.splitMaps;
  return _objectSpread({}, state, {
    splitMaps: splitMaps.map(function (sm, i) {
      return i === mapIndex ? _objectSpread({}, splitMaps[i], {
        layers: _objectSpread({}, splitMaps[i].layers, (0, _defineProperty2["default"])({}, layerId, !splitMaps[i].layers[layerId]))
      }) : sm;
    })
  });
};
/**
 * Add new dataset to `visState`, with option to load a map config along with the datasets
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Array<Object>|Object} action.datasets - ***required** datasets can be a dataset or an array of datasets
 * Each dataset object needs to have `info` and `data` property.
 * @param {Object} action.datasets.info -info of a dataset
 * @param {string} action.datasets.info.id - id of this dataset. If config is defined, `id` should matches the `dataId` in config.
 * @param {string} action.datasets.info.label - A display name of this dataset
 * @param {Object} action.datasets.data - ***required** The data object, in a tabular format with 2 properties `fields` and `rows`
 * @param {Array<Object>} action.datasets.data.fields - ***required** Array of fields,
 * @param {string} action.datasets.data.fields.name - ***required** Name of the field,
 * @param {Array<Array>} action.datasets.data.rows - ***required** Array of rows, in a tabular format with `fields` and `rows`
 * @param {Object} action.options option object `{centerMap: true, keepExistingConfig: false}`
 * @param {Object} action.config map config
 * @returns {Object} nextState
 * @public
 */

/* eslint-disable max-statements */


exports.toggleLayerForMapUpdater = toggleLayerForMapUpdater;

var updateVisDataUpdater = function updateVisDataUpdater(state, action) {
  // datasets can be a single data entries or an array of multiple data entries
  var config = action.config,
      options = action.options;
  var datasets = Array.isArray(action.datasets) ? action.datasets : [action.datasets];
  var newDateEntries = datasets.reduce(function (accu, _ref12) {
    var _ref12$info = _ref12.info,
        info = _ref12$info === void 0 ? {} : _ref12$info,
        data = _ref12.data;
    return _objectSpread({}, accu, {}, (0, _datasetUtils.createNewDataEntry)({
      info: info,
      data: data
    }, state.datasets) || {});
  }, {});

  if (!Object.keys(newDateEntries).length) {
    return state;
  } // apply config if passed from action


  var previousState = config ? receiveMapConfigUpdater(state, {
    payload: {
      config: config,
      options: options
    }
  }) : state;

  var stateWithNewData = _objectSpread({}, previousState, {
    datasets: _objectSpread({}, previousState.datasets, {}, newDateEntries)
  }); // previously saved config before data loaded


  var _stateWithNewData$fil = stateWithNewData.filterToBeMerged,
      filterToBeMerged = _stateWithNewData$fil === void 0 ? [] : _stateWithNewData$fil,
      _stateWithNewData$lay = stateWithNewData.layerToBeMerged,
      layerToBeMerged = _stateWithNewData$lay === void 0 ? [] : _stateWithNewData$lay,
      _stateWithNewData$int = stateWithNewData.interactionToBeMerged,
      interactionToBeMerged = _stateWithNewData$int === void 0 ? {} : _stateWithNewData$int,
      _stateWithNewData$spl = stateWithNewData.splitMapsToBeMerged,
      splitMapsToBeMerged = _stateWithNewData$spl === void 0 ? [] : _stateWithNewData$spl; // merge state with saved filters

  var mergedState = (0, _visStateMerger.mergeFilters)(stateWithNewData, filterToBeMerged); // merge state with saved layers

  mergedState = (0, _visStateMerger.mergeLayers)(mergedState, layerToBeMerged); // merge state with saved splitMaps

  mergedState = (0, _visStateMerger.mergeSplitMaps)(mergedState, splitMapsToBeMerged);
  var newLayers = mergedState.layers.filter(function (l) {
    return l.config.dataId in newDateEntries;
  });

  if (!newLayers.length) {
    // no layer merged, find defaults
    var result = addDefaultLayers(mergedState, newDateEntries);
    mergedState = result.state;
    newLayers = result.newLayers;
  }

  if (mergedState.splitMaps.length) {
    // if map is split, add new layers to splitMaps
    newLayers = mergedState.layers.filter(function (l) {
      return l.config.dataId in newDateEntries;
    });
    mergedState = _objectSpread({}, mergedState, {
      splitMaps: (0, _splitMapUtils.addNewLayersToSplitMap)(mergedState.splitMaps, newLayers)
    });
  } // merge state with saved interactions


  mergedState = (0, _visStateMerger.mergeInteractions)(mergedState, interactionToBeMerged); // if no tooltips merged add default tooltips

  Object.keys(newDateEntries).forEach(function (dataId) {
    var tooltipFields = mergedState.interactionConfig.tooltip.config.fieldsToShow[dataId];

    if (!Array.isArray(tooltipFields) || !tooltipFields.length) {
      mergedState = addDefaultTooltips(mergedState, newDateEntries[dataId]);
    }
  });
  var updatedState = updateAllLayerDomainData(mergedState, Object.keys(newDateEntries)); // register layer animation domain,
  // need to be called after layer data is calculated

  updatedState = updateAnimationDomain(updatedState);
  return updatedState;
};
/* eslint-enable max-statements */

/**
 * When a user clicks on the specific map closing icon
 * the application will close the selected map
 * and will merge the remaining one with the global state
 * TODO: i think in the future this action should be called merge map layers with global settings
 * @param {Object} state `visState`
 * @param {Object} action action
 * @returns {Object} nextState
 */


exports.updateVisDataUpdater = updateVisDataUpdater;

function closeSpecificMapAtIndex(state, action) {
  // retrieve layers meta data from the remaining map that we need to keep
  var indexToRetrieve = 1 - action.payload;
  var mapLayers = state.splitMaps[indexToRetrieve].layers;
  var layers = state.layers; // update layer visibility

  var newLayers = layers.map(function (layer) {
    return !mapLayers[layer.id] && layer.config.isVisible ? layer.updateLayerConfig({
      // if layer.id is not in mapLayers, it should be inVisible
      isVisible: false
    }) : layer;
  }); // delete map

  return _objectSpread({}, state, {
    layers: newLayers,
    splitMaps: []
  });
}
/**
 * Trigger file loading dispatch `addDataToMap` if succeed, or `loadFilesErr` if failed
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Object} action action
 * @param {Array<Object>} action.files array of fileblob
 * @returns {Object} nextState
 * @public
 */


var loadFilesUpdater = function loadFilesUpdater(state, action) {
  var files = action.files;
  var filesToLoad = files.map(function (fileBlob) {
    return (0, _fileUtils.processFileToLoad)(fileBlob);
  }); // reader -> parser -> augment -> receiveVisData

  var loadFileTasks = [_tasks["default"].all(filesToLoad.map(_tasks2.LOAD_FILE_TASK)).bimap(function (results) {
    var data = results.reduce(function (f, c) {
      return {
        // using concat here because the current datasets could be an array or a single item
        datasets: f.datasets.concat(c.datasets),
        // we need to deep merge this thing unless we find a better solution
        // this case will only happen if we allow to load multiple keplergl json files
        config: _objectSpread({}, f.config, {}, c.config || {})
      };
    }, {
      datasets: [],
      config: {},
      options: {
        centerMap: true
      }
    });
    return (0, _actions.addDataToMap)(data);
  }, _visStateActions.loadFilesErr)];
  return (0, _tasks.withTask)(state, loadFileTasks);
};
/**
 * Helper function to update All layer domain and layer data of state
 * @memberof visStateUpdaters
 * @param {Object} state `visState`
 * @param {Array<string>} datasets
 * @returns {Object} nextState
 */


exports.loadFilesUpdater = loadFilesUpdater;

function addDefaultLayers(state, datasets) {
  var defaultLayers = Object.values(datasets).reduce(function (accu, dataset) {
    return [].concat((0, _toConsumableArray2["default"])(accu), (0, _toConsumableArray2["default"])((0, _layerUtils.findDefaultLayer)(dataset, state.layerClasses) || []));
  }, []);
  return {
    state: _objectSpread({}, state, {
      layers: [].concat((0, _toConsumableArray2["default"])(state.layers), (0, _toConsumableArray2["default"])(defaultLayers)),
      layerOrder: [].concat((0, _toConsumableArray2["default"])(defaultLayers.map(function (_, i) {
        return state.layers.length + i;
      })), (0, _toConsumableArray2["default"])(state.layerOrder))
    }),
    newLayers: defaultLayers
  };
}
/**
 * helper function to find default tooltips
 * @param {Object} state
 * @param {Object} dataset
 * @returns {Object} nextState
 */


function addDefaultTooltips(state, dataset) {
  var tooltipFields = (0, _interactionUtils.findFieldsToShow)(dataset);
  return _objectSpread({}, state, {
    interactionConfig: _objectSpread({}, state.interactionConfig, {
      tooltip: _objectSpread({}, state.interactionConfig.tooltip, {
        config: {
          // find default fields to show in tooltip
          fieldsToShow: _objectSpread({}, state.interactionConfig.tooltip.config.fieldsToShow, {}, tooltipFields)
        }
      })
    })
  });
}
/**
 * Helper function to update layer domains for an array of datsets
 * @param {Object} state
 * @param {Array|Array<string>} dataId dataset id or array of dataset ids
 * @param {Object} newFilter if is called by setFilter, the filter that has changed
 * @returns {Object} nextState
 */


function updateAllLayerDomainData(state, dataId, newFilter) {
  var dataIds = typeof dataId === 'string' ? [dataId] : dataId;
  var newLayers = [];
  var newLayerDatas = [];
  state.layers.forEach(function (oldLayer, i) {
    if (oldLayer.config.dataId && dataIds.includes(oldLayer.config.dataId)) {
      // No need to recalculate layer domain if filter has fixed domain
      var newLayer = newFilter && newFilter.fixedDomain ? oldLayer : oldLayer.updateLayerDomain(state.datasets[oldLayer.config.dataId], newFilter);

      var _calculateLayerData4 = (0, _layerUtils.calculateLayerData)(newLayer, state, state.layerData[i]),
          layerData = _calculateLayerData4.layerData,
          layer = _calculateLayerData4.layer;

      newLayers.push(layer);
      newLayerDatas.push(layerData);
    } else {
      newLayers.push(oldLayer);
      newLayerDatas.push(state.layerData[i]);
    }
  });

  var newState = _objectSpread({}, state, {
    layers: newLayers,
    layerData: newLayerDatas
  });

  return newState;
}

function updateAnimationDomain(state) {
  // merge all animatable layer domain and update global config
  var animatableLayers = state.layers.filter(function (l) {
    return l.config.isVisible && l.config.animation && l.config.animation.enabled && Array.isArray(l.animationDomain);
  });

  if (!animatableLayers.length) {
    return _objectSpread({}, state, {
      animationConfig: defaultAnimationConfig
    });
  }

  var mergedDomain = animatableLayers.reduce(function (accu, layer) {
    return [Math.min(accu[0], layer.animationDomain[0]), Math.max(accu[1], layer.animationDomain[1])];
  }, [Number(Infinity), -Infinity]);
  return _objectSpread({}, state, {
    animationConfig: _objectSpread({}, state.animationConfig, {
      currentTime: (0, _filterUtils.isInRange)(state.animationConfig.currentTime, mergedDomain) ? state.animationConfig.currentTime : mergedDomain[0],
      domain: mergedDomain
    })
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWR1Y2Vycy92aXMtc3RhdGUtdXBkYXRlcnMuanMiXSwibmFtZXMiOlsidmlzU3RhdGVVcGRhdGVycyIsImRlZmF1bHRBbmltYXRpb25Db25maWciLCJkb21haW4iLCJjdXJyZW50VGltZSIsInNwZWVkIiwiSU5JVElBTF9WSVNfU1RBVEUiLCJsYXllcnMiLCJsYXllckRhdGEiLCJsYXllclRvQmVNZXJnZWQiLCJsYXllck9yZGVyIiwiZmlsdGVycyIsImZpbHRlclRvQmVNZXJnZWQiLCJkYXRhc2V0cyIsImVkaXRpbmdEYXRhc2V0IiwidW5kZWZpbmVkIiwiaW50ZXJhY3Rpb25Db25maWciLCJpbnRlcmFjdGlvblRvQmVNZXJnZWQiLCJsYXllckJsZW5kaW5nIiwiaG92ZXJJbmZvIiwiY2xpY2tlZCIsIm1vdXNlUG9zIiwic3BsaXRNYXBzIiwibGF5ZXJDbGFzc2VzIiwiTGF5ZXJDbGFzc2VzIiwiYW5pbWF0aW9uQ29uZmlnIiwidXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhIiwic3RhdGUiLCJsYXllciIsImlkeCIsIm1hcCIsImx5ciIsImkiLCJkIiwidXBkYXRlU3RhdGVPbkxheWVyVmlzaWJpbGl0eUNoYW5nZSIsIm5ld1N0YXRlIiwibGVuZ3RoIiwiY29uZmlnIiwiaXNWaXNpYmxlIiwiYW5pbWF0aW9uIiwiZW5hYmxlZCIsInVwZGF0ZUFuaW1hdGlvbkRvbWFpbiIsImxheWVyQ29uZmlnQ2hhbmdlVXBkYXRlciIsImFjdGlvbiIsIm9sZExheWVyIiwiZmluZEluZGV4IiwibCIsImlkIiwicHJvcHMiLCJPYmplY3QiLCJrZXlzIiwibmV3Q29uZmlnIiwibmV3TGF5ZXIiLCJ1cGRhdGVMYXllckNvbmZpZyIsInNob3VsZENhbGN1bGF0ZUxheWVyRGF0YSIsIm9sZExheWVyRGF0YSIsInVwZGF0ZUxheWVyRGF0YVJlc3VsdCIsInNhbWVEYXRhIiwiYWRkT3JSZW1vdmVUZXh0TGFiZWxzIiwibmV3RmllbGRzIiwidGV4dExhYmVsIiwibmV3VGV4dExhYmVsIiwic2xpY2UiLCJjdXJyZW50RmllbGRzIiwidGwiLCJmaWVsZCIsIm5hbWUiLCJmaWx0ZXIiLCJhZGRGaWVsZHMiLCJmIiwiaW5jbHVkZXMiLCJkZWxldGVGaWVsZHMiLCJmaW5kIiwiZmQiLCJERUZBVUxUX1RFWFRfTEFCRUwiLCJhZiIsInVwZGF0ZVRleHRMYWJlbFByb3BBbmRWYWx1ZSIsInByb3AiLCJ2YWx1ZSIsImhhc093blByb3BlcnR5Iiwic3BsaWNlIiwibGF5ZXJUZXh0TGFiZWxDaGFuZ2VVcGRhdGVyIiwibGF5ZXJUeXBlQ2hhbmdlVXBkYXRlciIsIm5ld1R5cGUiLCJvbGRJZCIsIkNvbnNvbGUiLCJlcnJvciIsImFzc2lnbkNvbmZpZ1RvTGF5ZXIiLCJ2aXNDb25maWdTZXR0aW5ncyIsImRhdGFJZCIsImRhdGFzZXQiLCJ1cGRhdGVMYXllckRvbWFpbiIsInNldHRpbmdzIiwib2xkTGF5ZXJNYXAiLCJvdGhlckxheWVycyIsImxheWVyVmlzdWFsQ2hhbm5lbENoYW5nZVVwZGF0ZXIiLCJjaGFubmVsIiwidXBkYXRlTGF5ZXJWaXN1YWxDaGFubmVsIiwibGF5ZXJWaXNDb25maWdDaGFuZ2VVcGRhdGVyIiwibmV3VmlzQ29uZmlnIiwidmlzQ29uZmlnIiwiaW50ZXJhY3Rpb25Db25maWdDaGFuZ2VVcGRhdGVyIiwiY29udHJhZGljdCIsImZvckVhY2giLCJrIiwic2V0RmlsdGVyVXBkYXRlciIsIm5ld0ZpbHRlciIsImZpZWxkcyIsImFsbERhdGEiLCJmaWVsZElkeCIsImZpbHRlclByb3AiLCJmcmVlemUiLCJlbmxhcmdlZEZpbHRlcklkeCIsImVubGFyZ2VkIiwidXBkYXRlQWxsTGF5ZXJEb21haW5EYXRhIiwic2V0RmlsdGVyUGxvdFVwZGF0ZXIiLCJuZXdQcm9wIiwicGxvdFR5cGUiLCJhZGRGaWx0ZXJVcGRhdGVyIiwibGF5ZXJDb2xvclVJQ2hhbmdlVXBkYXRlciIsInVwZGF0ZUxheWVyQ29sb3JVSSIsInRvZ2dsZUZpbHRlckFuaW1hdGlvblVwZGF0ZXIiLCJpc0FuaW1hdGluZyIsInVwZGF0ZUZpbHRlckFuaW1hdGlvblNwZWVkVXBkYXRlciIsInVwZGF0ZUFuaW1hdGlvblRpbWVVcGRhdGVyIiwidXBkYXRlTGF5ZXJBbmltYXRpb25TcGVlZFVwZGF0ZXIiLCJlbmxhcmdlRmlsdGVyVXBkYXRlciIsImlzRW5sYXJnZWQiLCJyZW1vdmVGaWx0ZXJVcGRhdGVyIiwibmV3RmlsdGVycyIsImFkZExheWVyVXBkYXRlciIsImRlZmF1bHREYXRhc2V0IiwiTGF5ZXIiLCJpc0NvbmZpZ0FjdGl2ZSIsInJlbW92ZUxheWVyVXBkYXRlciIsImxheWVyVG9SZW1vdmUiLCJuZXdNYXBzIiwicGlkIiwiaXNMYXllckhvdmVyZWQiLCJyZW9yZGVyTGF5ZXJVcGRhdGVyIiwib3JkZXIiLCJyZW1vdmVEYXRhc2V0VXBkYXRlciIsImRhdGFzZXRLZXkiLCJrZXkiLCJuZXdEYXRhc2V0cyIsImluZGV4ZXMiLCJyZWR1Y2UiLCJsaXN0T2ZJbmRleGVzIiwiaW5kZXgiLCJwdXNoIiwiY3VycmVudFN0YXRlIiwiaW5kZXhDb3VudGVyIiwiY3VycmVudEluZGV4IiwidG9vbHRpcCIsImZpZWxkc1RvU2hvdyIsInVwZGF0ZUxheWVyQmxlbmRpbmdVcGRhdGVyIiwibW9kZSIsInNob3dEYXRhc2V0VGFibGVVcGRhdGVyIiwicmVzZXRNYXBDb25maWdVcGRhdGVyIiwiaW5pdGlhbFN0YXRlIiwicmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIiLCJwYXlsb2FkIiwib3B0aW9ucyIsInZpc1N0YXRlIiwia2VlcEV4aXN0aW5nQ29uZmlnIiwibWVyZ2VkU3RhdGUiLCJsYXllckhvdmVyVXBkYXRlciIsImluZm8iLCJsYXllckNsaWNrVXBkYXRlciIsImNvb3JkaW5hdGUiLCJwaW5uZWQiLCJwaWNrZWQiLCJtYXBDbGlja1VwZGF0ZXIiLCJtb3VzZU1vdmVVcGRhdGVyIiwiZXZ0IiwidmFsdWVzIiwic29tZSIsIm1vdXNlUG9zaXRpb24iLCJwb2ludCIsImxuZ0xhdCIsInRvZ2dsZVNwbGl0TWFwVXBkYXRlciIsImNsb3NlU3BlY2lmaWNNYXBBdEluZGV4IiwidG9nZ2xlTGF5ZXJGb3JNYXBVcGRhdGVyIiwibWFwSW5kZXgiLCJsYXllcklkIiwic20iLCJ1cGRhdGVWaXNEYXRhVXBkYXRlciIsIkFycmF5IiwiaXNBcnJheSIsIm5ld0RhdGVFbnRyaWVzIiwiYWNjdSIsImRhdGEiLCJwcmV2aW91c1N0YXRlIiwic3RhdGVXaXRoTmV3RGF0YSIsInNwbGl0TWFwc1RvQmVNZXJnZWQiLCJuZXdMYXllcnMiLCJyZXN1bHQiLCJhZGREZWZhdWx0TGF5ZXJzIiwidG9vbHRpcEZpZWxkcyIsImFkZERlZmF1bHRUb29sdGlwcyIsInVwZGF0ZWRTdGF0ZSIsImluZGV4VG9SZXRyaWV2ZSIsIm1hcExheWVycyIsImxvYWRGaWxlc1VwZGF0ZXIiLCJmaWxlcyIsImZpbGVzVG9Mb2FkIiwiZmlsZUJsb2IiLCJsb2FkRmlsZVRhc2tzIiwiVGFzayIsImFsbCIsIkxPQURfRklMRV9UQVNLIiwiYmltYXAiLCJyZXN1bHRzIiwiYyIsImNvbmNhdCIsImNlbnRlck1hcCIsImxvYWRGaWxlc0VyciIsImRlZmF1bHRMYXllcnMiLCJfIiwiZGF0YUlkcyIsIm5ld0xheWVyRGF0YXMiLCJmaXhlZERvbWFpbiIsImFuaW1hdGFibGVMYXllcnMiLCJhbmltYXRpb25Eb21haW4iLCJtZXJnZWREb21haW4iLCJNYXRoIiwibWluIiwibWF4IiwiTnVtYmVyIiwiSW5maW5pdHkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBQ0E7O0FBR0E7O0FBR0E7O0FBQ0E7O0FBR0E7O0FBQ0E7O0FBUUE7O0FBRUE7O0FBS0E7O0FBU0E7O0FBTUE7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9DQTs7QUFDQSxJQUFNQSxnQkFBZ0IsR0FBRyxJQUF6QjtBQUNBOztBQUVPLElBQU1DLHNCQUFzQixHQUFHO0FBQ3BDQyxFQUFBQSxNQUFNLEVBQUUsSUFENEI7QUFFcENDLEVBQUFBLFdBQVcsRUFBRSxJQUZ1QjtBQUdwQ0MsRUFBQUEsS0FBSyxFQUFFO0FBSDZCLENBQS9CO0FBTVA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JPLElBQU1DLGlCQUFpQixHQUFHO0FBQy9CO0FBQ0FDLEVBQUFBLE1BQU0sRUFBRSxFQUZ1QjtBQUcvQkMsRUFBQUEsU0FBUyxFQUFFLEVBSG9CO0FBSS9CQyxFQUFBQSxlQUFlLEVBQUUsRUFKYztBQUsvQkMsRUFBQUEsVUFBVSxFQUFFLEVBTG1CO0FBTy9CO0FBQ0FDLEVBQUFBLE9BQU8sRUFBRSxFQVJzQjtBQVMvQkMsRUFBQUEsZ0JBQWdCLEVBQUUsRUFUYTtBQVcvQjtBQUNBQyxFQUFBQSxRQUFRLEVBQUUsRUFacUI7QUFhL0JDLEVBQUFBLGNBQWMsRUFBRUMsU0FiZTtBQWUvQkMsRUFBQUEsaUJBQWlCLEVBQUUsOENBZlk7QUFnQi9CQyxFQUFBQSxxQkFBcUIsRUFBRUYsU0FoQlE7QUFrQi9CRyxFQUFBQSxhQUFhLEVBQUUsUUFsQmdCO0FBbUIvQkMsRUFBQUEsU0FBUyxFQUFFSixTQW5Cb0I7QUFvQi9CSyxFQUFBQSxPQUFPLEVBQUVMLFNBcEJzQjtBQXFCL0JNLEVBQUFBLFFBQVEsRUFBRSxFQXJCcUI7QUF1Qi9CO0FBQ0FDLEVBQUFBLFNBQVMsRUFBRSxDQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUFMsR0F4Qm9CO0FBaUMvQjtBQUNBO0FBQ0FDLEVBQUFBLFlBQVksRUFBRUMsb0JBbkNpQjtBQXFDL0I7QUFDQTtBQUNBQyxFQUFBQSxlQUFlLEVBQUV2QjtBQXZDYyxDQUExQjs7O0FBMENQLFNBQVN3QiwyQkFBVCxDQUFxQ0MsS0FBckMsUUFBcUU7QUFBQSxNQUF4Qm5CLFNBQXdCLFFBQXhCQSxTQUF3QjtBQUFBLE1BQWJvQixLQUFhLFFBQWJBLEtBQWE7QUFBQSxNQUFOQyxHQUFNLFFBQU5BLEdBQU07QUFDbkUsMkJBQ0tGLEtBREw7QUFFRXBCLElBQUFBLE1BQU0sRUFBRW9CLEtBQUssQ0FBQ3BCLE1BQU4sQ0FBYXVCLEdBQWIsQ0FBaUIsVUFBQ0MsR0FBRCxFQUFNQyxDQUFOO0FBQUEsYUFBYUEsQ0FBQyxLQUFLSCxHQUFOLEdBQVlELEtBQVosR0FBb0JHLEdBQWpDO0FBQUEsS0FBakIsQ0FGVjtBQUdFdkIsSUFBQUEsU0FBUyxFQUFFQSxTQUFTLEdBQ2hCbUIsS0FBSyxDQUFDbkIsU0FBTixDQUFnQnNCLEdBQWhCLENBQW9CLFVBQUNHLENBQUQsRUFBSUQsQ0FBSjtBQUFBLGFBQVdBLENBQUMsS0FBS0gsR0FBTixHQUFZckIsU0FBWixHQUF3QnlCLENBQW5DO0FBQUEsS0FBcEIsQ0FEZ0IsR0FFaEJOLEtBQUssQ0FBQ25CO0FBTFo7QUFPRDs7QUFFTSxTQUFTMEIsa0NBQVQsQ0FBNENQLEtBQTVDLEVBQW1EQyxLQUFuRCxFQUEwRDtBQUMvRCxNQUFJTyxRQUFRLEdBQUdSLEtBQWY7O0FBQ0EsTUFBSUEsS0FBSyxDQUFDTCxTQUFOLENBQWdCYyxNQUFwQixFQUE0QjtBQUMxQkQsSUFBQUEsUUFBUSxxQkFDSFIsS0FERztBQUVOTCxNQUFBQSxTQUFTLEVBQUVNLEtBQUssQ0FBQ1MsTUFBTixDQUFhQyxTQUFiLEdBQ1AsMkNBQXVCWCxLQUFLLENBQUNMLFNBQTdCLEVBQXdDTSxLQUF4QyxDQURPLEdBRVAsNkNBQXlCRCxLQUFLLENBQUNMLFNBQS9CLEVBQTBDTSxLQUExQztBQUpFLE1BQVI7QUFNRDs7QUFFRCxNQUFJQSxLQUFLLENBQUNTLE1BQU4sQ0FBYUUsU0FBYixDQUF1QkMsT0FBM0IsRUFBb0M7QUFDbENMLElBQUFBLFFBQVEsR0FBR00scUJBQXFCLENBQUNkLEtBQUQsQ0FBaEM7QUFDRDs7QUFFRCxTQUFPUSxRQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7QUFTTyxTQUFTTyx3QkFBVCxDQUFrQ2YsS0FBbEMsRUFBeUNnQixNQUF6QyxFQUFpRDtBQUFBLE1BQy9DQyxRQUQrQyxHQUNuQ0QsTUFEbUMsQ0FDL0NDLFFBRCtDO0FBRXRELE1BQU1mLEdBQUcsR0FBR0YsS0FBSyxDQUFDcEIsTUFBTixDQUFhc0MsU0FBYixDQUF1QixVQUFBQyxDQUFDO0FBQUEsV0FBSUEsQ0FBQyxDQUFDQyxFQUFGLEtBQVNILFFBQVEsQ0FBQ0csRUFBdEI7QUFBQSxHQUF4QixDQUFaO0FBQ0EsTUFBTUMsS0FBSyxHQUFHQyxNQUFNLENBQUNDLElBQVAsQ0FBWVAsTUFBTSxDQUFDUSxTQUFuQixDQUFkO0FBQ0EsTUFBSUMsUUFBUSxHQUFHUixRQUFRLENBQUNTLGlCQUFULENBQTJCVixNQUFNLENBQUNRLFNBQWxDLENBQWY7QUFFQSxNQUFJM0MsU0FBSixDQU5zRCxDQVF0RDs7QUFDQSxNQUFJNEMsUUFBUSxDQUFDRSx3QkFBVCxDQUFrQ04sS0FBbEMsQ0FBSixFQUE4QztBQUM1QyxRQUFNTyxZQUFZLEdBQUc1QixLQUFLLENBQUNuQixTQUFOLENBQWdCcUIsR0FBaEIsQ0FBckI7QUFDQSxRQUFNMkIscUJBQXFCLEdBQUcsb0NBQzVCSixRQUQ0QixFQUU1QnpCLEtBRjRCLEVBRzVCNEIsWUFINEIsRUFJNUI7QUFDRUUsTUFBQUEsUUFBUSxFQUFFO0FBRFosS0FKNEIsQ0FBOUI7QUFTQWpELElBQUFBLFNBQVMsR0FBR2dELHFCQUFxQixDQUFDaEQsU0FBbEM7QUFDQTRDLElBQUFBLFFBQVEsR0FBR0kscUJBQXFCLENBQUM1QixLQUFqQztBQUNEOztBQUVELE1BQUlPLFFBQVEsR0FBR1IsS0FBZjs7QUFDQSxNQUFJLGVBQWVnQixNQUFNLENBQUNRLFNBQTFCLEVBQXFDO0FBQ25DaEIsSUFBQUEsUUFBUSxHQUFHRCxrQ0FBa0MsQ0FBQ1AsS0FBRCxFQUFReUIsUUFBUixDQUE3QztBQUNEOztBQUVELFNBQU8xQiwyQkFBMkIsQ0FBQ1MsUUFBRCxFQUFXO0FBQzNDUCxJQUFBQSxLQUFLLEVBQUV3QixRQURvQztBQUUzQzVDLElBQUFBLFNBQVMsRUFBVEEsU0FGMkM7QUFHM0NxQixJQUFBQSxHQUFHLEVBQUhBO0FBSDJDLEdBQVgsQ0FBbEM7QUFLRDs7QUFFRCxTQUFTNkIscUJBQVQsQ0FBK0JDLFNBQS9CLEVBQTBDQyxTQUExQyxFQUFxRDtBQUNuRCxNQUFJQyxZQUFZLEdBQUdELFNBQVMsQ0FBQ0UsS0FBVixFQUFuQjtBQUVBLE1BQU1DLGFBQWEsR0FBR0gsU0FBUyxDQUM1QjlCLEdBRG1CLENBQ2YsVUFBQWtDLEVBQUU7QUFBQSxXQUFJQSxFQUFFLENBQUNDLEtBQUgsSUFBWUQsRUFBRSxDQUFDQyxLQUFILENBQVNDLElBQXpCO0FBQUEsR0FEYSxFQUVuQkMsTUFGbUIsQ0FFWixVQUFBbEMsQ0FBQztBQUFBLFdBQUlBLENBQUo7QUFBQSxHQUZXLENBQXRCO0FBSUEsTUFBTW1DLFNBQVMsR0FBR1QsU0FBUyxDQUFDUSxNQUFWLENBQWlCLFVBQUFFLENBQUM7QUFBQSxXQUFJLENBQUNOLGFBQWEsQ0FBQ08sUUFBZCxDQUF1QkQsQ0FBQyxDQUFDSCxJQUF6QixDQUFMO0FBQUEsR0FBbEIsQ0FBbEI7QUFDQSxNQUFNSyxZQUFZLEdBQUdSLGFBQWEsQ0FBQ0ksTUFBZCxDQUNuQixVQUFBRSxDQUFDO0FBQUEsV0FBSSxDQUFDVixTQUFTLENBQUNhLElBQVYsQ0FBZSxVQUFBQyxFQUFFO0FBQUEsYUFBSUEsRUFBRSxDQUFDUCxJQUFILEtBQVlHLENBQWhCO0FBQUEsS0FBakIsQ0FBTDtBQUFBLEdBRGtCLENBQXJCLENBUm1ELENBWW5EOztBQUNBUixFQUFBQSxZQUFZLEdBQUdBLFlBQVksQ0FBQ00sTUFBYixDQUNiLFVBQUFILEVBQUU7QUFBQSxXQUFJQSxFQUFFLENBQUNDLEtBQUgsSUFBWSxDQUFDTSxZQUFZLENBQUNELFFBQWIsQ0FBc0JOLEVBQUUsQ0FBQ0MsS0FBSCxDQUFTQyxJQUEvQixDQUFqQjtBQUFBLEdBRFcsQ0FBZjtBQUdBTCxFQUFBQSxZQUFZLEdBQUcsQ0FBQ0EsWUFBWSxDQUFDekIsTUFBZCxHQUF1QixDQUFDc0MsZ0NBQUQsQ0FBdkIsR0FBOENiLFlBQTdELENBaEJtRCxDQWtCbkQ7O0FBQ0FBLEVBQUFBLFlBQVksaURBQ1BBLFlBQVksQ0FBQ00sTUFBYixDQUFvQixVQUFBSCxFQUFFO0FBQUEsV0FBSUEsRUFBRSxDQUFDQyxLQUFQO0FBQUEsR0FBdEIsQ0FETyx1Q0FFUEcsU0FBUyxDQUFDdEMsR0FBVixDQUFjLFVBQUE2QyxFQUFFO0FBQUEsNkJBQ2RELGdDQURjO0FBRWpCVCxNQUFBQSxLQUFLLEVBQUVVO0FBRlU7QUFBQSxHQUFoQixDQUZPLEVBQVo7QUFRQSxTQUFPZCxZQUFQO0FBQ0Q7O0FBRUQsU0FBU2UsMkJBQVQsQ0FBcUMvQyxHQUFyQyxFQUEwQ2dELElBQTFDLEVBQWdEQyxLQUFoRCxFQUF1RGxCLFNBQXZELEVBQWtFO0FBQ2hFLE1BQUksQ0FBQ0EsU0FBUyxDQUFDL0IsR0FBRCxDQUFULENBQWVrRCxjQUFmLENBQThCRixJQUE5QixDQUFMLEVBQTBDO0FBQ3hDLFdBQU9qQixTQUFQO0FBQ0Q7O0FBRUQsTUFBSUMsWUFBWSxHQUFHRCxTQUFTLENBQUNFLEtBQVYsRUFBbkI7O0FBRUEsTUFBSWUsSUFBSSxLQUFLQyxLQUFLLElBQUlsQixTQUFTLENBQUN4QixNQUFWLEtBQXFCLENBQW5DLENBQVIsRUFBK0M7QUFDN0N5QixJQUFBQSxZQUFZLEdBQUdELFNBQVMsQ0FBQzlCLEdBQVYsQ0FBYyxVQUFDa0MsRUFBRCxFQUFLaEMsQ0FBTDtBQUFBLGFBQzNCQSxDQUFDLEtBQUtILEdBQU4scUJBQWdCbUMsRUFBaEIsdUNBQXFCYSxJQUFyQixFQUE0QkMsS0FBNUIsS0FBcUNkLEVBRFY7QUFBQSxLQUFkLENBQWY7QUFHRCxHQUpELE1BSU8sSUFBSWEsSUFBSSxLQUFLLE9BQVQsSUFBb0JDLEtBQUssS0FBSyxJQUE5QixJQUFzQ2xCLFNBQVMsQ0FBQ3hCLE1BQVYsR0FBbUIsQ0FBN0QsRUFBZ0U7QUFDckU7QUFDQXlCLElBQUFBLFlBQVksQ0FBQ21CLE1BQWIsQ0FBb0JuRCxHQUFwQixFQUF5QixDQUF6QjtBQUNEOztBQUVELFNBQU9nQyxZQUFQO0FBQ0Q7O0FBRU0sU0FBU29CLDJCQUFULENBQXFDdEQsS0FBckMsRUFBNENnQixNQUE1QyxFQUFvRDtBQUFBLE1BQ2xEQyxRQURrRCxHQUNwQkQsTUFEb0IsQ0FDbERDLFFBRGtEO0FBQUEsTUFDeENmLEdBRHdDLEdBQ3BCYyxNQURvQixDQUN4Q2QsR0FEd0M7QUFBQSxNQUNuQ2dELElBRG1DLEdBQ3BCbEMsTUFEb0IsQ0FDbkNrQyxJQURtQztBQUFBLE1BQzdCQyxLQUQ2QixHQUNwQm5DLE1BRG9CLENBQzdCbUMsS0FENkI7QUFBQSxNQUVsRGxCLFNBRmtELEdBRXJDaEIsUUFBUSxDQUFDUCxNQUY0QixDQUVsRHVCLFNBRmtEO0FBSXpELE1BQUlDLFlBQVksR0FBR0QsU0FBUyxDQUFDRSxLQUFWLEVBQW5COztBQUNBLE1BQUksQ0FBQ0YsU0FBUyxDQUFDL0IsR0FBRCxDQUFWLElBQW1CQSxHQUFHLEtBQUsrQixTQUFTLENBQUN4QixNQUF6QyxFQUFpRDtBQUMvQztBQUNBeUIsSUFBQUEsWUFBWSxpREFBT0QsU0FBUCxJQUFrQmMsZ0NBQWxCLEVBQVo7QUFDRDs7QUFFRCxNQUFJN0MsR0FBRyxLQUFLLEtBQVIsSUFBaUJnRCxJQUFJLEtBQUssUUFBOUIsRUFBd0M7QUFDdENoQixJQUFBQSxZQUFZLEdBQUdILHFCQUFxQixDQUFDb0IsS0FBRCxFQUFRbEIsU0FBUixDQUFwQztBQUNELEdBRkQsTUFFTztBQUNMQyxJQUFBQSxZQUFZLEdBQUdlLDJCQUEyQixDQUFDL0MsR0FBRCxFQUFNZ0QsSUFBTixFQUFZQyxLQUFaLEVBQW1CakIsWUFBbkIsQ0FBMUM7QUFDRCxHQWR3RCxDQWdCekQ7OztBQUNBLFNBQU9uQix3QkFBd0IsQ0FBQ2YsS0FBRCxFQUFRO0FBQ3JDaUIsSUFBQUEsUUFBUSxFQUFSQSxRQURxQztBQUVyQ08sSUFBQUEsU0FBUyxFQUFFO0FBQUNTLE1BQUFBLFNBQVMsRUFBRUM7QUFBWjtBQUYwQixHQUFSLENBQS9CO0FBSUQ7QUFFRDs7Ozs7Ozs7Ozs7O0FBVU8sU0FBU3FCLHNCQUFULENBQWdDdkQsS0FBaEMsRUFBdUNnQixNQUF2QyxFQUErQztBQUFBLE1BQzdDQyxRQUQ2QyxHQUN4QkQsTUFEd0IsQ0FDN0NDLFFBRDZDO0FBQUEsTUFDbkN1QyxPQURtQyxHQUN4QnhDLE1BRHdCLENBQ25Dd0MsT0FEbUM7O0FBRXBELE1BQUksQ0FBQ3ZDLFFBQUwsRUFBZTtBQUNiLFdBQU9qQixLQUFQO0FBQ0Q7O0FBQ0QsTUFBTXlELEtBQUssR0FBR3hDLFFBQVEsQ0FBQ0csRUFBdkI7QUFDQSxNQUFNbEIsR0FBRyxHQUFHRixLQUFLLENBQUNwQixNQUFOLENBQWFzQyxTQUFiLENBQXVCLFVBQUFDLENBQUM7QUFBQSxXQUFJQSxDQUFDLENBQUNDLEVBQUYsS0FBU3FDLEtBQWI7QUFBQSxHQUF4QixDQUFaOztBQUVBLE1BQUksQ0FBQ3pELEtBQUssQ0FBQ0osWUFBTixDQUFtQjRELE9BQW5CLENBQUwsRUFBa0M7QUFDaENFLG9CQUFRQyxLQUFSLFdBQWlCSCxPQUFqQjs7QUFDQSxXQUFPeEQsS0FBUDtBQUNELEdBWG1ELENBYXBEO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTXlCLFFBQVEsR0FBRyxJQUFJekIsS0FBSyxDQUFDSixZQUFOLENBQW1CNEQsT0FBbkIsQ0FBSixFQUFqQjtBQUVBL0IsRUFBQUEsUUFBUSxDQUFDbUMsbUJBQVQsQ0FBNkIzQyxRQUFRLENBQUNQLE1BQXRDLEVBQThDTyxRQUFRLENBQUM0QyxpQkFBdkQ7O0FBRUEsTUFBSXBDLFFBQVEsQ0FBQ2YsTUFBVCxDQUFnQm9ELE1BQXBCLEVBQTRCO0FBQzFCLFFBQU1DLE9BQU8sR0FBRy9ELEtBQUssQ0FBQ2QsUUFBTixDQUFldUMsUUFBUSxDQUFDZixNQUFULENBQWdCb0QsTUFBL0IsQ0FBaEI7QUFDQXJDLElBQUFBLFFBQVEsQ0FBQ3VDLGlCQUFULENBQTJCRCxPQUEzQjtBQUNEOztBQXZCbUQsNEJBeUJ6QixvQ0FBbUJ0QyxRQUFuQixFQUE2QnpCLEtBQTdCLENBekJ5QjtBQUFBLE1BeUI3Q25CLFNBekI2Qyx1QkF5QjdDQSxTQXpCNkM7QUFBQSxNQXlCbENvQixLQXpCa0MsdUJBeUJsQ0EsS0F6QmtDOztBQTBCcEQsTUFBSU8sUUFBUSxHQUFHVCwyQkFBMkIsQ0FBQ0MsS0FBRCxFQUFRO0FBQUNuQixJQUFBQSxTQUFTLEVBQVRBLFNBQUQ7QUFBWW9CLElBQUFBLEtBQUssRUFBTEEsS0FBWjtBQUFtQkMsSUFBQUEsR0FBRyxFQUFIQTtBQUFuQixHQUFSLENBQTFDOztBQUVBLE1BQUlELEtBQUssQ0FBQ1MsTUFBTixDQUFhRSxTQUFiLENBQXVCQyxPQUF2QixJQUFrQ0ksUUFBUSxDQUFDUCxNQUFULENBQWdCRSxTQUFoQixDQUEwQkMsT0FBaEUsRUFBeUU7QUFDdkVMLElBQUFBLFFBQVEsR0FBR00scUJBQXFCLENBQUNOLFFBQUQsQ0FBaEM7QUFDRCxHQTlCbUQsQ0FnQ3BEOzs7QUFDQSxNQUFJUixLQUFLLENBQUNMLFNBQU4sQ0FBZ0JjLE1BQXBCLEVBQTRCO0FBQzFCRCxJQUFBQSxRQUFRLHFCQUNIQSxRQURHO0FBRU5iLE1BQUFBLFNBQVMsRUFBRWEsUUFBUSxDQUFDYixTQUFULENBQW1CUSxHQUFuQixDQUF1QixVQUFBOEQsUUFBUSxFQUFJO0FBQUEsK0JBQ0dBLFFBQVEsQ0FBQ3JGLE1BRFo7QUFBQSxZQUM1QnNGLFdBRDRCLG9CQUNwQ1QsS0FEb0M7QUFBQSxZQUNaVSxXQURZLGdFQUNwQ1YsS0FEb0M7QUFFNUMsZUFBT0EsS0FBSyxJQUFJUSxRQUFRLENBQUNyRixNQUFsQixxQkFFRXFGLFFBRkY7QUFHRHJGLFVBQUFBLE1BQU0sb0JBQ0R1RixXQURDLHVDQUVIbEUsS0FBSyxDQUFDbUIsRUFGSCxFQUVROEMsV0FGUjtBQUhMLGFBUUhELFFBUko7QUFTRCxPQVhVO0FBRkwsTUFBUjtBQWVEOztBQUVELFNBQU96RCxRQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7OztBQVdPLFNBQVM0RCwrQkFBVCxDQUF5Q3BFLEtBQXpDLEVBQWdEZ0IsTUFBaEQsRUFBd0Q7QUFBQSxNQUN0REMsUUFEc0QsR0FDdEJELE1BRHNCLENBQ3REQyxRQURzRDtBQUFBLE1BQzVDTyxTQUQ0QyxHQUN0QlIsTUFEc0IsQ0FDNUNRLFNBRDRDO0FBQUEsTUFDakM2QyxPQURpQyxHQUN0QnJELE1BRHNCLENBQ2pDcUQsT0FEaUM7QUFFN0QsTUFBTU4sT0FBTyxHQUFHL0QsS0FBSyxDQUFDZCxRQUFOLENBQWUrQixRQUFRLENBQUNQLE1BQVQsQ0FBZ0JvRCxNQUEvQixDQUFoQjtBQUVBLE1BQU01RCxHQUFHLEdBQUdGLEtBQUssQ0FBQ3BCLE1BQU4sQ0FBYXNDLFNBQWIsQ0FBdUIsVUFBQUMsQ0FBQztBQUFBLFdBQUlBLENBQUMsQ0FBQ0MsRUFBRixLQUFTSCxRQUFRLENBQUNHLEVBQXRCO0FBQUEsR0FBeEIsQ0FBWjtBQUNBLE1BQU1LLFFBQVEsR0FBR1IsUUFBUSxDQUFDUyxpQkFBVCxDQUEyQkYsU0FBM0IsQ0FBakI7QUFFQUMsRUFBQUEsUUFBUSxDQUFDNkMsd0JBQVQsQ0FBa0NQLE9BQWxDLEVBQTJDTSxPQUEzQztBQUVBLE1BQU16QyxZQUFZLEdBQUc1QixLQUFLLENBQUNuQixTQUFOLENBQWdCcUIsR0FBaEIsQ0FBckI7O0FBVDZELDZCQVVsQyxvQ0FBbUJ1QixRQUFuQixFQUE2QnpCLEtBQTdCLEVBQW9DNEIsWUFBcEMsRUFBa0Q7QUFDM0VFLElBQUFBLFFBQVEsRUFBRTtBQURpRSxHQUFsRCxDQVZrQztBQUFBLE1BVXREakQsU0FWc0Qsd0JBVXREQSxTQVZzRDtBQUFBLE1BVTNDb0IsS0FWMkMsd0JBVTNDQSxLQVYyQzs7QUFjN0QsU0FBT0YsMkJBQTJCLENBQUNDLEtBQUQsRUFBUTtBQUFDbkIsSUFBQUEsU0FBUyxFQUFUQSxTQUFEO0FBQVlvQixJQUFBQSxLQUFLLEVBQUxBLEtBQVo7QUFBbUJDLElBQUFBLEdBQUcsRUFBSEE7QUFBbkIsR0FBUixDQUFsQztBQUNEO0FBRUQ7Ozs7Ozs7Ozs7OztBQVVPLFNBQVNxRSwyQkFBVCxDQUFxQ3ZFLEtBQXJDLEVBQTRDZ0IsTUFBNUMsRUFBb0Q7QUFBQSxNQUNsREMsUUFEa0QsR0FDdENELE1BRHNDLENBQ2xEQyxRQURrRDtBQUV6RCxNQUFNZixHQUFHLEdBQUdGLEtBQUssQ0FBQ3BCLE1BQU4sQ0FBYXNDLFNBQWIsQ0FBdUIsVUFBQUMsQ0FBQztBQUFBLFdBQUlBLENBQUMsQ0FBQ0MsRUFBRixLQUFTSCxRQUFRLENBQUNHLEVBQXRCO0FBQUEsR0FBeEIsQ0FBWjtBQUNBLE1BQU1DLEtBQUssR0FBR0MsTUFBTSxDQUFDQyxJQUFQLENBQVlQLE1BQU0sQ0FBQ3dELFlBQW5CLENBQWQ7O0FBRUEsTUFBTUEsWUFBWSxxQkFDYnZELFFBQVEsQ0FBQ1AsTUFBVCxDQUFnQitELFNBREgsTUFFYnpELE1BQU0sQ0FBQ3dELFlBRk0sQ0FBbEI7O0FBS0EsTUFBTS9DLFFBQVEsR0FBR1IsUUFBUSxDQUFDUyxpQkFBVCxDQUEyQjtBQUFDK0MsSUFBQUEsU0FBUyxFQUFFRDtBQUFaLEdBQTNCLENBQWpCOztBQUVBLE1BQUkvQyxRQUFRLENBQUNFLHdCQUFULENBQWtDTixLQUFsQyxDQUFKLEVBQThDO0FBQzVDLFFBQU1PLFlBQVksR0FBRzVCLEtBQUssQ0FBQ25CLFNBQU4sQ0FBZ0JxQixHQUFoQixDQUFyQjs7QUFENEMsK0JBRWpCLG9DQUN6QnVCLFFBRHlCLEVBRXpCekIsS0FGeUIsRUFHekI0QixZQUh5QixFQUl6QjtBQUNFRSxNQUFBQSxRQUFRLEVBQUU7QUFEWixLQUp5QixDQUZpQjtBQUFBLFFBRXJDakQsU0FGcUMsd0JBRXJDQSxTQUZxQztBQUFBLFFBRTFCb0IsS0FGMEIsd0JBRTFCQSxLQUYwQjs7QUFVNUMsV0FBT0YsMkJBQTJCLENBQUNDLEtBQUQsRUFBUTtBQUFDbkIsTUFBQUEsU0FBUyxFQUFUQSxTQUFEO0FBQVlvQixNQUFBQSxLQUFLLEVBQUxBLEtBQVo7QUFBbUJDLE1BQUFBLEdBQUcsRUFBSEE7QUFBbkIsS0FBUixDQUFsQztBQUNEOztBQUVELFNBQU9ILDJCQUEyQixDQUFDQyxLQUFELEVBQVE7QUFBQ0MsSUFBQUEsS0FBSyxFQUFFd0IsUUFBUjtBQUFrQnZCLElBQUFBLEdBQUcsRUFBSEE7QUFBbEIsR0FBUixDQUFsQztBQUNEO0FBRUQ7O0FBRUE7Ozs7Ozs7Ozs7O0FBU08sU0FBU3dFLDhCQUFULENBQXdDMUUsS0FBeEMsRUFBK0NnQixNQUEvQyxFQUF1RDtBQUFBLE1BQ3JETixNQURxRCxHQUMzQ00sTUFEMkMsQ0FDckROLE1BRHFEOztBQUc1RCxNQUFNckIsaUJBQWlCLHFCQUNsQlcsS0FBSyxDQUFDWCxpQkFEWSwyQ0FFaEJxQixNQUFNLENBQUNVLEVBRlMsRUFFSlYsTUFGSSxFQUF2QixDQUg0RCxDQVE1RDtBQUNBOzs7QUFDQSxNQUFNaUUsVUFBVSxHQUFHLENBQUMsT0FBRCxFQUFVLFNBQVYsQ0FBbkI7O0FBRUEsTUFDRUEsVUFBVSxDQUFDaEMsUUFBWCxDQUFvQmpDLE1BQU0sQ0FBQ1UsRUFBM0IsS0FDQVYsTUFBTSxDQUFDRyxPQURQLElBRUEsQ0FBQ2IsS0FBSyxDQUFDWCxpQkFBTixDQUF3QnFCLE1BQU0sQ0FBQ1UsRUFBL0IsRUFBbUNQLE9BSHRDLEVBSUU7QUFDQTtBQUNBOEQsSUFBQUEsVUFBVSxDQUFDQyxPQUFYLENBQW1CLFVBQUFDLENBQUMsRUFBSTtBQUN0QixVQUFJQSxDQUFDLEtBQUtuRSxNQUFNLENBQUNVLEVBQWpCLEVBQXFCO0FBQ25CL0IsUUFBQUEsaUJBQWlCLENBQUN3RixDQUFELENBQWpCLHFCQUEyQnhGLGlCQUFpQixDQUFDd0YsQ0FBRCxDQUE1QztBQUFpRGhFLFVBQUFBLE9BQU8sRUFBRTtBQUExRDtBQUNEO0FBQ0YsS0FKRDtBQUtEOztBQUVELDJCQUNLYixLQURMO0FBRUVYLElBQUFBLGlCQUFpQixFQUFqQkE7QUFGRjtBQUlEO0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUFXTyxTQUFTeUYsZ0JBQVQsQ0FBMEI5RSxLQUExQixFQUFpQ2dCLE1BQWpDLEVBQXlDO0FBQUEsTUFDdkNkLEdBRHVDLEdBQ25CYyxNQURtQixDQUN2Q2QsR0FEdUM7QUFBQSxNQUNsQ2dELElBRGtDLEdBQ25CbEMsTUFEbUIsQ0FDbENrQyxJQURrQztBQUFBLE1BQzVCQyxLQUQ0QixHQUNuQm5DLE1BRG1CLENBQzVCbUMsS0FENEI7QUFFOUMsTUFBSTNDLFFBQVEsR0FBR1IsS0FBZjs7QUFDQSxNQUFJK0UsU0FBUyxxQkFDUi9FLEtBQUssQ0FBQ2hCLE9BQU4sQ0FBY2tCLEdBQWQsQ0FEUSx1Q0FFVmdELElBRlUsRUFFSEMsS0FGRyxFQUFiOztBQUg4QyxtQkFRN0I0QixTQVI2QjtBQUFBLE1BUXZDakIsTUFSdUMsY0FRdkNBLE1BUnVDOztBQVM5QyxNQUFJLENBQUNBLE1BQUwsRUFBYTtBQUNYLFdBQU85RCxLQUFQO0FBQ0Q7O0FBWDZDLDhCQVlwQkEsS0FBSyxDQUFDZCxRQUFOLENBQWU0RSxNQUFmLENBWm9CO0FBQUEsTUFZdkNrQixNQVp1Qyx5QkFZdkNBLE1BWnVDO0FBQUEsTUFZL0JDLE9BWitCLHlCQVkvQkEsT0FaK0I7O0FBYzlDLFVBQVEvQixJQUFSO0FBQ0UsU0FBSyxRQUFMO0FBQ0U7QUFDQTZCLE1BQUFBLFNBQVMsR0FBRyxtQ0FBaUJqQixNQUFqQixDQUFaO0FBQ0E7O0FBRUYsU0FBSyxNQUFMO0FBQ0U7QUFDQSxVQUFNb0IsUUFBUSxHQUFHRixNQUFNLENBQUM5RCxTQUFQLENBQWlCLFVBQUF3QixDQUFDO0FBQUEsZUFBSUEsQ0FBQyxDQUFDSCxJQUFGLEtBQVdZLEtBQWY7QUFBQSxPQUFsQixDQUFqQjtBQUNBLFVBQUliLEtBQUssR0FBRzBDLE1BQU0sQ0FBQ0UsUUFBRCxDQUFsQjs7QUFFQSxVQUFJLENBQUM1QyxLQUFLLENBQUM2QyxVQUFYLEVBQXVCO0FBQ3JCO0FBQ0E7QUFDQTdDLFFBQUFBLEtBQUsscUJBQ0FBLEtBREE7QUFFSDZDLFVBQUFBLFVBQVUsRUFBRSxpQ0FBZUYsT0FBZixFQUF3QjNDLEtBQXhCO0FBRlQsVUFBTDtBQUlEOztBQUVEeUMsTUFBQUEsU0FBUyxxQkFDSkEsU0FESSxNQUVKekMsS0FBSyxDQUFDNkMsVUFGRjtBQUdQNUMsUUFBQUEsSUFBSSxFQUFFRCxLQUFLLENBQUNDLElBSEw7QUFJUDtBQUNBNkMsUUFBQUEsTUFBTSxFQUFFLElBTEQ7QUFNUEYsUUFBQUEsUUFBUSxFQUFSQTtBQU5PLFFBQVQ7QUFRQSxVQUFNRyxpQkFBaUIsR0FBR3JGLEtBQUssQ0FBQ2hCLE9BQU4sQ0FBY2tDLFNBQWQsQ0FBd0IsVUFBQXdCLENBQUM7QUFBQSxlQUFJQSxDQUFDLENBQUM0QyxRQUFOO0FBQUEsT0FBekIsQ0FBMUI7O0FBQ0EsVUFBSUQsaUJBQWlCLEdBQUcsQ0FBQyxDQUFyQixJQUEwQkEsaUJBQWlCLEtBQUtuRixHQUFwRCxFQUF5RDtBQUN2RDtBQUNBNkUsUUFBQUEsU0FBUyxDQUFDTyxRQUFWLEdBQXFCLEtBQXJCO0FBQ0Q7O0FBRUQ5RSxNQUFBQSxRQUFRLHFCQUNIUixLQURHO0FBRU5kLFFBQUFBLFFBQVEsb0JBQ0hjLEtBQUssQ0FBQ2QsUUFESCx1Q0FFTDRFLE1BRkssb0JBR0Q5RCxLQUFLLENBQUNkLFFBQU4sQ0FBZTRFLE1BQWYsQ0FIQztBQUlKa0IsVUFBQUEsTUFBTSxFQUFFQSxNQUFNLENBQUM3RSxHQUFQLENBQVcsVUFBQ0csQ0FBRCxFQUFJRCxDQUFKO0FBQUEsbUJBQVdBLENBQUMsS0FBSzZFLFFBQU4sR0FBaUI1QyxLQUFqQixHQUF5QmhDLENBQXBDO0FBQUEsV0FBWDtBQUpKO0FBRkYsUUFBUjtBQVVBOztBQUNGLFNBQUssT0FBTDtBQUNBO0FBQ0U7QUEvQ0osR0FkOEMsQ0FnRTlDOzs7QUFDQUUsRUFBQUEsUUFBUSxxQkFDSEEsUUFERztBQUVOeEIsSUFBQUEsT0FBTyxFQUFFZ0IsS0FBSyxDQUFDaEIsT0FBTixDQUFjbUIsR0FBZCxDQUFrQixVQUFDdUMsQ0FBRCxFQUFJckMsQ0FBSjtBQUFBLGFBQVdBLENBQUMsS0FBS0gsR0FBTixHQUFZNkUsU0FBWixHQUF3QnJDLENBQW5DO0FBQUEsS0FBbEI7QUFGSCxJQUFSLENBakU4QyxDQXNFOUM7O0FBQ0FsQyxFQUFBQSxRQUFRLHFCQUNIQSxRQURHO0FBRU50QixJQUFBQSxRQUFRLG9CQUNIc0IsUUFBUSxDQUFDdEIsUUFETix1Q0FFTDRFLE1BRkssb0JBR0R0RCxRQUFRLENBQUN0QixRQUFULENBQWtCNEUsTUFBbEIsQ0FIQyxNQUlELDZCQUFXbUIsT0FBWCxFQUFvQm5CLE1BQXBCLEVBQTRCdEQsUUFBUSxDQUFDeEIsT0FBckMsQ0FKQztBQUZGLElBQVI7QUFXQXdCLEVBQUFBLFFBQVEsR0FBRytFLHdCQUF3QixDQUFDL0UsUUFBRCxFQUFXc0QsTUFBWCxFQUFtQmlCLFNBQW5CLENBQW5DO0FBRUEsU0FBT3ZFLFFBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7QUFVTyxJQUFNZ0Ysb0JBQW9CLEdBQUcsU0FBdkJBLG9CQUF1QixDQUFDeEYsS0FBRCxTQUEyQjtBQUFBLE1BQWxCRSxHQUFrQixTQUFsQkEsR0FBa0I7QUFBQSxNQUFidUYsT0FBYSxTQUFiQSxPQUFhOztBQUM3RCxNQUFJVixTQUFTLHFCQUFPL0UsS0FBSyxDQUFDaEIsT0FBTixDQUFja0IsR0FBZCxDQUFQLE1BQThCdUYsT0FBOUIsQ0FBYjs7QUFDQSxNQUFNdkMsSUFBSSxHQUFHNUIsTUFBTSxDQUFDQyxJQUFQLENBQVlrRSxPQUFaLEVBQXFCLENBQXJCLENBQWI7O0FBQ0EsTUFBSXZDLElBQUksS0FBSyxPQUFiLEVBQXNCO0FBQ3BCLFFBQU13QyxRQUFRLEdBQUcsMkNBQXlCWCxTQUF6QixDQUFqQjs7QUFFQSxRQUFJVyxRQUFKLEVBQWM7QUFDWlgsTUFBQUEsU0FBUyxxQkFDSkEsU0FESSxNQUVKLGtEQUNHQSxTQURIO0FBQ2NXLFFBQUFBLFFBQVEsRUFBUkE7QUFEZCxVQUVEMUYsS0FBSyxDQUFDZCxRQUFOLENBQWU2RixTQUFTLENBQUNqQixNQUF6QixFQUFpQ21CLE9BRmhDLENBRkk7QUFNUFMsUUFBQUEsUUFBUSxFQUFSQTtBQU5PLFFBQVQ7QUFRRDtBQUNGOztBQUVELDJCQUNLMUYsS0FETDtBQUVFaEIsSUFBQUEsT0FBTyxFQUFFZ0IsS0FBSyxDQUFDaEIsT0FBTixDQUFjbUIsR0FBZCxDQUFrQixVQUFDdUMsQ0FBRCxFQUFJckMsQ0FBSjtBQUFBLGFBQVdBLENBQUMsS0FBS0gsR0FBTixHQUFZNkUsU0FBWixHQUF3QnJDLENBQW5DO0FBQUEsS0FBbEI7QUFGWDtBQUlELENBdEJNO0FBd0JQOzs7Ozs7Ozs7Ozs7O0FBU08sSUFBTWlELGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUIsQ0FBQzNGLEtBQUQsRUFBUWdCLE1BQVI7QUFBQSxTQUM5QixDQUFDQSxNQUFNLENBQUM4QyxNQUFSLEdBQ0k5RCxLQURKLHFCQUdTQSxLQUhUO0FBSU1oQixJQUFBQSxPQUFPLGdEQUFNZ0IsS0FBSyxDQUFDaEIsT0FBWixJQUFxQixtQ0FBaUJnQyxNQUFNLENBQUM4QyxNQUF4QixDQUFyQjtBQUpiLElBRDhCO0FBQUEsQ0FBekI7QUFRUDs7Ozs7Ozs7Ozs7O0FBUU8sSUFBTThCLHlCQUF5QixHQUFHLFNBQTVCQSx5QkFBNEIsQ0FBQzVGLEtBQUQsU0FBd0M7QUFBQSxNQUEvQmlCLFFBQStCLFNBQS9CQSxRQUErQjtBQUFBLE1BQXJCaUMsSUFBcUIsU0FBckJBLElBQXFCO0FBQUEsTUFBZjFCLFNBQWUsU0FBZkEsU0FBZTtBQUMvRSxNQUFNQyxRQUFRLEdBQUdSLFFBQVEsQ0FBQzRFLGtCQUFULENBQTRCM0MsSUFBNUIsRUFBa0MxQixTQUFsQyxDQUFqQjtBQUNBLDJCQUNLeEIsS0FETDtBQUVFcEIsSUFBQUEsTUFBTSxFQUFFb0IsS0FBSyxDQUFDcEIsTUFBTixDQUFhdUIsR0FBYixDQUFpQixVQUFBZ0IsQ0FBQztBQUFBLGFBQUlBLENBQUMsQ0FBQ0MsRUFBRixLQUFTSCxRQUFRLENBQUNHLEVBQWxCLEdBQXVCSyxRQUF2QixHQUFrQ04sQ0FBdEM7QUFBQSxLQUFsQjtBQUZWO0FBSUQsQ0FOTTtBQVFQOzs7Ozs7Ozs7Ozs7O0FBU08sSUFBTTJFLDRCQUE0QixHQUFHLFNBQS9CQSw0QkFBK0IsQ0FBQzlGLEtBQUQsRUFBUWdCLE1BQVI7QUFBQSwyQkFDdkNoQixLQUR1QztBQUUxQ2hCLElBQUFBLE9BQU8sRUFBRWdCLEtBQUssQ0FBQ2hCLE9BQU4sQ0FBY21CLEdBQWQsQ0FBa0IsVUFBQ3VDLENBQUQsRUFBSXJDLENBQUo7QUFBQSxhQUN6QkEsQ0FBQyxLQUFLVyxNQUFNLENBQUNkLEdBQWIscUJBQXVCd0MsQ0FBdkI7QUFBMEJxRCxRQUFBQSxXQUFXLEVBQUUsQ0FBQ3JELENBQUMsQ0FBQ3FEO0FBQTFDLFdBQXlEckQsQ0FEaEM7QUFBQSxLQUFsQjtBQUZpQztBQUFBLENBQXJDO0FBT1A7Ozs7Ozs7Ozs7Ozs7O0FBVU8sSUFBTXNELGlDQUFpQyxHQUFHLFNBQXBDQSxpQ0FBb0MsQ0FBQ2hHLEtBQUQsRUFBUWdCLE1BQVI7QUFBQSwyQkFDNUNoQixLQUQ0QztBQUUvQ2hCLElBQUFBLE9BQU8sRUFBRWdCLEtBQUssQ0FBQ2hCLE9BQU4sQ0FBY21CLEdBQWQsQ0FBa0IsVUFBQ3VDLENBQUQsRUFBSXJDLENBQUo7QUFBQSxhQUN6QkEsQ0FBQyxLQUFLVyxNQUFNLENBQUNkLEdBQWIscUJBQXVCd0MsQ0FBdkI7QUFBMEJoRSxRQUFBQSxLQUFLLEVBQUVzQyxNQUFNLENBQUN0QztBQUF4QyxXQUFpRGdFLENBRHhCO0FBQUEsS0FBbEI7QUFGc0M7QUFBQSxDQUExQztBQU9QOzs7Ozs7Ozs7Ozs7OztBQVdPLElBQU11RCwwQkFBMEIsR0FBRyxTQUE3QkEsMEJBQTZCLENBQUNqRyxLQUFEO0FBQUEsTUFBU21ELEtBQVQsU0FBU0EsS0FBVDtBQUFBLDJCQUNyQ25ELEtBRHFDO0FBRXhDRixJQUFBQSxlQUFlLG9CQUNWRSxLQUFLLENBQUNGLGVBREk7QUFFYnJCLE1BQUFBLFdBQVcsRUFBRTBFO0FBRkE7QUFGeUI7QUFBQSxDQUFuQztBQVFQOzs7Ozs7Ozs7Ozs7OztBQVdPLElBQU0rQyxnQ0FBZ0MsR0FBRyxTQUFuQ0EsZ0NBQW1DLENBQUNsRyxLQUFELFNBQW9CO0FBQUEsTUFBWHRCLEtBQVcsU0FBWEEsS0FBVztBQUNsRSwyQkFDS3NCLEtBREw7QUFFRUYsSUFBQUEsZUFBZSxvQkFDVkUsS0FBSyxDQUFDRixlQURJO0FBRWJwQixNQUFBQSxLQUFLLEVBQUxBO0FBRmE7QUFGakI7QUFPRCxDQVJNO0FBVVA7Ozs7Ozs7Ozs7Ozs7QUFTTyxJQUFNeUgsb0JBQW9CLEdBQUcsU0FBdkJBLG9CQUF1QixDQUFDbkcsS0FBRCxFQUFRZ0IsTUFBUixFQUFtQjtBQUNyRCxNQUFNb0YsVUFBVSxHQUFHcEcsS0FBSyxDQUFDaEIsT0FBTixDQUFjZ0MsTUFBTSxDQUFDZCxHQUFyQixFQUEwQm9GLFFBQTdDO0FBRUEsMkJBQ0t0RixLQURMO0FBRUVoQixJQUFBQSxPQUFPLEVBQUVnQixLQUFLLENBQUNoQixPQUFOLENBQWNtQixHQUFkLENBQWtCLFVBQUN1QyxDQUFELEVBQUlyQyxDQUFKLEVBQVU7QUFDbkNxQyxNQUFBQSxDQUFDLENBQUM0QyxRQUFGLEdBQWEsQ0FBQ2MsVUFBRCxJQUFlL0YsQ0FBQyxLQUFLVyxNQUFNLENBQUNkLEdBQXpDO0FBQ0EsYUFBT3dDLENBQVA7QUFDRCxLQUhRO0FBRlg7QUFPRCxDQVZNO0FBWVA7Ozs7Ozs7Ozs7Ozs7QUFTTyxJQUFNMkQsbUJBQW1CLEdBQUcsU0FBdEJBLG1CQUFzQixDQUFDckcsS0FBRCxFQUFRZ0IsTUFBUixFQUFtQjtBQUFBLE1BQzdDZCxHQUQ2QyxHQUN0Q2MsTUFEc0MsQ0FDN0NkLEdBRDZDO0FBQUEsTUFFN0M0RCxNQUY2QyxHQUVuQzlELEtBQUssQ0FBQ2hCLE9BQU4sQ0FBY2tCLEdBQWQsQ0FGbUMsQ0FFN0M0RCxNQUY2QztBQUlwRCxNQUFNd0MsVUFBVSxpREFDWHRHLEtBQUssQ0FBQ2hCLE9BQU4sQ0FBY21ELEtBQWQsQ0FBb0IsQ0FBcEIsRUFBdUJqQyxHQUF2QixDQURXLHVDQUVYRixLQUFLLENBQUNoQixPQUFOLENBQWNtRCxLQUFkLENBQW9CakMsR0FBRyxHQUFHLENBQTFCLEVBQTZCRixLQUFLLENBQUNoQixPQUFOLENBQWN5QixNQUEzQyxDQUZXLEVBQWhCOztBQUtBLE1BQU1ELFFBQVEscUJBQ1RSLEtBRFM7QUFFWmQsSUFBQUEsUUFBUSxvQkFDSGMsS0FBSyxDQUFDZCxRQURILHVDQUVMNEUsTUFGSyxvQkFHRDlELEtBQUssQ0FBQ2QsUUFBTixDQUFlNEUsTUFBZixDQUhDLE1BSUQsNkJBQVc5RCxLQUFLLENBQUNkLFFBQU4sQ0FBZTRFLE1BQWYsRUFBdUJtQixPQUFsQyxFQUEyQ25CLE1BQTNDLEVBQW1Ed0MsVUFBbkQsQ0FKQyxHQUZJO0FBU1p0SCxJQUFBQSxPQUFPLEVBQUVzSDtBQVRHLElBQWQ7O0FBWUEsU0FBT2Ysd0JBQXdCLENBQUMvRSxRQUFELEVBQVdzRCxNQUFYLENBQS9CO0FBQ0QsQ0F0Qk07QUF3QlA7Ozs7Ozs7Ozs7Ozs7QUFTTyxJQUFNeUMsZUFBZSxHQUFHLFNBQWxCQSxlQUFrQixDQUFDdkcsS0FBRCxFQUFRZ0IsTUFBUixFQUFtQjtBQUNoRCxNQUFNd0YsY0FBYyxHQUFHbEYsTUFBTSxDQUFDQyxJQUFQLENBQVl2QixLQUFLLENBQUNkLFFBQWxCLEVBQTRCLENBQTVCLENBQXZCO0FBQ0EsTUFBTXVDLFFBQVEsR0FBRyxJQUFJZ0YsYUFBSjtBQUNmOUYsSUFBQUEsU0FBUyxFQUFFLElBREk7QUFFZitGLElBQUFBLGNBQWMsRUFBRSxJQUZEO0FBR2Y1QyxJQUFBQSxNQUFNLEVBQUUwQztBQUhPLEtBSVp4RixNQUFNLENBQUNLLEtBSkssRUFBakI7QUFPQSwyQkFDS3JCLEtBREw7QUFFRXBCLElBQUFBLE1BQU0sZ0RBQU1vQixLQUFLLENBQUNwQixNQUFaLElBQW9CNkMsUUFBcEIsRUFGUjtBQUdFNUMsSUFBQUEsU0FBUyxnREFBTW1CLEtBQUssQ0FBQ25CLFNBQVosSUFBdUIsRUFBdkIsRUFIWDtBQUlFRSxJQUFBQSxVQUFVLGdEQUFNaUIsS0FBSyxDQUFDakIsVUFBWixJQUF3QmlCLEtBQUssQ0FBQ2pCLFVBQU4sQ0FBaUIwQixNQUF6QyxFQUpaO0FBS0VkLElBQUFBLFNBQVMsRUFBRSwyQ0FBdUJLLEtBQUssQ0FBQ0wsU0FBN0IsRUFBd0M4QixRQUF4QztBQUxiO0FBT0QsQ0FoQk07QUFrQlA7Ozs7Ozs7Ozs7Ozs7QUFTTyxJQUFNa0Ysa0JBQWtCLEdBQUcsU0FBckJBLGtCQUFxQixDQUFDM0csS0FBRCxTQUFrQjtBQUFBLE1BQVRFLEdBQVMsU0FBVEEsR0FBUztBQUFBLE1BQzNDdEIsTUFEMkMsR0FDRm9CLEtBREUsQ0FDM0NwQixNQUQyQztBQUFBLE1BQ25DQyxTQURtQyxHQUNGbUIsS0FERSxDQUNuQ25CLFNBRG1DO0FBQUEsTUFDeEJZLE9BRHdCLEdBQ0ZPLEtBREUsQ0FDeEJQLE9BRHdCO0FBQUEsTUFDZkQsU0FEZSxHQUNGUSxLQURFLENBQ2ZSLFNBRGU7QUFFbEQsTUFBTW9ILGFBQWEsR0FBRzVHLEtBQUssQ0FBQ3BCLE1BQU4sQ0FBYXNCLEdBQWIsQ0FBdEI7QUFDQSxNQUFNMkcsT0FBTyxHQUFHLDZDQUF5QjdHLEtBQUssQ0FBQ0wsU0FBL0IsRUFBMENpSCxhQUExQyxDQUFoQjs7QUFFQSxNQUFNcEcsUUFBUSxxQkFDVFIsS0FEUztBQUVacEIsSUFBQUEsTUFBTSxnREFBTUEsTUFBTSxDQUFDdUQsS0FBUCxDQUFhLENBQWIsRUFBZ0JqQyxHQUFoQixDQUFOLHVDQUErQnRCLE1BQU0sQ0FBQ3VELEtBQVAsQ0FBYWpDLEdBQUcsR0FBRyxDQUFuQixFQUFzQnRCLE1BQU0sQ0FBQzZCLE1BQTdCLENBQS9CLEVBRk07QUFHWjVCLElBQUFBLFNBQVMsZ0RBQ0pBLFNBQVMsQ0FBQ3NELEtBQVYsQ0FBZ0IsQ0FBaEIsRUFBbUJqQyxHQUFuQixDQURJLHVDQUVKckIsU0FBUyxDQUFDc0QsS0FBVixDQUFnQmpDLEdBQUcsR0FBRyxDQUF0QixFQUF5QnJCLFNBQVMsQ0FBQzRCLE1BQW5DLENBRkksRUFIRztBQU9aMUIsSUFBQUEsVUFBVSxFQUFFaUIsS0FBSyxDQUFDakIsVUFBTixDQUNUeUQsTUFEUyxDQUNGLFVBQUFuQyxDQUFDO0FBQUEsYUFBSUEsQ0FBQyxLQUFLSCxHQUFWO0FBQUEsS0FEQyxFQUVUQyxHQUZTLENBRUwsVUFBQTJHLEdBQUc7QUFBQSxhQUFLQSxHQUFHLEdBQUc1RyxHQUFOLEdBQVk0RyxHQUFHLEdBQUcsQ0FBbEIsR0FBc0JBLEdBQTNCO0FBQUEsS0FGRSxDQVBBO0FBVVpySCxJQUFBQSxPQUFPLEVBQUVtSCxhQUFhLENBQUNHLGNBQWQsQ0FBNkJ0SCxPQUE3QixJQUF3Q0wsU0FBeEMsR0FBb0RLLE9BVmpEO0FBV1pELElBQUFBLFNBQVMsRUFBRW9ILGFBQWEsQ0FBQ0csY0FBZCxDQUE2QnZILFNBQTdCLElBQTBDSixTQUExQyxHQUFzREksU0FYckQ7QUFZWkcsSUFBQUEsU0FBUyxFQUFFa0g7QUFaQyxJQUFkOztBQWVBLFNBQU8vRixxQkFBcUIsQ0FBQ04sUUFBRCxDQUE1QjtBQUNELENBckJNO0FBdUJQOzs7Ozs7Ozs7Ozs7O0FBU08sSUFBTXdHLG1CQUFtQixHQUFHLFNBQXRCQSxtQkFBc0IsQ0FBQ2hILEtBQUQ7QUFBQSxNQUFTaUgsS0FBVCxTQUFTQSxLQUFUO0FBQUEsMkJBQzlCakgsS0FEOEI7QUFFakNqQixJQUFBQSxVQUFVLEVBQUVrSTtBQUZxQjtBQUFBLENBQTVCO0FBS1A7Ozs7Ozs7Ozs7Ozs7QUFTTyxJQUFNQyxvQkFBb0IsR0FBRyxTQUF2QkEsb0JBQXVCLENBQUNsSCxLQUFELEVBQVFnQixNQUFSLEVBQW1CO0FBQ3JEO0FBRHFELE1BRXpDbUcsVUFGeUMsR0FFM0JuRyxNQUYyQixDQUU5Q29HLEdBRjhDO0FBQUEsTUFHOUNsSSxRQUg4QyxHQUdsQ2MsS0FIa0MsQ0FHOUNkLFFBSDhDLEVBS3JEOztBQUNBLE1BQUksQ0FBQ0EsUUFBUSxDQUFDaUksVUFBRCxDQUFiLEVBQTJCO0FBQ3pCLFdBQU9uSCxLQUFQO0FBQ0Q7QUFFRDs7O0FBVnFELE1BWW5EcEIsTUFabUQsR0FjakRvQixLQWRpRCxDQVluRHBCLE1BWm1EO0FBQUEsd0JBY2pEb0IsS0FkaUQsQ0FhbkRkLFFBYm1EO0FBQUEsTUFhMUI2RSxPQWIwQixtQkFhdkNvRCxVQWJ1QztBQUFBLE1BYWRFLFdBYmMsK0RBYXZDRixVQWJ1QztBQWVyRDs7QUFFQSxNQUFNRyxPQUFPLEdBQUcxSSxNQUFNLENBQUMySSxNQUFQLENBQWMsVUFBQ0MsYUFBRCxFQUFnQnZILEtBQWhCLEVBQXVCd0gsS0FBdkIsRUFBaUM7QUFDN0QsUUFBSXhILEtBQUssQ0FBQ1MsTUFBTixDQUFhb0QsTUFBYixLQUF3QnFELFVBQTVCLEVBQXdDO0FBQ3RDSyxNQUFBQSxhQUFhLENBQUNFLElBQWQsQ0FBbUJELEtBQW5CO0FBQ0Q7O0FBQ0QsV0FBT0QsYUFBUDtBQUNELEdBTGUsRUFLYixFQUxhLENBQWhCLENBakJxRCxDQXdCckQ7O0FBeEJxRCx3QkF5QmxDRixPQUFPLENBQUNDLE1BQVIsQ0FDakIsaUJBQXlDckgsR0FBekMsRUFBaUQ7QUFBQSxRQUFyQ3lILFlBQXFDLFNBQS9DbkgsUUFBK0M7QUFBQSxRQUF2Qm9ILFlBQXVCLFNBQXZCQSxZQUF1QjtBQUMvQyxRQUFNQyxZQUFZLEdBQUczSCxHQUFHLEdBQUcwSCxZQUEzQjtBQUNBRCxJQUFBQSxZQUFZLEdBQUdoQixrQkFBa0IsQ0FBQ2dCLFlBQUQsRUFBZTtBQUFDekgsTUFBQUEsR0FBRyxFQUFFMkg7QUFBTixLQUFmLENBQWpDO0FBQ0FELElBQUFBLFlBQVk7QUFDWixXQUFPO0FBQUNwSCxNQUFBQSxRQUFRLEVBQUVtSCxZQUFYO0FBQXlCQyxNQUFBQSxZQUFZLEVBQVpBO0FBQXpCLEtBQVA7QUFDRCxHQU5nQixFQU9qQjtBQUFDcEgsSUFBQUEsUUFBUSxvQkFBTVIsS0FBTjtBQUFhZCxNQUFBQSxRQUFRLEVBQUVtSTtBQUF2QixNQUFUO0FBQThDTyxJQUFBQSxZQUFZLEVBQUU7QUFBNUQsR0FQaUIsQ0F6QmtDO0FBQUEsTUF5QjlDcEgsUUF6QjhDLG1CQXlCOUNBLFFBekI4QyxFQW1DckQ7OztBQUNBLE1BQU14QixPQUFPLEdBQUdnQixLQUFLLENBQUNoQixPQUFOLENBQWN3RCxNQUFkLENBQXFCLFVBQUFBLE1BQU07QUFBQSxXQUFJQSxNQUFNLENBQUNzQixNQUFQLEtBQWtCcUQsVUFBdEI7QUFBQSxHQUEzQixDQUFoQixDQXBDcUQsQ0FzQ3JEOztBQXRDcUQsTUF1Q2hEOUgsaUJBdkNnRCxHQXVDM0JXLEtBdkMyQixDQXVDaERYLGlCQXZDZ0Q7QUFBQSwyQkF3Q25DQSxpQkF4Q21DO0FBQUEsTUF3QzlDeUksT0F4QzhDLHNCQXdDOUNBLE9BeEM4Qzs7QUF5Q3JELE1BQUlBLE9BQUosRUFBYTtBQUFBLFFBQ0pwSCxNQURJLEdBQ01vSCxPQUROLENBQ0pwSCxNQURJO0FBRVg7O0FBRlcsK0JBR3FDQSxNQUFNLENBQUNxSCxZQUg1QztBQUFBLFFBR1UvQyxNQUhWLHdCQUdIbUMsVUFIRztBQUFBLFFBR3FCWSxZQUhyQixvRUFHSFosVUFIRztBQUlYOztBQUNBOUgsSUFBQUEsaUJBQWlCLHFCQUNaQSxpQkFEWTtBQUVmeUksTUFBQUEsT0FBTyxvQkFBTUEsT0FBTjtBQUFlcEgsUUFBQUEsTUFBTSxvQkFBTUEsTUFBTjtBQUFjcUgsVUFBQUEsWUFBWSxFQUFaQTtBQUFkO0FBQXJCO0FBRlEsTUFBakI7QUFJRDs7QUFFRCwyQkFBV3ZILFFBQVg7QUFBcUJ4QixJQUFBQSxPQUFPLEVBQVBBLE9BQXJCO0FBQThCSyxJQUFBQSxpQkFBaUIsRUFBakJBO0FBQTlCO0FBQ0QsQ0FyRE07QUF1RFA7Ozs7Ozs7Ozs7Ozs7QUFTTyxJQUFNMkksMEJBQTBCLEdBQUcsU0FBN0JBLDBCQUE2QixDQUFDaEksS0FBRCxFQUFRZ0IsTUFBUjtBQUFBLDJCQUNyQ2hCLEtBRHFDO0FBRXhDVCxJQUFBQSxhQUFhLEVBQUV5QixNQUFNLENBQUNpSDtBQUZrQjtBQUFBLENBQW5DO0FBS1A7Ozs7Ozs7Ozs7Ozs7QUFTTyxJQUFNQyx1QkFBdUIsR0FBRyxTQUExQkEsdUJBQTBCLENBQUNsSSxLQUFELEVBQVFnQixNQUFSLEVBQW1CO0FBQ3hELDJCQUNLaEIsS0FETDtBQUVFYixJQUFBQSxjQUFjLEVBQUU2QixNQUFNLENBQUM4QztBQUZ6QjtBQUlELENBTE07QUFPUDs7Ozs7Ozs7Ozs7QUFPTyxJQUFNcUUscUJBQXFCLEdBQUcsU0FBeEJBLHFCQUF3QixDQUFBbkksS0FBSztBQUFBLDJCQUNyQ3JCLGlCQURxQyxNQUVyQ3FCLEtBQUssQ0FBQ29JLFlBRitCO0FBR3hDQSxJQUFBQSxZQUFZLEVBQUVwSSxLQUFLLENBQUNvSTtBQUhvQjtBQUFBLENBQW5DO0FBTVA7Ozs7Ozs7Ozs7Ozs7OztBQVdPLElBQU1DLHVCQUF1QixHQUFHLFNBQTFCQSx1QkFBMEIsQ0FDckNySSxLQURxQyxTQUdsQztBQUFBLDRCQURGc0ksT0FDRTtBQUFBLDJDQURRNUgsTUFDUjtBQUFBLE1BRFFBLE1BQ1IscUNBRGlCLEVBQ2pCO0FBQUEsNENBRHFCNkgsT0FDckI7QUFBQSxNQURxQkEsT0FDckIsc0NBRCtCLEVBQy9COztBQUNILE1BQUksQ0FBQzdILE1BQU0sQ0FBQzhILFFBQVosRUFBc0I7QUFDcEIsV0FBT3hJLEtBQVA7QUFDRDs7QUFIRSx5QkFZQ1UsTUFBTSxDQUFDOEgsUUFaUjtBQUFBLE1BTUR4SixPQU5DLG9CQU1EQSxPQU5DO0FBQUEsTUFPREosTUFQQyxvQkFPREEsTUFQQztBQUFBLE1BUURTLGlCQVJDLG9CQVFEQSxpQkFSQztBQUFBLE1BU0RFLGFBVEMsb0JBU0RBLGFBVEM7QUFBQSxNQVVESSxTQVZDLG9CQVVEQSxTQVZDO0FBQUEsTUFXREcsZUFYQyxvQkFXREEsZUFYQztBQUFBLE1BY0kySSxrQkFkSixHQWMwQkYsT0FkMUIsQ0FjSUUsa0JBZEosRUFnQkg7O0FBQ0EsTUFBSUMsV0FBVyxHQUFHLENBQUNELGtCQUFELEdBQXNCTixxQkFBcUIsQ0FBQ25JLEtBQUQsQ0FBM0MsR0FBcURBLEtBQXZFO0FBQ0EwSSxFQUFBQSxXQUFXLEdBQUcsa0NBQWFBLFdBQWIsRUFBMEIxSixPQUExQixDQUFkO0FBQ0EwSixFQUFBQSxXQUFXLEdBQUcsaUNBQVlBLFdBQVosRUFBeUI5SixNQUF6QixDQUFkO0FBQ0E4SixFQUFBQSxXQUFXLEdBQUcsdUNBQWtCQSxXQUFsQixFQUErQnJKLGlCQUEvQixDQUFkO0FBQ0FxSixFQUFBQSxXQUFXLEdBQUcsd0NBQW1CQSxXQUFuQixFQUFnQ25KLGFBQWhDLENBQWQ7QUFDQW1KLEVBQUFBLFdBQVcsR0FBRyxvQ0FBZUEsV0FBZixFQUE0Qi9JLFNBQTVCLENBQWQ7QUFDQStJLEVBQUFBLFdBQVcsR0FBRywwQ0FBcUJBLFdBQXJCLEVBQWtDNUksZUFBbEMsQ0FBZDtBQUVBLFNBQU80SSxXQUFQO0FBQ0QsQ0E3Qk07QUErQlA7Ozs7Ozs7Ozs7Ozs7QUFTTyxJQUFNQyxpQkFBaUIsR0FBRyxTQUFwQkEsaUJBQW9CLENBQUMzSSxLQUFELEVBQVFnQixNQUFSO0FBQUEsMkJBQzVCaEIsS0FENEI7QUFFL0JSLElBQUFBLFNBQVMsRUFBRXdCLE1BQU0sQ0FBQzRIO0FBRmE7QUFBQSxDQUExQjtBQUtQOzs7Ozs7Ozs7Ozs7O0FBU08sSUFBTUMsaUJBQWlCLEdBQUcsU0FBcEJBLGlCQUFvQixDQUFDN0ksS0FBRCxFQUFRZ0IsTUFBUjtBQUFBLDJCQUM1QmhCLEtBRDRCO0FBRS9CTixJQUFBQSxRQUFRLEVBQUVNLEtBQUssQ0FBQ1gsaUJBQU4sQ0FBd0J5SixVQUF4QixDQUFtQ2pJLE9BQW5DLHFCQUVEYixLQUFLLENBQUNOLFFBRkw7QUFHSnFKLE1BQUFBLE1BQU0sRUFBRS9JLEtBQUssQ0FBQ04sUUFBTixDQUFlcUosTUFBZixHQUF3QixJQUF4QixHQUErQix3QkFBVS9JLEtBQUssQ0FBQ04sUUFBaEI7QUFIbkMsU0FLTk0sS0FBSyxDQUFDTixRQVBxQjtBQVEvQkQsSUFBQUEsT0FBTyxFQUFFdUIsTUFBTSxDQUFDNEgsSUFBUCxJQUFlNUgsTUFBTSxDQUFDNEgsSUFBUCxDQUFZSSxNQUEzQixHQUFvQ2hJLE1BQU0sQ0FBQzRILElBQTNDLEdBQWtEO0FBUjVCO0FBQUEsQ0FBMUI7QUFXUDs7Ozs7Ozs7Ozs7QUFPTyxJQUFNSyxlQUFlLEdBQUcsU0FBbEJBLGVBQWtCLENBQUFqSixLQUFLLEVBQUk7QUFDdEMsMkJBQ0tBLEtBREw7QUFFRVAsSUFBQUEsT0FBTyxFQUFFO0FBRlg7QUFJRCxDQUxNOzs7O0FBT0EsSUFBTXlKLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUIsQ0FBQ2xKLEtBQUQsVUFBa0I7QUFBQSxNQUFUbUosR0FBUyxVQUFUQSxHQUFTOztBQUNoRCxNQUFJN0gsTUFBTSxDQUFDOEgsTUFBUCxDQUFjcEosS0FBSyxDQUFDWCxpQkFBcEIsRUFBdUNnSyxJQUF2QyxDQUE0QyxVQUFBM0ksTUFBTTtBQUFBLFdBQUlBLE1BQU0sQ0FBQ0csT0FBWDtBQUFBLEdBQWxELENBQUosRUFBMkU7QUFDekUsNkJBQ0tiLEtBREw7QUFFRU4sTUFBQUEsUUFBUSxvQkFDSE0sS0FBSyxDQUFDTixRQURIO0FBRU40SixRQUFBQSxhQUFhLHNDQUFNSCxHQUFHLENBQUNJLEtBQVYsQ0FGUDtBQUdOVCxRQUFBQSxVQUFVLHNDQUFNSyxHQUFHLENBQUNLLE1BQVY7QUFISjtBQUZWO0FBUUQ7O0FBRUQsU0FBT3hKLEtBQVA7QUFDRCxDQWJNO0FBY1A7Ozs7Ozs7Ozs7Ozs7QUFTTyxJQUFNeUoscUJBQXFCLEdBQUcsU0FBeEJBLHFCQUF3QixDQUFDekosS0FBRCxFQUFRZ0IsTUFBUjtBQUFBLFNBQ25DaEIsS0FBSyxDQUFDTCxTQUFOLElBQW1CSyxLQUFLLENBQUNMLFNBQU4sQ0FBZ0JjLE1BQWhCLEtBQTJCLENBQTlDLHFCQUVTVCxLQUZUO0FBR007QUFDQTtBQUNBTCxJQUFBQSxTQUFTLEVBQUUsMENBQXNCSyxLQUFLLENBQUNwQixNQUE1QjtBQUxqQixPQU9JOEssdUJBQXVCLENBQUMxSixLQUFELEVBQVFnQixNQUFSLENBUlE7QUFBQSxDQUE5QjtBQVVQOzs7Ozs7Ozs7Ozs7OztBQVVPLElBQU0ySSx3QkFBd0IsR0FBRyxTQUEzQkEsd0JBQTJCLENBQUMzSixLQUFELFVBQWdDO0FBQUEsTUFBdkI0SixRQUF1QixVQUF2QkEsUUFBdUI7QUFBQSxNQUFiQyxPQUFhLFVBQWJBLE9BQWE7QUFBQSxNQUMvRGxLLFNBRCtELEdBQ2xESyxLQURrRCxDQUMvREwsU0FEK0Q7QUFHdEUsMkJBQ0tLLEtBREw7QUFFRUwsSUFBQUEsU0FBUyxFQUFFQSxTQUFTLENBQUNRLEdBQVYsQ0FBYyxVQUFDMkosRUFBRCxFQUFLekosQ0FBTDtBQUFBLGFBQ3ZCQSxDQUFDLEtBQUt1SixRQUFOLHFCQUVTakssU0FBUyxDQUFDVSxDQUFELENBRmxCO0FBR016QixRQUFBQSxNQUFNLG9CQUNEZSxTQUFTLENBQUNVLENBQUQsQ0FBVCxDQUFhekIsTUFEWix1Q0FHSGlMLE9BSEcsRUFHTyxDQUFDbEssU0FBUyxDQUFDVSxDQUFELENBQVQsQ0FBYXpCLE1BQWIsQ0FBb0JpTCxPQUFwQixDQUhSO0FBSFosV0FTSUMsRUFWbUI7QUFBQSxLQUFkO0FBRmI7QUFlRCxDQWxCTTtBQW9CUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7Ozs7O0FBQ08sSUFBTUMsb0JBQW9CLEdBQUcsU0FBdkJBLG9CQUF1QixDQUFDL0osS0FBRCxFQUFRZ0IsTUFBUixFQUFtQjtBQUNyRDtBQURxRCxNQUU5Q04sTUFGOEMsR0FFM0JNLE1BRjJCLENBRTlDTixNQUY4QztBQUFBLE1BRXRDNkgsT0FGc0MsR0FFM0J2SCxNQUYyQixDQUV0Q3VILE9BRnNDO0FBSXJELE1BQU1ySixRQUFRLEdBQUc4SyxLQUFLLENBQUNDLE9BQU4sQ0FBY2pKLE1BQU0sQ0FBQzlCLFFBQXJCLElBQ2I4QixNQUFNLENBQUM5QixRQURNLEdBRWIsQ0FBQzhCLE1BQU0sQ0FBQzlCLFFBQVIsQ0FGSjtBQUlBLE1BQU1nTCxjQUFjLEdBQUdoTCxRQUFRLENBQUNxSSxNQUFULENBQ3JCLFVBQUM0QyxJQUFEO0FBQUEsNkJBQVF2QixJQUFSO0FBQUEsUUFBUUEsSUFBUiw0QkFBZSxFQUFmO0FBQUEsUUFBbUJ3QixJQUFuQixVQUFtQkEsSUFBbkI7QUFBQSw2QkFDS0QsSUFETCxNQUVNLHNDQUFtQjtBQUFDdkIsTUFBQUEsSUFBSSxFQUFKQSxJQUFEO0FBQU93QixNQUFBQSxJQUFJLEVBQUpBO0FBQVAsS0FBbkIsRUFBaUNwSyxLQUFLLENBQUNkLFFBQXZDLEtBQW9ELEVBRjFEO0FBQUEsR0FEcUIsRUFLckIsRUFMcUIsQ0FBdkI7O0FBT0EsTUFBSSxDQUFDb0MsTUFBTSxDQUFDQyxJQUFQLENBQVkySSxjQUFaLEVBQTRCekosTUFBakMsRUFBeUM7QUFDdkMsV0FBT1QsS0FBUDtBQUNELEdBakJvRCxDQW1CckQ7OztBQUNBLE1BQU1xSyxhQUFhLEdBQUczSixNQUFNLEdBQ3hCMkgsdUJBQXVCLENBQUNySSxLQUFELEVBQVE7QUFDN0JzSSxJQUFBQSxPQUFPLEVBQUU7QUFBQzVILE1BQUFBLE1BQU0sRUFBTkEsTUFBRDtBQUFTNkgsTUFBQUEsT0FBTyxFQUFQQTtBQUFUO0FBRG9CLEdBQVIsQ0FEQyxHQUl4QnZJLEtBSko7O0FBTUEsTUFBTXNLLGdCQUFnQixxQkFDakJELGFBRGlCO0FBRXBCbkwsSUFBQUEsUUFBUSxvQkFDSG1MLGFBQWEsQ0FBQ25MLFFBRFgsTUFFSGdMLGNBRkc7QUFGWSxJQUF0QixDQTFCcUQsQ0FrQ3JEOzs7QUFsQ3FELDhCQXdDakRJLGdCQXhDaUQsQ0FvQ25EckwsZ0JBcENtRDtBQUFBLE1Bb0NuREEsZ0JBcENtRCxzQ0FvQ2hDLEVBcENnQztBQUFBLDhCQXdDakRxTCxnQkF4Q2lELENBcUNuRHhMLGVBckNtRDtBQUFBLE1BcUNuREEsZUFyQ21ELHNDQXFDakMsRUFyQ2lDO0FBQUEsOEJBd0NqRHdMLGdCQXhDaUQsQ0FzQ25EaEwscUJBdENtRDtBQUFBLE1Bc0NuREEscUJBdENtRCxzQ0FzQzNCLEVBdEMyQjtBQUFBLDhCQXdDakRnTCxnQkF4Q2lELENBdUNuREMsbUJBdkNtRDtBQUFBLE1BdUNuREEsbUJBdkNtRCxzQ0F1QzdCLEVBdkM2QiwwQkEwQ3JEOztBQUNBLE1BQUk3QixXQUFXLEdBQUcsa0NBQWE0QixnQkFBYixFQUErQnJMLGdCQUEvQixDQUFsQixDQTNDcUQsQ0E2Q3JEOztBQUNBeUosRUFBQUEsV0FBVyxHQUFHLGlDQUFZQSxXQUFaLEVBQXlCNUosZUFBekIsQ0FBZCxDQTlDcUQsQ0FnRHJEOztBQUNBNEosRUFBQUEsV0FBVyxHQUFHLG9DQUFlQSxXQUFmLEVBQTRCNkIsbUJBQTVCLENBQWQ7QUFFQSxNQUFJQyxTQUFTLEdBQUc5QixXQUFXLENBQUM5SixNQUFaLENBQW1CNEQsTUFBbkIsQ0FDZCxVQUFBckIsQ0FBQztBQUFBLFdBQUlBLENBQUMsQ0FBQ1QsTUFBRixDQUFTb0QsTUFBVCxJQUFtQm9HLGNBQXZCO0FBQUEsR0FEYSxDQUFoQjs7QUFJQSxNQUFJLENBQUNNLFNBQVMsQ0FBQy9KLE1BQWYsRUFBdUI7QUFDckI7QUFDQSxRQUFNZ0ssTUFBTSxHQUFHQyxnQkFBZ0IsQ0FBQ2hDLFdBQUQsRUFBY3dCLGNBQWQsQ0FBL0I7QUFDQXhCLElBQUFBLFdBQVcsR0FBRytCLE1BQU0sQ0FBQ3pLLEtBQXJCO0FBQ0F3SyxJQUFBQSxTQUFTLEdBQUdDLE1BQU0sQ0FBQ0QsU0FBbkI7QUFDRDs7QUFFRCxNQUFJOUIsV0FBVyxDQUFDL0ksU0FBWixDQUFzQmMsTUFBMUIsRUFBa0M7QUFDaEM7QUFDQStKLElBQUFBLFNBQVMsR0FBRzlCLFdBQVcsQ0FBQzlKLE1BQVosQ0FBbUI0RCxNQUFuQixDQUNWLFVBQUFyQixDQUFDO0FBQUEsYUFBSUEsQ0FBQyxDQUFDVCxNQUFGLENBQVNvRCxNQUFULElBQW1Cb0csY0FBdkI7QUFBQSxLQURTLENBQVo7QUFHQXhCLElBQUFBLFdBQVcscUJBQ05BLFdBRE07QUFFVC9JLE1BQUFBLFNBQVMsRUFBRSwyQ0FBdUIrSSxXQUFXLENBQUMvSSxTQUFuQyxFQUE4QzZLLFNBQTlDO0FBRkYsTUFBWDtBQUlELEdBdkVvRCxDQXlFckQ7OztBQUNBOUIsRUFBQUEsV0FBVyxHQUFHLHVDQUFrQkEsV0FBbEIsRUFBK0JwSixxQkFBL0IsQ0FBZCxDQTFFcUQsQ0E0RXJEOztBQUNBZ0MsRUFBQUEsTUFBTSxDQUFDQyxJQUFQLENBQVkySSxjQUFaLEVBQTRCdEYsT0FBNUIsQ0FBb0MsVUFBQWQsTUFBTSxFQUFJO0FBQzVDLFFBQU02RyxhQUFhLEdBQ2pCakMsV0FBVyxDQUFDckosaUJBQVosQ0FBOEJ5SSxPQUE5QixDQUFzQ3BILE1BQXRDLENBQTZDcUgsWUFBN0MsQ0FBMERqRSxNQUExRCxDQURGOztBQUVBLFFBQUksQ0FBQ2tHLEtBQUssQ0FBQ0MsT0FBTixDQUFjVSxhQUFkLENBQUQsSUFBaUMsQ0FBQ0EsYUFBYSxDQUFDbEssTUFBcEQsRUFBNEQ7QUFDMURpSSxNQUFBQSxXQUFXLEdBQUdrQyxrQkFBa0IsQ0FBQ2xDLFdBQUQsRUFBY3dCLGNBQWMsQ0FBQ3BHLE1BQUQsQ0FBNUIsQ0FBaEM7QUFDRDtBQUNGLEdBTkQ7QUFRQSxNQUFJK0csWUFBWSxHQUFHdEYsd0JBQXdCLENBQ3pDbUQsV0FEeUMsRUFFekNwSCxNQUFNLENBQUNDLElBQVAsQ0FBWTJJLGNBQVosQ0FGeUMsQ0FBM0MsQ0FyRnFELENBMEZyRDtBQUNBOztBQUNBVyxFQUFBQSxZQUFZLEdBQUcvSixxQkFBcUIsQ0FBQytKLFlBQUQsQ0FBcEM7QUFFQSxTQUFPQSxZQUFQO0FBQ0QsQ0EvRk07QUFnR1A7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFTQSxTQUFTbkIsdUJBQVQsQ0FBaUMxSixLQUFqQyxFQUF3Q2dCLE1BQXhDLEVBQWdEO0FBQzlDO0FBQ0EsTUFBTThKLGVBQWUsR0FBRyxJQUFJOUosTUFBTSxDQUFDc0gsT0FBbkM7QUFDQSxNQUFNeUMsU0FBUyxHQUFHL0ssS0FBSyxDQUFDTCxTQUFOLENBQWdCbUwsZUFBaEIsRUFBaUNsTSxNQUFuRDtBQUg4QyxNQUl2Q0EsTUFKdUMsR0FJN0JvQixLQUo2QixDQUl2Q3BCLE1BSnVDLEVBTTlDOztBQUNBLE1BQU00TCxTQUFTLEdBQUc1TCxNQUFNLENBQUN1QixHQUFQLENBQVcsVUFBQUYsS0FBSztBQUFBLFdBQ2hDLENBQUM4SyxTQUFTLENBQUM5SyxLQUFLLENBQUNtQixFQUFQLENBQVYsSUFBd0JuQixLQUFLLENBQUNTLE1BQU4sQ0FBYUMsU0FBckMsR0FDSVYsS0FBSyxDQUFDeUIsaUJBQU4sQ0FBd0I7QUFDdEI7QUFDQWYsTUFBQUEsU0FBUyxFQUFFO0FBRlcsS0FBeEIsQ0FESixHQUtJVixLQU40QjtBQUFBLEdBQWhCLENBQWxCLENBUDhDLENBZ0I5Qzs7QUFDQSwyQkFDS0QsS0FETDtBQUVFcEIsSUFBQUEsTUFBTSxFQUFFNEwsU0FGVjtBQUdFN0ssSUFBQUEsU0FBUyxFQUFFO0FBSGI7QUFLRDtBQUVEOzs7Ozs7Ozs7OztBQVNPLElBQU1xTCxnQkFBZ0IsR0FBRyxTQUFuQkEsZ0JBQW1CLENBQUNoTCxLQUFELEVBQVFnQixNQUFSLEVBQW1CO0FBQUEsTUFFMUNpSyxLQUYwQyxHQUVqQ2pLLE1BRmlDLENBRTFDaUssS0FGMEM7QUFHakQsTUFBTUMsV0FBVyxHQUFHRCxLQUFLLENBQUM5SyxHQUFOLENBQVUsVUFBQWdMLFFBQVE7QUFBQSxXQUFJLGtDQUFrQkEsUUFBbEIsQ0FBSjtBQUFBLEdBQWxCLENBQXBCLENBSGlELENBSWpEOztBQUNBLE1BQU1DLGFBQWEsR0FBRyxDQUNwQkMsa0JBQUtDLEdBQUwsQ0FBU0osV0FBVyxDQUFDL0ssR0FBWixDQUFnQm9MLHNCQUFoQixDQUFULEVBQTBDQyxLQUExQyxDQUNFLFVBQUFDLE9BQU8sRUFBSTtBQUNULFFBQU1yQixJQUFJLEdBQUdxQixPQUFPLENBQUNsRSxNQUFSLENBQ1gsVUFBQzdFLENBQUQsRUFBSWdKLENBQUo7QUFBQSxhQUFXO0FBQ1Q7QUFDQXhNLFFBQUFBLFFBQVEsRUFBRXdELENBQUMsQ0FBQ3hELFFBQUYsQ0FBV3lNLE1BQVgsQ0FBa0JELENBQUMsQ0FBQ3hNLFFBQXBCLENBRkQ7QUFHVDtBQUNBO0FBQ0F3QixRQUFBQSxNQUFNLG9CQUNEZ0MsQ0FBQyxDQUFDaEMsTUFERCxNQUVBZ0wsQ0FBQyxDQUFDaEwsTUFBRixJQUFZLEVBRlo7QUFMRyxPQUFYO0FBQUEsS0FEVyxFQVdYO0FBQUN4QixNQUFBQSxRQUFRLEVBQUUsRUFBWDtBQUFld0IsTUFBQUEsTUFBTSxFQUFFLEVBQXZCO0FBQTJCNkgsTUFBQUEsT0FBTyxFQUFFO0FBQUNxRCxRQUFBQSxTQUFTLEVBQUU7QUFBWjtBQUFwQyxLQVhXLENBQWI7QUFhQSxXQUFPLDJCQUFheEIsSUFBYixDQUFQO0FBQ0QsR0FoQkgsRUFpQkV5Qiw2QkFqQkYsQ0FEb0IsQ0FBdEI7QUFzQkEsU0FBTyxxQkFDTDdMLEtBREssRUFFTG9MLGFBRkssQ0FBUDtBQUlELENBL0JNO0FBaUNQOzs7Ozs7Ozs7OztBQU9PLFNBQVNWLGdCQUFULENBQTBCMUssS0FBMUIsRUFBaUNkLFFBQWpDLEVBQTJDO0FBQ2hELE1BQU00TSxhQUFhLEdBQUd4SyxNQUFNLENBQUM4SCxNQUFQLENBQWNsSyxRQUFkLEVBQXdCcUksTUFBeEIsQ0FDcEIsVUFBQzRDLElBQUQsRUFBT3BHLE9BQVA7QUFBQSx5REFDS29HLElBREwsdUNBRU0sa0NBQWlCcEcsT0FBakIsRUFBMEIvRCxLQUFLLENBQUNKLFlBQWhDLEtBQWlELEVBRnZEO0FBQUEsR0FEb0IsRUFLcEIsRUFMb0IsQ0FBdEI7QUFRQSxTQUFPO0FBQ0xJLElBQUFBLEtBQUssb0JBQ0FBLEtBREE7QUFFSHBCLE1BQUFBLE1BQU0sZ0RBQU1vQixLQUFLLENBQUNwQixNQUFaLHVDQUF1QmtOLGFBQXZCLEVBRkg7QUFHSC9NLE1BQUFBLFVBQVUsZ0RBRUwrTSxhQUFhLENBQUMzTCxHQUFkLENBQWtCLFVBQUM0TCxDQUFELEVBQUkxTCxDQUFKO0FBQUEsZUFBVUwsS0FBSyxDQUFDcEIsTUFBTixDQUFhNkIsTUFBYixHQUFzQkosQ0FBaEM7QUFBQSxPQUFsQixDQUZLLHVDQUdMTCxLQUFLLENBQUNqQixVQUhEO0FBSFAsTUFEQTtBQVVMeUwsSUFBQUEsU0FBUyxFQUFFc0I7QUFWTixHQUFQO0FBWUQ7QUFFRDs7Ozs7Ozs7QUFNTyxTQUFTbEIsa0JBQVQsQ0FBNEI1SyxLQUE1QixFQUFtQytELE9BQW5DLEVBQTRDO0FBQ2pELE1BQU00RyxhQUFhLEdBQUcsd0NBQWlCNUcsT0FBakIsQ0FBdEI7QUFFQSwyQkFDSy9ELEtBREw7QUFFRVgsSUFBQUEsaUJBQWlCLG9CQUNaVyxLQUFLLENBQUNYLGlCQURNO0FBRWZ5SSxNQUFBQSxPQUFPLG9CQUNGOUgsS0FBSyxDQUFDWCxpQkFBTixDQUF3QnlJLE9BRHRCO0FBRUxwSCxRQUFBQSxNQUFNLEVBQUU7QUFDTjtBQUNBcUgsVUFBQUEsWUFBWSxvQkFDUC9ILEtBQUssQ0FBQ1gsaUJBQU4sQ0FBd0J5SSxPQUF4QixDQUFnQ3BILE1BQWhDLENBQXVDcUgsWUFEaEMsTUFFUDRDLGFBRk87QUFGTjtBQUZIO0FBRlE7QUFGbkI7QUFnQkQ7QUFFRDs7Ozs7Ozs7O0FBT08sU0FBU3BGLHdCQUFULENBQWtDdkYsS0FBbEMsRUFBeUM4RCxNQUF6QyxFQUFpRGlCLFNBQWpELEVBQTREO0FBQ2pFLE1BQU1pSCxPQUFPLEdBQUcsT0FBT2xJLE1BQVAsS0FBa0IsUUFBbEIsR0FBNkIsQ0FBQ0EsTUFBRCxDQUE3QixHQUF3Q0EsTUFBeEQ7QUFDQSxNQUFNMEcsU0FBUyxHQUFHLEVBQWxCO0FBQ0EsTUFBTXlCLGFBQWEsR0FBRyxFQUF0QjtBQUVBak0sRUFBQUEsS0FBSyxDQUFDcEIsTUFBTixDQUFhZ0csT0FBYixDQUFxQixVQUFDM0QsUUFBRCxFQUFXWixDQUFYLEVBQWlCO0FBQ3BDLFFBQUlZLFFBQVEsQ0FBQ1AsTUFBVCxDQUFnQm9ELE1BQWhCLElBQTBCa0ksT0FBTyxDQUFDckosUUFBUixDQUFpQjFCLFFBQVEsQ0FBQ1AsTUFBVCxDQUFnQm9ELE1BQWpDLENBQTlCLEVBQXdFO0FBQ3RFO0FBQ0EsVUFBTXJDLFFBQVEsR0FDWnNELFNBQVMsSUFBSUEsU0FBUyxDQUFDbUgsV0FBdkIsR0FDSWpMLFFBREosR0FFSUEsUUFBUSxDQUFDK0MsaUJBQVQsQ0FDRWhFLEtBQUssQ0FBQ2QsUUFBTixDQUFlK0IsUUFBUSxDQUFDUCxNQUFULENBQWdCb0QsTUFBL0IsQ0FERixFQUVFaUIsU0FGRixDQUhOOztBQUZzRSxpQ0FVM0Msb0NBQ3pCdEQsUUFEeUIsRUFFekJ6QixLQUZ5QixFQUd6QkEsS0FBSyxDQUFDbkIsU0FBTixDQUFnQndCLENBQWhCLENBSHlCLENBVjJDO0FBQUEsVUFVL0R4QixTQVYrRCx3QkFVL0RBLFNBVitEO0FBQUEsVUFVcERvQixLQVZvRCx3QkFVcERBLEtBVm9EOztBQWdCdEV1SyxNQUFBQSxTQUFTLENBQUM5QyxJQUFWLENBQWV6SCxLQUFmO0FBQ0FnTSxNQUFBQSxhQUFhLENBQUN2RSxJQUFkLENBQW1CN0ksU0FBbkI7QUFDRCxLQWxCRCxNQWtCTztBQUNMMkwsTUFBQUEsU0FBUyxDQUFDOUMsSUFBVixDQUFlekcsUUFBZjtBQUNBZ0wsTUFBQUEsYUFBYSxDQUFDdkUsSUFBZCxDQUFtQjFILEtBQUssQ0FBQ25CLFNBQU4sQ0FBZ0J3QixDQUFoQixDQUFuQjtBQUNEO0FBQ0YsR0F2QkQ7O0FBeUJBLE1BQU1HLFFBQVEscUJBQ1RSLEtBRFM7QUFFWnBCLElBQUFBLE1BQU0sRUFBRTRMLFNBRkk7QUFHWjNMLElBQUFBLFNBQVMsRUFBRW9OO0FBSEMsSUFBZDs7QUFNQSxTQUFPekwsUUFBUDtBQUNEOztBQUVNLFNBQVNNLHFCQUFULENBQStCZCxLQUEvQixFQUFzQztBQUMzQztBQUNBLE1BQU1tTSxnQkFBZ0IsR0FBR25NLEtBQUssQ0FBQ3BCLE1BQU4sQ0FBYTRELE1BQWIsQ0FDdkIsVUFBQXJCLENBQUM7QUFBQSxXQUNDQSxDQUFDLENBQUNULE1BQUYsQ0FBU0MsU0FBVCxJQUNBUSxDQUFDLENBQUNULE1BQUYsQ0FBU0UsU0FEVCxJQUVBTyxDQUFDLENBQUNULE1BQUYsQ0FBU0UsU0FBVCxDQUFtQkMsT0FGbkIsSUFHQW1KLEtBQUssQ0FBQ0MsT0FBTixDQUFjOUksQ0FBQyxDQUFDaUwsZUFBaEIsQ0FKRDtBQUFBLEdBRHNCLENBQXpCOztBQVFBLE1BQUksQ0FBQ0QsZ0JBQWdCLENBQUMxTCxNQUF0QixFQUE4QjtBQUM1Qiw2QkFDS1QsS0FETDtBQUVFRixNQUFBQSxlQUFlLEVBQUV2QjtBQUZuQjtBQUlEOztBQUVELE1BQU04TixZQUFZLEdBQUdGLGdCQUFnQixDQUFDNUUsTUFBakIsQ0FDbkIsVUFBQzRDLElBQUQsRUFBT2xLLEtBQVA7QUFBQSxXQUFpQixDQUNmcU0sSUFBSSxDQUFDQyxHQUFMLENBQVNwQyxJQUFJLENBQUMsQ0FBRCxDQUFiLEVBQWtCbEssS0FBSyxDQUFDbU0sZUFBTixDQUFzQixDQUF0QixDQUFsQixDQURlLEVBRWZFLElBQUksQ0FBQ0UsR0FBTCxDQUFTckMsSUFBSSxDQUFDLENBQUQsQ0FBYixFQUFrQmxLLEtBQUssQ0FBQ21NLGVBQU4sQ0FBc0IsQ0FBdEIsQ0FBbEIsQ0FGZSxDQUFqQjtBQUFBLEdBRG1CLEVBS25CLENBQUNLLE1BQU0sQ0FBQ0MsUUFBRCxDQUFQLEVBQW1CLENBQUNBLFFBQXBCLENBTG1CLENBQXJCO0FBUUEsMkJBQ0sxTSxLQURMO0FBRUVGLElBQUFBLGVBQWUsb0JBQ1ZFLEtBQUssQ0FBQ0YsZUFESTtBQUVickIsTUFBQUEsV0FBVyxFQUFFLDRCQUFVdUIsS0FBSyxDQUFDRixlQUFOLENBQXNCckIsV0FBaEMsRUFBNkM0TixZQUE3QyxJQUNUck0sS0FBSyxDQUFDRixlQUFOLENBQXNCckIsV0FEYixHQUVUNE4sWUFBWSxDQUFDLENBQUQsQ0FKSDtBQUtiN04sTUFBQUEsTUFBTSxFQUFFNk47QUFMSztBQUZqQjtBQVVEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE5IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtjb25zb2xlIGFzIENvbnNvbGV9IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IFRhc2ssIHtkaXNhYmxlU3RhY2tDYXB0dXJpbmcsIHdpdGhUYXNrfSBmcm9tICdyZWFjdC1wYWxtL3Rhc2tzJztcbmltcG9ydCBjbG9uZURlZXAgZnJvbSAnbG9kYXNoLmNsb25lZGVlcCc7XG5cbi8vIFRhc2tzXG5pbXBvcnQge0xPQURfRklMRV9UQVNLfSBmcm9tICd0YXNrcy90YXNrcyc7XG5cbi8vIEFjdGlvbnNcbmltcG9ydCB7bG9hZEZpbGVzRXJyfSBmcm9tICdhY3Rpb25zL3Zpcy1zdGF0ZS1hY3Rpb25zJztcbmltcG9ydCB7YWRkRGF0YVRvTWFwfSBmcm9tICdhY3Rpb25zJztcblxuLy8gVXRpbHNcbmltcG9ydCB7Z2V0RGVmYXVsdEludGVyYWN0aW9uLCBmaW5kRmllbGRzVG9TaG93fSBmcm9tICd1dGlscy9pbnRlcmFjdGlvbi11dGlscyc7XG5pbXBvcnQge1xuICBnZXREZWZhdWx0RmlsdGVyLFxuICBnZXRGaWx0ZXJQcm9wcyxcbiAgZ2V0RmlsdGVyUGxvdCxcbiAgZ2V0RGVmYXVsdEZpbHRlclBsb3RUeXBlLFxuICBmaWx0ZXJEYXRhLFxuICBpc0luUmFuZ2Vcbn0gZnJvbSAndXRpbHMvZmlsdGVyLXV0aWxzJztcbmltcG9ydCB7Y3JlYXRlTmV3RGF0YUVudHJ5fSBmcm9tICd1dGlscy9kYXRhc2V0LXV0aWxzJztcblxuaW1wb3J0IHtcbiAgZmluZERlZmF1bHRMYXllcixcbiAgY2FsY3VsYXRlTGF5ZXJEYXRhXG59IGZyb20gJ3V0aWxzL2xheWVyLXV0aWxzL2xheWVyLXV0aWxzJztcblxuaW1wb3J0IHtcbiAgbWVyZ2VGaWx0ZXJzLFxuICBtZXJnZUxheWVycyxcbiAgbWVyZ2VJbnRlcmFjdGlvbnMsXG4gIG1lcmdlTGF5ZXJCbGVuZGluZyxcbiAgbWVyZ2VTcGxpdE1hcHMsXG4gIG1lcmdlQW5pbWF0aW9uQ29uZmlnXG59IGZyb20gJy4vdmlzLXN0YXRlLW1lcmdlcic7XG5cbmltcG9ydCB7XG4gIGFkZE5ld0xheWVyc1RvU3BsaXRNYXAsXG4gIHJlbW92ZUxheWVyRnJvbVNwbGl0TWFwcyxcbiAgY29tcHV0ZVNwbGl0TWFwTGF5ZXJzXG59IGZyb20gJ3V0aWxzL3NwbGl0LW1hcC11dGlscyc7XG5cbmltcG9ydCB7TGF5ZXIsIExheWVyQ2xhc3Nlc30gZnJvbSAnbGF5ZXJzJztcbmltcG9ydCB7cHJvY2Vzc0ZpbGVUb0xvYWR9IGZyb20gJy91dGlscy9maWxlLXV0aWxzJztcbmltcG9ydCB7REVGQVVMVF9URVhUX0xBQkVMfSBmcm9tICdsYXllcnMvbGF5ZXItZmFjdG9yeSc7XG5cbi8vIHJlYWN0LXBhbG1cbi8vIGRpc2FibGUgY2FwdHVyZSBleGNlcHRpb24gZm9yIHJlYWN0LXBhbG0gY2FsbCB0byB3aXRoVGFza1xuZGlzYWJsZVN0YWNrQ2FwdHVyaW5nKCk7XG5cbi8qKlxuICogVXBkYXRlcnMgZm9yIGB2aXNTdGF0ZWAgcmVkdWNlci4gQ2FuIGJlIHVzZWQgaW4geW91ciByb290IHJlZHVjZXIgdG8gZGlyZWN0bHkgbW9kaWZ5IGtlcGxlci5nbCdzIHN0YXRlLlxuICogUmVhZCBtb3JlIGFib3V0IFtVc2luZyB1cGRhdGVyc10oLi4vYWR2YW5jZWQtdXNhZ2UvdXNpbmctdXBkYXRlcnMubWQpXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQga2VwbGVyR2xSZWR1Y2VyLCB7dmlzU3RhdGVVcGRhdGVyc30gZnJvbSAna2VwbGVyLmdsL3JlZHVjZXJzJztcbiAqIC8vIFJvb3QgUmVkdWNlclxuICogY29uc3QgcmVkdWNlcnMgPSBjb21iaW5lUmVkdWNlcnMoe1xuICogIGtlcGxlckdsOiBrZXBsZXJHbFJlZHVjZXIsXG4gKiAgYXBwOiBhcHBSZWR1Y2VyXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBjb21wb3NlZFJlZHVjZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICogIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAqICAgIGNhc2UgJ0NMSUNLX0JVVFRPTic6XG4gKiAgICAgIHJldHVybiB7XG4gKiAgICAgICAgLi4uc3RhdGUsXG4gKiAgICAgICAga2VwbGVyR2w6IHtcbiAqICAgICAgICAgIC4uLnN0YXRlLmtlcGxlckdsLFxuICogICAgICAgICAgZm9vOiB7XG4gKiAgICAgICAgICAgICAuLi5zdGF0ZS5rZXBsZXJHbC5mb28sXG4gKiAgICAgICAgICAgICB2aXNTdGF0ZTogdmlzU3RhdGVVcGRhdGVycy5lbmxhcmdlRmlsdGVyVXBkYXRlcihcbiAqICAgICAgICAgICAgICAgc3RhdGUua2VwbGVyR2wuZm9vLnZpc1N0YXRlLFxuICogICAgICAgICAgICAgICB7aWR4OiAwfVxuICogICAgICAgICAgICAgKVxuICogICAgICAgICAgfVxuICogICAgICAgIH1cbiAqICAgICAgfTtcbiAqICB9XG4gKiAgcmV0dXJuIHJlZHVjZXJzKHN0YXRlLCBhY3Rpb24pO1xuICogfTtcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBjb21wb3NlZFJlZHVjZXI7XG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5jb25zdCB2aXNTdGF0ZVVwZGF0ZXJzID0gbnVsbDtcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRBbmltYXRpb25Db25maWcgPSB7XG4gIGRvbWFpbjogbnVsbCxcbiAgY3VycmVudFRpbWU6IG51bGwsXG4gIHNwZWVkOiAxXG59O1xuXG4vKipcbiAqIERlZmF1bHQgaW5pdGlhbCBgdmlzU3RhdGVgXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtBcnJheX0gbGF5ZXJzXG4gKiBAcHJvcGVydHkge0FycmF5fSBsYXllckRhdGFcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IGxheWVyVG9CZU1lcmdlZFxuICogQHByb3BlcnR5IHtBcnJheX0gbGF5ZXJPcmRlclxuICogQHByb3BlcnR5IHtBcnJheX0gZmlsdGVyc1xuICogQHByb3BlcnR5IHtBcnJheX0gZmlsdGVyVG9CZU1lcmdlZFxuICogQHByb3BlcnR5IHtBcnJheX0gZGF0YXNldHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBlZGl0aW5nRGF0YXNldFxuICogQHByb3BlcnR5IHtPYmplY3R9IGludGVyYWN0aW9uQ29uZmlnXG4gKiBAcHJvcGVydHkge09iamVjdH0gaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGF5ZXJCbGVuZGluZ1xuICogQHByb3BlcnR5IHtPYmplY3R9IGhvdmVySW5mb1xuICogQHByb3BlcnR5IHtPYmplY3R9IGNsaWNrZWRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtb3VzZVBvc1xuICogQHByb3BlcnR5IHtBcnJheX0gc3BsaXRNYXBzIC0gYSBsaXN0IG9mIG9iamVjdHMgb2YgbGF5ZXIgYXZhaWxhYmlsaXRpZXMgYW5kIHZpc2liaWxpdGllcyBmb3IgZWFjaCBtYXBcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBsYXllckNsYXNzZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhbmltYXRpb25Db25maWdcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IElOSVRJQUxfVklTX1NUQVRFID0ge1xuICAvLyBsYXllcnNcbiAgbGF5ZXJzOiBbXSxcbiAgbGF5ZXJEYXRhOiBbXSxcbiAgbGF5ZXJUb0JlTWVyZ2VkOiBbXSxcbiAgbGF5ZXJPcmRlcjogW10sXG5cbiAgLy8gZmlsdGVyc1xuICBmaWx0ZXJzOiBbXSxcbiAgZmlsdGVyVG9CZU1lcmdlZDogW10sXG5cbiAgLy8gYSBjb2xsZWN0aW9uIG9mIG11bHRpcGxlIGRhdGFzZXRcbiAgZGF0YXNldHM6IHt9LFxuICBlZGl0aW5nRGF0YXNldDogdW5kZWZpbmVkLFxuXG4gIGludGVyYWN0aW9uQ29uZmlnOiBnZXREZWZhdWx0SW50ZXJhY3Rpb24oKSxcbiAgaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkOiB1bmRlZmluZWQsXG5cbiAgbGF5ZXJCbGVuZGluZzogJ25vcm1hbCcsXG4gIGhvdmVySW5mbzogdW5kZWZpbmVkLFxuICBjbGlja2VkOiB1bmRlZmluZWQsXG4gIG1vdXNlUG9zOiB7fSxcblxuICAvLyB0aGlzIGlzIHVzZWQgd2hlbiB1c2VyIHNwbGl0IG1hcHNcbiAgc3BsaXRNYXBzOiBbXG4gICAgLy8gdGhpcyB3aWxsIGNvbnRhaW4gYSBsaXN0IG9mIG9iamVjdHMgdG9cbiAgICAvLyBkZXNjcmliZSB0aGUgc3RhdGUgb2YgbGF5ZXIgYXZhaWxhYmlsaXR5IGFuZCB2aXNpYmlsaXR5IGZvciBlYWNoIG1hcFxuICAgIC8vIFtcbiAgICAvLyAgIHtcbiAgICAvLyAgICAgIGxheWVyczoge2xheWVyX2lkOiB0cnVlIHwgZmFsc2V9XG4gICAgLy8gICB9XG4gICAgLy8gXVxuICBdLFxuICAvL1xuICAvLyBkZWZhdWx0cyBsYXllciBjbGFzc2VzXG4gIGxheWVyQ2xhc3NlczogTGF5ZXJDbGFzc2VzLFxuXG4gIC8vIGRlZmF1bHQgYW5pbWF0aW9uXG4gIC8vIHRpbWUgaW4gdW5peCB0aW1lc3RhbXAgKG1pbGxpc2Vjb25kcykgKHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgVW5peCBFcG9jaClcbiAgYW5pbWF0aW9uQ29uZmlnOiBkZWZhdWx0QW5pbWF0aW9uQ29uZmlnXG59O1xuXG5mdW5jdGlvbiB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEoc3RhdGUsIHtsYXllckRhdGEsIGxheWVyLCBpZHh9KSB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBzdGF0ZS5sYXllcnMubWFwKChseXIsIGkpID0+IChpID09PSBpZHggPyBsYXllciA6IGx5cikpLFxuICAgIGxheWVyRGF0YTogbGF5ZXJEYXRhXG4gICAgICA/IHN0YXRlLmxheWVyRGF0YS5tYXAoKGQsIGkpID0+IChpID09PSBpZHggPyBsYXllckRhdGEgOiBkKSlcbiAgICAgIDogc3RhdGUubGF5ZXJEYXRhXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVTdGF0ZU9uTGF5ZXJWaXNpYmlsaXR5Q2hhbmdlKHN0YXRlLCBsYXllcikge1xuICBsZXQgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgaWYgKHN0YXRlLnNwbGl0TWFwcy5sZW5ndGgpIHtcbiAgICBuZXdTdGF0ZSA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgc3BsaXRNYXBzOiBsYXllci5jb25maWcuaXNWaXNpYmxlXG4gICAgICAgID8gYWRkTmV3TGF5ZXJzVG9TcGxpdE1hcChzdGF0ZS5zcGxpdE1hcHMsIGxheWVyKVxuICAgICAgICA6IHJlbW92ZUxheWVyRnJvbVNwbGl0TWFwcyhzdGF0ZS5zcGxpdE1hcHMsIGxheWVyKVxuICAgIH07XG4gIH1cblxuICBpZiAobGF5ZXIuY29uZmlnLmFuaW1hdGlvbi5lbmFibGVkKSB7XG4gICAgbmV3U3RhdGUgPSB1cGRhdGVBbmltYXRpb25Eb21haW4oc3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ld1N0YXRlO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBsYXllciBiYXNlIGNvbmZpZzogZGF0YUlkLCBsYWJlbCwgY29sdW1uLCBpc1Zpc2libGVcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24ub2xkTGF5ZXIgbGF5ZXIgdG8gYmUgdXBkYXRlZFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5uZXdDb25maWcgbmV3IGNvbmZpZ1xuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXllckNvbmZpZ0NoYW5nZVVwZGF0ZXIoc3RhdGUsIGFjdGlvbikge1xuICBjb25zdCB7b2xkTGF5ZXJ9ID0gYWN0aW9uO1xuICBjb25zdCBpZHggPSBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gb2xkTGF5ZXIuaWQpO1xuICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKGFjdGlvbi5uZXdDb25maWcpO1xuICBsZXQgbmV3TGF5ZXIgPSBvbGRMYXllci51cGRhdGVMYXllckNvbmZpZyhhY3Rpb24ubmV3Q29uZmlnKTtcblxuICBsZXQgbGF5ZXJEYXRhO1xuXG4gIC8vIGxldCBuZXdMYXllcjtcbiAgaWYgKG5ld0xheWVyLnNob3VsZENhbGN1bGF0ZUxheWVyRGF0YShwcm9wcykpIHtcbiAgICBjb25zdCBvbGRMYXllckRhdGEgPSBzdGF0ZS5sYXllckRhdGFbaWR4XTtcbiAgICBjb25zdCB1cGRhdGVMYXllckRhdGFSZXN1bHQgPSBjYWxjdWxhdGVMYXllckRhdGEoXG4gICAgICBuZXdMYXllcixcbiAgICAgIHN0YXRlLFxuICAgICAgb2xkTGF5ZXJEYXRhLFxuICAgICAge1xuICAgICAgICBzYW1lRGF0YTogdHJ1ZVxuICAgICAgfVxuICAgICk7XG5cbiAgICBsYXllckRhdGEgPSB1cGRhdGVMYXllckRhdGFSZXN1bHQubGF5ZXJEYXRhO1xuICAgIG5ld0xheWVyID0gdXBkYXRlTGF5ZXJEYXRhUmVzdWx0LmxheWVyO1xuICB9XG5cbiAgbGV0IG5ld1N0YXRlID0gc3RhdGU7XG4gIGlmICgnaXNWaXNpYmxlJyBpbiBhY3Rpb24ubmV3Q29uZmlnKSB7XG4gICAgbmV3U3RhdGUgPSB1cGRhdGVTdGF0ZU9uTGF5ZXJWaXNpYmlsaXR5Q2hhbmdlKHN0YXRlLCBuZXdMYXllcik7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlU3RhdGVXaXRoTGF5ZXJBbmREYXRhKG5ld1N0YXRlLCB7XG4gICAgbGF5ZXI6IG5ld0xheWVyLFxuICAgIGxheWVyRGF0YSxcbiAgICBpZHhcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZE9yUmVtb3ZlVGV4dExhYmVscyhuZXdGaWVsZHMsIHRleHRMYWJlbCkge1xuICBsZXQgbmV3VGV4dExhYmVsID0gdGV4dExhYmVsLnNsaWNlKCk7XG5cbiAgY29uc3QgY3VycmVudEZpZWxkcyA9IHRleHRMYWJlbFxuICAgIC5tYXAodGwgPT4gdGwuZmllbGQgJiYgdGwuZmllbGQubmFtZSlcbiAgICAuZmlsdGVyKGQgPT4gZCk7XG5cbiAgY29uc3QgYWRkRmllbGRzID0gbmV3RmllbGRzLmZpbHRlcihmID0+ICFjdXJyZW50RmllbGRzLmluY2x1ZGVzKGYubmFtZSkpO1xuICBjb25zdCBkZWxldGVGaWVsZHMgPSBjdXJyZW50RmllbGRzLmZpbHRlcihcbiAgICBmID0+ICFuZXdGaWVsZHMuZmluZChmZCA9PiBmZC5uYW1lID09PSBmKVxuICApO1xuXG4gIC8vIGRlbGV0ZVxuICBuZXdUZXh0TGFiZWwgPSBuZXdUZXh0TGFiZWwuZmlsdGVyKFxuICAgIHRsID0+IHRsLmZpZWxkICYmICFkZWxldGVGaWVsZHMuaW5jbHVkZXModGwuZmllbGQubmFtZSlcbiAgKTtcbiAgbmV3VGV4dExhYmVsID0gIW5ld1RleHRMYWJlbC5sZW5ndGggPyBbREVGQVVMVF9URVhUX0xBQkVMXSA6IG5ld1RleHRMYWJlbDtcblxuICAvLyBhZGRcbiAgbmV3VGV4dExhYmVsID0gW1xuICAgIC4uLm5ld1RleHRMYWJlbC5maWx0ZXIodGwgPT4gdGwuZmllbGQpLFxuICAgIC4uLmFkZEZpZWxkcy5tYXAoYWYgPT4gKHtcbiAgICAgIC4uLkRFRkFVTFRfVEVYVF9MQUJFTCxcbiAgICAgIGZpZWxkOiBhZlxuICAgIH0pKVxuICBdO1xuXG4gIHJldHVybiBuZXdUZXh0TGFiZWw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRleHRMYWJlbFByb3BBbmRWYWx1ZShpZHgsIHByb3AsIHZhbHVlLCB0ZXh0TGFiZWwpIHtcbiAgaWYgKCF0ZXh0TGFiZWxbaWR4XS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgIHJldHVybiB0ZXh0TGFiZWw7XG4gIH1cblxuICBsZXQgbmV3VGV4dExhYmVsID0gdGV4dExhYmVsLnNsaWNlKCk7XG5cbiAgaWYgKHByb3AgJiYgKHZhbHVlIHx8IHRleHRMYWJlbC5sZW5ndGggPT09IDEpKSB7XG4gICAgbmV3VGV4dExhYmVsID0gdGV4dExhYmVsLm1hcCgodGwsIGkpID0+XG4gICAgICBpID09PSBpZHggPyB7Li4udGwsIFtwcm9wXTogdmFsdWV9IDogdGxcbiAgICApO1xuICB9IGVsc2UgaWYgKHByb3AgPT09ICdmaWVsZCcgJiYgdmFsdWUgPT09IG51bGwgJiYgdGV4dExhYmVsLmxlbmd0aCA+IDEpIHtcbiAgICAvLyByZW1vdmUgbGFiZWwgd2hlbiBmaWVsZCB2YWx1ZSBpcyBzZXQgdG8gbnVsbFxuICAgIG5ld1RleHRMYWJlbC5zcGxpY2UoaWR4LCAxKTtcbiAgfVxuXG4gIHJldHVybiBuZXdUZXh0TGFiZWw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXllclRleHRMYWJlbENoYW5nZVVwZGF0ZXIoc3RhdGUsIGFjdGlvbikge1xuICBjb25zdCB7b2xkTGF5ZXIsIGlkeCwgcHJvcCwgdmFsdWV9ID0gYWN0aW9uO1xuICBjb25zdCB7dGV4dExhYmVsfSA9IG9sZExheWVyLmNvbmZpZztcblxuICBsZXQgbmV3VGV4dExhYmVsID0gdGV4dExhYmVsLnNsaWNlKCk7XG4gIGlmICghdGV4dExhYmVsW2lkeF0gJiYgaWR4ID09PSB0ZXh0TGFiZWwubGVuZ3RoKSB7XG4gICAgLy8gaWYgaWR4IGlzIHNldCB0byBsZW5ndGgsIGFkZCBlbXB0eSB0ZXh0IGxhYmVsXG4gICAgbmV3VGV4dExhYmVsID0gWy4uLnRleHRMYWJlbCwgREVGQVVMVF9URVhUX0xBQkVMXTtcbiAgfVxuXG4gIGlmIChpZHggPT09ICdhbGwnICYmIHByb3AgPT09ICdmaWVsZHMnKSB7XG4gICAgbmV3VGV4dExhYmVsID0gYWRkT3JSZW1vdmVUZXh0TGFiZWxzKHZhbHVlLCB0ZXh0TGFiZWwpO1xuICB9IGVsc2Uge1xuICAgIG5ld1RleHRMYWJlbCA9IHVwZGF0ZVRleHRMYWJlbFByb3BBbmRWYWx1ZShpZHgsIHByb3AsIHZhbHVlLCBuZXdUZXh0TGFiZWwpO1xuICB9XG5cbiAgLy8gdXBkYXRlIHRleHQgbGFiZWwgcHJvcCBhbmQgdmFsdWVcbiAgcmV0dXJuIGxheWVyQ29uZmlnQ2hhbmdlVXBkYXRlcihzdGF0ZSwge1xuICAgIG9sZExheWVyLFxuICAgIG5ld0NvbmZpZzoge3RleHRMYWJlbDogbmV3VGV4dExhYmVsfVxuICB9KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgbGF5ZXIgdHlwZS4gUHJldmlld3MgbGF5ZXIgY29uZmlnIHdpbGwgYmUgY29waWVkIGlmIGFwcGxpY2FibGUuXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLm9sZExheWVyIGxheWVyIHRvIGJlIHVwZGF0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24ubmV3VHlwZSBuZXcgdHlwZVxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXllclR5cGVDaGFuZ2VVcGRhdGVyKHN0YXRlLCBhY3Rpb24pIHtcbiAgY29uc3Qge29sZExheWVyLCBuZXdUeXBlfSA9IGFjdGlvbjtcbiAgaWYgKCFvbGRMYXllcikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCBvbGRJZCA9IG9sZExheWVyLmlkO1xuICBjb25zdCBpZHggPSBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gb2xkSWQpO1xuXG4gIGlmICghc3RhdGUubGF5ZXJDbGFzc2VzW25ld1R5cGVdKSB7XG4gICAgQ29uc29sZS5lcnJvcihgJHtuZXdUeXBlfSBpcyBub3QgYSB2YWxpZCBsYXllciB0eXBlYCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgLy8gZ2V0IGEgbWludCBsYXllciwgd2l0aCBuZXcgaWQgYW5kIHR5cGVcbiAgLy8gYmVjYXVzZSBkZWNrLmdsIHVzZXMgaWQgdG8gbWF0Y2ggYmV0d2VlbiBuZXcgYW5kIG9sZCBsYXllci5cbiAgLy8gSWYgdHlwZSBoYXMgY2hhbmdlZCBidXQgaWQgaXMgdGhlIHNhbWUsIGl0IHdpbGwgYnJlYWtcbiAgY29uc3QgbmV3TGF5ZXIgPSBuZXcgc3RhdGUubGF5ZXJDbGFzc2VzW25ld1R5cGVdKCk7XG5cbiAgbmV3TGF5ZXIuYXNzaWduQ29uZmlnVG9MYXllcihvbGRMYXllci5jb25maWcsIG9sZExheWVyLnZpc0NvbmZpZ1NldHRpbmdzKTtcblxuICBpZiAobmV3TGF5ZXIuY29uZmlnLmRhdGFJZCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSBzdGF0ZS5kYXRhc2V0c1tuZXdMYXllci5jb25maWcuZGF0YUlkXTtcbiAgICBuZXdMYXllci51cGRhdGVMYXllckRvbWFpbihkYXRhc2V0KTtcbiAgfVxuXG4gIGNvbnN0IHtsYXllckRhdGEsIGxheWVyfSA9IGNhbGN1bGF0ZUxheWVyRGF0YShuZXdMYXllciwgc3RhdGUpO1xuICBsZXQgbmV3U3RhdGUgPSB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEoc3RhdGUsIHtsYXllckRhdGEsIGxheWVyLCBpZHh9KTtcblxuICBpZiAobGF5ZXIuY29uZmlnLmFuaW1hdGlvbi5lbmFibGVkIHx8IG9sZExheWVyLmNvbmZpZy5hbmltYXRpb24uZW5hYmxlZCkge1xuICAgIG5ld1N0YXRlID0gdXBkYXRlQW5pbWF0aW9uRG9tYWluKG5ld1N0YXRlKTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBzcGxpdE1hcCBsYXllciBpZFxuICBpZiAoc3RhdGUuc3BsaXRNYXBzLmxlbmd0aCkge1xuICAgIG5ld1N0YXRlID0ge1xuICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICBzcGxpdE1hcHM6IG5ld1N0YXRlLnNwbGl0TWFwcy5tYXAoc2V0dGluZ3MgPT4ge1xuICAgICAgICBjb25zdCB7W29sZElkXTogb2xkTGF5ZXJNYXAsIC4uLm90aGVyTGF5ZXJzfSA9IHNldHRpbmdzLmxheWVycztcbiAgICAgICAgcmV0dXJuIG9sZElkIGluIHNldHRpbmdzLmxheWVyc1xuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAuLi5zZXR0aW5ncyxcbiAgICAgICAgICAgICAgbGF5ZXJzOiB7XG4gICAgICAgICAgICAgICAgLi4ub3RoZXJMYXllcnMsXG4gICAgICAgICAgICAgICAgW2xheWVyLmlkXTogb2xkTGF5ZXJNYXBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogc2V0dGluZ3M7XG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbi8qKlxuICogVXBkYXRlIGxheWVyIHZpc3VhbCBjaGFubmVsXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLm9sZExheWVyIGxheWVyIHRvIGJlIHVwZGF0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24ubmV3Q29uZmlnIG5ldyB2aXN1YWwgY2hhbm5lbCBjb25maWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24uY2hhbm5lbCBjaGFubmVsIHRvIGJlIHVwZGF0ZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gbGF5ZXJWaXN1YWxDaGFubmVsQ2hhbmdlVXBkYXRlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIGNvbnN0IHtvbGRMYXllciwgbmV3Q29uZmlnLCBjaGFubmVsfSA9IGFjdGlvbjtcbiAgY29uc3QgZGF0YXNldCA9IHN0YXRlLmRhdGFzZXRzW29sZExheWVyLmNvbmZpZy5kYXRhSWRdO1xuXG4gIGNvbnN0IGlkeCA9IHN0YXRlLmxheWVycy5maW5kSW5kZXgobCA9PiBsLmlkID09PSBvbGRMYXllci5pZCk7XG4gIGNvbnN0IG5ld0xheWVyID0gb2xkTGF5ZXIudXBkYXRlTGF5ZXJDb25maWcobmV3Q29uZmlnKTtcblxuICBuZXdMYXllci51cGRhdGVMYXllclZpc3VhbENoYW5uZWwoZGF0YXNldCwgY2hhbm5lbCk7XG5cbiAgY29uc3Qgb2xkTGF5ZXJEYXRhID0gc3RhdGUubGF5ZXJEYXRhW2lkeF07XG4gIGNvbnN0IHtsYXllckRhdGEsIGxheWVyfSA9IGNhbGN1bGF0ZUxheWVyRGF0YShuZXdMYXllciwgc3RhdGUsIG9sZExheWVyRGF0YSwge1xuICAgIHNhbWVEYXRhOiB0cnVlXG4gIH0pO1xuXG4gIHJldHVybiB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEoc3RhdGUsIHtsYXllckRhdGEsIGxheWVyLCBpZHh9KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgbGF5ZXIgYHZpc0NvbmZpZ2BcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24ub2xkTGF5ZXIgbGF5ZXIgdG8gYmUgdXBkYXRlZFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5uZXdWaXNDb25maWcgbmV3IHZpc0NvbmZpZyBhcyBhIGtleSB2YWx1ZSBtYXA6IGUuZy4gYHtvcGFjaXR5OiAwLjh9YFxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXllclZpc0NvbmZpZ0NoYW5nZVVwZGF0ZXIoc3RhdGUsIGFjdGlvbikge1xuICBjb25zdCB7b2xkTGF5ZXJ9ID0gYWN0aW9uO1xuICBjb25zdCBpZHggPSBzdGF0ZS5sYXllcnMuZmluZEluZGV4KGwgPT4gbC5pZCA9PT0gb2xkTGF5ZXIuaWQpO1xuICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKGFjdGlvbi5uZXdWaXNDb25maWcpO1xuXG4gIGNvbnN0IG5ld1Zpc0NvbmZpZyA9IHtcbiAgICAuLi5vbGRMYXllci5jb25maWcudmlzQ29uZmlnLFxuICAgIC4uLmFjdGlvbi5uZXdWaXNDb25maWdcbiAgfTtcblxuICBjb25zdCBuZXdMYXllciA9IG9sZExheWVyLnVwZGF0ZUxheWVyQ29uZmlnKHt2aXNDb25maWc6IG5ld1Zpc0NvbmZpZ30pO1xuXG4gIGlmIChuZXdMYXllci5zaG91bGRDYWxjdWxhdGVMYXllckRhdGEocHJvcHMpKSB7XG4gICAgY29uc3Qgb2xkTGF5ZXJEYXRhID0gc3RhdGUubGF5ZXJEYXRhW2lkeF07XG4gICAgY29uc3Qge2xheWVyRGF0YSwgbGF5ZXJ9ID0gY2FsY3VsYXRlTGF5ZXJEYXRhKFxuICAgICAgbmV3TGF5ZXIsXG4gICAgICBzdGF0ZSxcbiAgICAgIG9sZExheWVyRGF0YSxcbiAgICAgIHtcbiAgICAgICAgc2FtZURhdGE6IHRydWVcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEoc3RhdGUsIHtsYXllckRhdGEsIGxheWVyLCBpZHh9KTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVTdGF0ZVdpdGhMYXllckFuZERhdGEoc3RhdGUsIHtsYXllcjogbmV3TGF5ZXIsIGlkeH0pO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbi8qKlxuICogVXBkYXRlIGBpbnRlcmFjdGlvbkNvbmZpZ2BcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24uY29uZmlnIG5ldyBjb25maWcgYXMga2V5IHZhbHVlIG1hcDogYHt0b29sdGlwOiB7ZW5hYmxlZDogdHJ1ZX19YFxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcmFjdGlvbkNvbmZpZ0NoYW5nZVVwZGF0ZXIoc3RhdGUsIGFjdGlvbikge1xuICBjb25zdCB7Y29uZmlnfSA9IGFjdGlvbjtcblxuICBjb25zdCBpbnRlcmFjdGlvbkNvbmZpZyA9IHtcbiAgICAuLi5zdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZyxcbiAgICAuLi57W2NvbmZpZy5pZF06IGNvbmZpZ31cbiAgfTtcblxuICAvLyBEb24ndCBlbmFibGUgdG9vbHRpcCBhbmQgYnJ1c2ggYXQgdGhlIHNhbWUgdGltZVxuICAvLyBidXQgY29vcmRpbmF0ZXMgY2FuIGJlIHNob3duIGF0IGFsbCB0aW1lXG4gIGNvbnN0IGNvbnRyYWRpY3QgPSBbJ2JydXNoJywgJ3Rvb2x0aXAnXTtcblxuICBpZiAoXG4gICAgY29udHJhZGljdC5pbmNsdWRlcyhjb25maWcuaWQpICYmXG4gICAgY29uZmlnLmVuYWJsZWQgJiZcbiAgICAhc3RhdGUuaW50ZXJhY3Rpb25Db25maWdbY29uZmlnLmlkXS5lbmFibGVkXG4gICkge1xuICAgIC8vIG9ubHkgZW5hYmxlIG9uZSBpbnRlcmFjdGlvbiBhdCBhIHRpbWVcbiAgICBjb250cmFkaWN0LmZvckVhY2goayA9PiB7XG4gICAgICBpZiAoayAhPT0gY29uZmlnLmlkKSB7XG4gICAgICAgIGludGVyYWN0aW9uQ29uZmlnW2tdID0gey4uLmludGVyYWN0aW9uQ29uZmlnW2tdLCBlbmFibGVkOiBmYWxzZX07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGludGVyYWN0aW9uQ29uZmlnXG4gIH07XG59XG5cbi8qKlxuICogVXBkYXRlIGZpbHRlciBwcm9wZXJ0eVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIGFjdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGFjdGlvbi5pZHggYGlkeGAgb2YgZmlsdGVyIHRvIGJlIHVwZGF0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24ucHJvcCBgcHJvcGAgb2YgZmlsdGVyLCBlLGcsIGBkYXRhSWRgLCBgbmFtZWAsIGB2YWx1ZWBcbiAqIEBwYXJhbSB7Kn0gYWN0aW9uLnZhbHVlIG5ldyB2YWx1ZVxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRGaWx0ZXJVcGRhdGVyKHN0YXRlLCBhY3Rpb24pIHtcbiAgY29uc3Qge2lkeCwgcHJvcCwgdmFsdWV9ID0gYWN0aW9uO1xuICBsZXQgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgbGV0IG5ld0ZpbHRlciA9IHtcbiAgICAuLi5zdGF0ZS5maWx0ZXJzW2lkeF0sXG4gICAgW3Byb3BdOiB2YWx1ZVxuICB9O1xuXG4gIGNvbnN0IHtkYXRhSWR9ID0gbmV3RmlsdGVyO1xuICBpZiAoIWRhdGFJZCkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCB7ZmllbGRzLCBhbGxEYXRhfSA9IHN0YXRlLmRhdGFzZXRzW2RhdGFJZF07XG5cbiAgc3dpdGNoIChwcm9wKSB7XG4gICAgY2FzZSAnZGF0YUlkJzpcbiAgICAgIC8vIGlmIHRyeWluZyB0byB1cGRhdGUgZmlsdGVyIGRhdGFJZC4gY3JlYXRlIGFuIGVtcHR5IG5ldyBmaWx0ZXJcbiAgICAgIG5ld0ZpbHRlciA9IGdldERlZmF1bHRGaWx0ZXIoZGF0YUlkKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbmFtZSc6XG4gICAgICAvLyBmaW5kIHRoZSBmaWVsZFxuICAgICAgY29uc3QgZmllbGRJZHggPSBmaWVsZHMuZmluZEluZGV4KGYgPT4gZi5uYW1lID09PSB2YWx1ZSk7XG4gICAgICBsZXQgZmllbGQgPSBmaWVsZHNbZmllbGRJZHhdO1xuXG4gICAgICBpZiAoIWZpZWxkLmZpbHRlclByb3ApIHtcbiAgICAgICAgLy8gZ2V0IGZpbHRlciBkb21haW4gZnJvbSBmaWVsZFxuICAgICAgICAvLyBzYXZlIGZpbHRlclByb3BzOiB7ZG9tYWluLCBzdGVwcywgdmFsdWV9IHRvIGZpZWxkLCBhdm9pZCByZWNhbGN1bGF0ZVxuICAgICAgICBmaWVsZCA9IHtcbiAgICAgICAgICAuLi5maWVsZCxcbiAgICAgICAgICBmaWx0ZXJQcm9wOiBnZXRGaWx0ZXJQcm9wcyhhbGxEYXRhLCBmaWVsZClcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbmV3RmlsdGVyID0ge1xuICAgICAgICAuLi5uZXdGaWx0ZXIsXG4gICAgICAgIC4uLmZpZWxkLmZpbHRlclByb3AsXG4gICAgICAgIG5hbWU6IGZpZWxkLm5hbWUsXG4gICAgICAgIC8vIGNhbid0IGVkaXQgZGF0YUlkIG9uY2UgbmFtZSBpcyBzZWxlY3RlZFxuICAgICAgICBmcmVlemU6IHRydWUsXG4gICAgICAgIGZpZWxkSWR4XG4gICAgICB9O1xuICAgICAgY29uc3QgZW5sYXJnZWRGaWx0ZXJJZHggPSBzdGF0ZS5maWx0ZXJzLmZpbmRJbmRleChmID0+IGYuZW5sYXJnZWQpO1xuICAgICAgaWYgKGVubGFyZ2VkRmlsdGVySWR4ID4gLTEgJiYgZW5sYXJnZWRGaWx0ZXJJZHggIT09IGlkeCkge1xuICAgICAgICAvLyB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgZW5sYXJnZWQgZmlsdGVyXG4gICAgICAgIG5ld0ZpbHRlci5lbmxhcmdlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBuZXdTdGF0ZSA9IHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGRhdGFzZXRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZGF0YXNldHMsXG4gICAgICAgICAgW2RhdGFJZF06IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLmRhdGFzZXRzW2RhdGFJZF0sXG4gICAgICAgICAgICBmaWVsZHM6IGZpZWxkcy5tYXAoKGQsIGkpID0+IChpID09PSBmaWVsZElkeCA/IGZpZWxkIDogZCkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndmFsdWUnOlxuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIHNhdmUgbmV3IGZpbHRlcnMgdG8gbmV3U3RhdGVcbiAgbmV3U3RhdGUgPSB7XG4gICAgLi4ubmV3U3RhdGUsXG4gICAgZmlsdGVyczogc3RhdGUuZmlsdGVycy5tYXAoKGYsIGkpID0+IChpID09PSBpZHggPyBuZXdGaWx0ZXIgOiBmKSlcbiAgfTtcblxuICAvLyBmaWx0ZXIgZGF0YVxuICBuZXdTdGF0ZSA9IHtcbiAgICAuLi5uZXdTdGF0ZSxcbiAgICBkYXRhc2V0czoge1xuICAgICAgLi4ubmV3U3RhdGUuZGF0YXNldHMsXG4gICAgICBbZGF0YUlkXToge1xuICAgICAgICAuLi5uZXdTdGF0ZS5kYXRhc2V0c1tkYXRhSWRdLFxuICAgICAgICAuLi5maWx0ZXJEYXRhKGFsbERhdGEsIGRhdGFJZCwgbmV3U3RhdGUuZmlsdGVycylcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgbmV3U3RhdGUgPSB1cGRhdGVBbGxMYXllckRvbWFpbkRhdGEobmV3U3RhdGUsIGRhdGFJZCwgbmV3RmlsdGVyKTtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbi8qKlxuICogU2V0IHRoZSBwcm9wZXJ0eSBvZiBhIGZpbHRlciBwbG90XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYWN0aW9uLmlkeFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5uZXdQcm9wIGtleSB2YWx1ZSBtYXBwaW5nIG9mIG5ldyBwcm9wIGB7eUF4aXM6ICdoaXN0b2dyYW0nfWBcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3Qgc2V0RmlsdGVyUGxvdFVwZGF0ZXIgPSAoc3RhdGUsIHtpZHgsIG5ld1Byb3B9KSA9PiB7XG4gIGxldCBuZXdGaWx0ZXIgPSB7Li4uc3RhdGUuZmlsdGVyc1tpZHhdLCAuLi5uZXdQcm9wfTtcbiAgY29uc3QgcHJvcCA9IE9iamVjdC5rZXlzKG5ld1Byb3ApWzBdO1xuICBpZiAocHJvcCA9PT0gJ3lBeGlzJykge1xuICAgIGNvbnN0IHBsb3RUeXBlID0gZ2V0RGVmYXVsdEZpbHRlclBsb3RUeXBlKG5ld0ZpbHRlcik7XG5cbiAgICBpZiAocGxvdFR5cGUpIHtcbiAgICAgIG5ld0ZpbHRlciA9IHtcbiAgICAgICAgLi4ubmV3RmlsdGVyLFxuICAgICAgICAuLi5nZXRGaWx0ZXJQbG90KFxuICAgICAgICAgIHsuLi5uZXdGaWx0ZXIsIHBsb3RUeXBlfSxcbiAgICAgICAgICBzdGF0ZS5kYXRhc2V0c1tuZXdGaWx0ZXIuZGF0YUlkXS5hbGxEYXRhXG4gICAgICAgICksXG4gICAgICAgIHBsb3RUeXBlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZmlsdGVyczogc3RhdGUuZmlsdGVycy5tYXAoKGYsIGkpID0+IChpID09PSBpZHggPyBuZXdGaWx0ZXIgOiBmKSlcbiAgfTtcbn07XG5cbi8qKlxuICogQWRkIGEgbmV3IGZpbHRlclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbi5kYXRhSWQgZGF0YXNldCBgaWRgIHRoaXMgbmV3IGZpbHRlciBpcyBhc3NvY2lhdGVkIHdpdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgYWRkRmlsdGVyVXBkYXRlciA9IChzdGF0ZSwgYWN0aW9uKSA9PlxuICAhYWN0aW9uLmRhdGFJZFxuICAgID8gc3RhdGVcbiAgICA6IHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGZpbHRlcnM6IFsuLi5zdGF0ZS5maWx0ZXJzLCBnZXREZWZhdWx0RmlsdGVyKGFjdGlvbi5kYXRhSWQpXVxuICAgICAgfTtcblxuLyoqXG4gKiBTZXQgbGF5ZXIgY29sb3IgcGFsZXR0ZSB1aSBzdGF0ZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5wcm9wXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLm5ld0NvbmZpZ1xuICovXG5leHBvcnQgY29uc3QgbGF5ZXJDb2xvclVJQ2hhbmdlVXBkYXRlciA9IChzdGF0ZSwge29sZExheWVyLCBwcm9wLCBuZXdDb25maWd9KSA9PiB7XG4gIGNvbnN0IG5ld0xheWVyID0gb2xkTGF5ZXIudXBkYXRlTGF5ZXJDb2xvclVJKHByb3AsIG5ld0NvbmZpZyk7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBzdGF0ZS5sYXllcnMubWFwKGwgPT4gbC5pZCA9PT0gb2xkTGF5ZXIuaWQgPyBuZXdMYXllciA6IGwpXG4gIH07XG59O1xuXG4vKipcbiAqIFN0YXJ0IGFuZCBlbmQgZmlsdGVyIGFuaW1hdGlvblxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIGFjdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGFjdGlvbi5pZHggaWR4IG9mIGZpbHRlclxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVGaWx0ZXJBbmltYXRpb25VcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+ICh7XG4gIC4uLnN0YXRlLFxuICBmaWx0ZXJzOiBzdGF0ZS5maWx0ZXJzLm1hcCgoZiwgaSkgPT5cbiAgICBpID09PSBhY3Rpb24uaWR4ID8gey4uLmYsIGlzQW5pbWF0aW5nOiAhZi5pc0FuaW1hdGluZ30gOiBmXG4gIClcbn0pO1xuXG4vKipcbiAqIENoYW5nZSBmaWx0ZXIgYW5pbWF0aW9uIHNwZWVkXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYWN0aW9uLmlkeCAgYGlkeGAgb2YgZmlsdGVyXG4gKiBAcGFyYW0ge051bWJlcn0gYWN0aW9uLnNwZWVkIGBzcGVlZGAgdG8gY2hhbmdlIGl0IHRvLiBgc3BlZWRgIGlzIGEgbXVsdGlwbGllclxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVGaWx0ZXJBbmltYXRpb25TcGVlZFVwZGF0ZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGZpbHRlcnM6IHN0YXRlLmZpbHRlcnMubWFwKChmLCBpKSA9PlxuICAgIGkgPT09IGFjdGlvbi5pZHggPyB7Li4uZiwgc3BlZWQ6IGFjdGlvbi5zcGVlZH0gOiBmXG4gIClcbn0pO1xuXG4vKipcbiAqIFJlc2V0IGFuaW1hdGlvbiBjb25maWcgY3VycmVudCB0aW1lIHRvIGEgc3BlY2lmaWVkIHZhbHVlXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYWN0aW9uLnZhbHVlIHRoZSB2YWx1ZSBjdXJyZW50IHRpbWUgd2lsbCBiZSBzZXQgdG9cbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICpcbiAqL1xuXG5leHBvcnQgY29uc3QgdXBkYXRlQW5pbWF0aW9uVGltZVVwZGF0ZXIgPSAoc3RhdGUsIHt2YWx1ZX0pID0+ICh7XG4gIC4uLnN0YXRlLFxuICBhbmltYXRpb25Db25maWc6IHtcbiAgICAuLi5zdGF0ZS5hbmltYXRpb25Db25maWcsXG4gICAgY3VycmVudFRpbWU6IHZhbHVlXG4gIH1cbn0pO1xuXG4vKipcbiAqIFVwZGF0ZSBhbmltYXRpb24gc3BlZWQgd2l0aCB0aGUgdmVydGljYWwgc3BlZWQgc2xpZGVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYWN0aW9uLnNwZWVkIHRoZSB1cGRhdGVkIHNwZWVkIG9mIHRoZSBhbmltYXRpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICpcbiAqL1xuXG5leHBvcnQgY29uc3QgdXBkYXRlTGF5ZXJBbmltYXRpb25TcGVlZFVwZGF0ZXIgPSAoc3RhdGUsIHtzcGVlZH0pID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBhbmltYXRpb25Db25maWc6IHtcbiAgICAgIC4uLnN0YXRlLmFuaW1hdGlvbkNvbmZpZyxcbiAgICAgIHNwZWVkXG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBTaG93IGxhcmdlciB0aW1lIGZpbHRlciBhdCBib3R0b20gZm9yIHRpbWUgcGxheWJhY2sgKGFwcGx5IHRvIHRpbWUgZmlsdGVyIG9ubHkpXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYWN0aW9uLmlkeCBpbmRleCBvZiBmaWx0ZXIgdG8gZW5sYXJnZVxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBlbmxhcmdlRmlsdGVyVXBkYXRlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gIGNvbnN0IGlzRW5sYXJnZWQgPSBzdGF0ZS5maWx0ZXJzW2FjdGlvbi5pZHhdLmVubGFyZ2VkO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZmlsdGVyczogc3RhdGUuZmlsdGVycy5tYXAoKGYsIGkpID0+IHtcbiAgICAgIGYuZW5sYXJnZWQgPSAhaXNFbmxhcmdlZCAmJiBpID09PSBhY3Rpb24uaWR4O1xuICAgICAgcmV0dXJuIGY7XG4gICAgfSlcbiAgfTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgZmlsdGVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYWN0aW9uLmlkeCBpbmRleCBvZiBmaWx0ZXIgdG8gYiBlIHJlbW92ZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRmlsdGVyVXBkYXRlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gIGNvbnN0IHtpZHh9ID0gYWN0aW9uO1xuICBjb25zdCB7ZGF0YUlkfSA9IHN0YXRlLmZpbHRlcnNbaWR4XTtcblxuICBjb25zdCBuZXdGaWx0ZXJzID0gW1xuICAgIC4uLnN0YXRlLmZpbHRlcnMuc2xpY2UoMCwgaWR4KSxcbiAgICAuLi5zdGF0ZS5maWx0ZXJzLnNsaWNlKGlkeCArIDEsIHN0YXRlLmZpbHRlcnMubGVuZ3RoKVxuICBdO1xuXG4gIGNvbnN0IG5ld1N0YXRlID0ge1xuICAgIC4uLnN0YXRlLFxuICAgIGRhdGFzZXRzOiB7XG4gICAgICAuLi5zdGF0ZS5kYXRhc2V0cyxcbiAgICAgIFtkYXRhSWRdOiB7XG4gICAgICAgIC4uLnN0YXRlLmRhdGFzZXRzW2RhdGFJZF0sXG4gICAgICAgIC4uLmZpbHRlckRhdGEoc3RhdGUuZGF0YXNldHNbZGF0YUlkXS5hbGxEYXRhLCBkYXRhSWQsIG5ld0ZpbHRlcnMpXG4gICAgICB9XG4gICAgfSxcbiAgICBmaWx0ZXJzOiBuZXdGaWx0ZXJzXG4gIH07XG5cbiAgcmV0dXJuIHVwZGF0ZUFsbExheWVyRG9tYWluRGF0YShuZXdTdGF0ZSwgZGF0YUlkKTtcbn07XG5cbi8qKlxuICogQWRkIGEgbmV3IGxheWVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLnByb3BzIC0gbmV3IGxheWVyIHByb3BzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZExheWVyVXBkYXRlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gIGNvbnN0IGRlZmF1bHREYXRhc2V0ID0gT2JqZWN0LmtleXMoc3RhdGUuZGF0YXNldHMpWzBdO1xuICBjb25zdCBuZXdMYXllciA9IG5ldyBMYXllcih7XG4gICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgIGlzQ29uZmlnQWN0aXZlOiB0cnVlLFxuICAgIGRhdGFJZDogZGVmYXVsdERhdGFzZXQsXG4gICAgLi4uYWN0aW9uLnByb3BzXG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgbGF5ZXJzOiBbLi4uc3RhdGUubGF5ZXJzLCBuZXdMYXllcl0sXG4gICAgbGF5ZXJEYXRhOiBbLi4uc3RhdGUubGF5ZXJEYXRhLCB7fV0sXG4gICAgbGF5ZXJPcmRlcjogWy4uLnN0YXRlLmxheWVyT3JkZXIsIHN0YXRlLmxheWVyT3JkZXIubGVuZ3RoXSxcbiAgICBzcGxpdE1hcHM6IGFkZE5ld0xheWVyc1RvU3BsaXRNYXAoc3RhdGUuc3BsaXRNYXBzLCBuZXdMYXllcilcbiAgfTtcbn07XG5cbi8qKlxuICogcmVtb3ZlIGxheWVyXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYWN0aW9uLmlkeCBpbmRleCBvZiBsYXllciB0byBiIGUgcmVtb3ZlZFxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVMYXllclVwZGF0ZXIgPSAoc3RhdGUsIHtpZHh9KSA9PiB7XG4gIGNvbnN0IHtsYXllcnMsIGxheWVyRGF0YSwgY2xpY2tlZCwgaG92ZXJJbmZvfSA9IHN0YXRlO1xuICBjb25zdCBsYXllclRvUmVtb3ZlID0gc3RhdGUubGF5ZXJzW2lkeF07XG4gIGNvbnN0IG5ld01hcHMgPSByZW1vdmVMYXllckZyb21TcGxpdE1hcHMoc3RhdGUuc3BsaXRNYXBzLCBsYXllclRvUmVtb3ZlKTtcblxuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXllcnM6IFsuLi5sYXllcnMuc2xpY2UoMCwgaWR4KSwgLi4ubGF5ZXJzLnNsaWNlKGlkeCArIDEsIGxheWVycy5sZW5ndGgpXSxcbiAgICBsYXllckRhdGE6IFtcbiAgICAgIC4uLmxheWVyRGF0YS5zbGljZSgwLCBpZHgpLFxuICAgICAgLi4ubGF5ZXJEYXRhLnNsaWNlKGlkeCArIDEsIGxheWVyRGF0YS5sZW5ndGgpXG4gICAgXSxcbiAgICBsYXllck9yZGVyOiBzdGF0ZS5sYXllck9yZGVyXG4gICAgICAuZmlsdGVyKGkgPT4gaSAhPT0gaWR4KVxuICAgICAgLm1hcChwaWQgPT4gKHBpZCA+IGlkeCA/IHBpZCAtIDEgOiBwaWQpKSxcbiAgICBjbGlja2VkOiBsYXllclRvUmVtb3ZlLmlzTGF5ZXJIb3ZlcmVkKGNsaWNrZWQpID8gdW5kZWZpbmVkIDogY2xpY2tlZCxcbiAgICBob3ZlckluZm86IGxheWVyVG9SZW1vdmUuaXNMYXllckhvdmVyZWQoaG92ZXJJbmZvKSA/IHVuZGVmaW5lZCA6IGhvdmVySW5mbyxcbiAgICBzcGxpdE1hcHM6IG5ld01hcHNcbiAgfTtcblxuICByZXR1cm4gdXBkYXRlQW5pbWF0aW9uRG9tYWluKG5ld1N0YXRlKTtcbn07XG5cbi8qKlxuICogUmVvcmRlciBsYXllclxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIGFjdGlvblxuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBhY3Rpb24ub3JkZXIgYW4gYXJyYXkgb2YgbGF5ZXIgaW5kZXhlc1xuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCByZW9yZGVyTGF5ZXJVcGRhdGVyID0gKHN0YXRlLCB7b3JkZXJ9KSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgbGF5ZXJPcmRlcjogb3JkZXJcbn0pO1xuXG4vKipcbiAqIFJlbW92ZSBhIGRhdGFzZXQgYW5kIGFsbCBsYXllcnMsIGZpbHRlcnMsIHRvb2x0aXAgY29uZmlncyB0aGF0IGJhc2VkIG9uIGl0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uLmtleSBkYXRhc2V0IGlkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZURhdGFzZXRVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgLy8gZXh0cmFjdCBkYXRhc2V0IGtleVxuICBjb25zdCB7a2V5OiBkYXRhc2V0S2V5fSA9IGFjdGlvbjtcbiAgY29uc3Qge2RhdGFzZXRzfSA9IHN0YXRlO1xuXG4gIC8vIGNoZWNrIGlmIGRhdGFzZXQgaXMgcHJlc2VudFxuICBpZiAoIWRhdGFzZXRzW2RhdGFzZXRLZXldKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgY29uc3Qge1xuICAgIGxheWVycyxcbiAgICBkYXRhc2V0czoge1tkYXRhc2V0S2V5XTogZGF0YXNldCwgLi4ubmV3RGF0YXNldHN9XG4gIH0gPSBzdGF0ZTtcbiAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4gIGNvbnN0IGluZGV4ZXMgPSBsYXllcnMucmVkdWNlKChsaXN0T2ZJbmRleGVzLCBsYXllciwgaW5kZXgpID0+IHtcbiAgICBpZiAobGF5ZXIuY29uZmlnLmRhdGFJZCA9PT0gZGF0YXNldEtleSkge1xuICAgICAgbGlzdE9mSW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RPZkluZGV4ZXM7XG4gIH0sIFtdKTtcblxuICAvLyByZW1vdmUgbGF5ZXJzIGFuZCBkYXRhc2V0c1xuICBjb25zdCB7bmV3U3RhdGV9ID0gaW5kZXhlcy5yZWR1Y2UoXG4gICAgKHtuZXdTdGF0ZTogY3VycmVudFN0YXRlLCBpbmRleENvdW50ZXJ9LCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGlkeCAtIGluZGV4Q291bnRlcjtcbiAgICAgIGN1cnJlbnRTdGF0ZSA9IHJlbW92ZUxheWVyVXBkYXRlcihjdXJyZW50U3RhdGUsIHtpZHg6IGN1cnJlbnRJbmRleH0pO1xuICAgICAgaW5kZXhDb3VudGVyKys7XG4gICAgICByZXR1cm4ge25ld1N0YXRlOiBjdXJyZW50U3RhdGUsIGluZGV4Q291bnRlcn07XG4gICAgfSxcbiAgICB7bmV3U3RhdGU6IHsuLi5zdGF0ZSwgZGF0YXNldHM6IG5ld0RhdGFzZXRzfSwgaW5kZXhDb3VudGVyOiAwfVxuICApO1xuXG4gIC8vIHJlbW92ZSBmaWx0ZXJzXG4gIGNvbnN0IGZpbHRlcnMgPSBzdGF0ZS5maWx0ZXJzLmZpbHRlcihmaWx0ZXIgPT4gZmlsdGVyLmRhdGFJZCAhPT0gZGF0YXNldEtleSk7XG5cbiAgLy8gdXBkYXRlIGludGVyYWN0aW9uQ29uZmlnXG4gIGxldCB7aW50ZXJhY3Rpb25Db25maWd9ID0gc3RhdGU7XG4gIGNvbnN0IHt0b29sdGlwfSA9IGludGVyYWN0aW9uQ29uZmlnO1xuICBpZiAodG9vbHRpcCkge1xuICAgIGNvbnN0IHtjb25maWd9ID0gdG9vbHRpcDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgIGNvbnN0IHtbZGF0YXNldEtleV06IGZpZWxkcywgLi4uZmllbGRzVG9TaG93fSA9IGNvbmZpZy5maWVsZHNUb1Nob3c7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgIGludGVyYWN0aW9uQ29uZmlnID0ge1xuICAgICAgLi4uaW50ZXJhY3Rpb25Db25maWcsXG4gICAgICB0b29sdGlwOiB7Li4udG9vbHRpcCwgY29uZmlnOiB7Li4uY29uZmlnLCBmaWVsZHNUb1Nob3d9fVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gey4uLm5ld1N0YXRlLCBmaWx0ZXJzLCBpbnRlcmFjdGlvbkNvbmZpZ307XG59O1xuXG4vKipcbiAqIHVwZGF0ZSBsYXllciBibGVuZGluZyBtb2RlXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uLm1vZGUgb25lIG9mIGBhZGRpdGl2ZWAsIGBub3JtYWxgIGFuZCBgc3VidHJhY3RpdmVgXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZUxheWVyQmxlbmRpbmdVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+ICh7XG4gIC4uLnN0YXRlLFxuICBsYXllckJsZW5kaW5nOiBhY3Rpb24ubW9kZVxufSk7XG5cbi8qKlxuICogRGlzcGxheSBkYXRhc2V0IHRhYmxlIGluIGEgbW9kYWxcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24uZGF0YUlkIGRhdGFzZXQgaWQgdG8gc2hvdyBpbiB0YWJsZVxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBzaG93RGF0YXNldFRhYmxlVXBkYXRlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZWRpdGluZ0RhdGFzZXQ6IGFjdGlvbi5kYXRhSWRcbiAgfTtcbn07XG5cbi8qKlxuICogcmVzZXQgdmlzU3RhdGUgdG8gaW5pdGlhbCBTdGF0ZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc2V0TWFwQ29uZmlnVXBkYXRlciA9IHN0YXRlID0+ICh7XG4gIC4uLklOSVRJQUxfVklTX1NUQVRFLFxuICAuLi5zdGF0ZS5pbml0aWFsU3RhdGUsXG4gIGluaXRpYWxTdGF0ZTogc3RhdGUuaW5pdGlhbFN0YXRlXG59KTtcblxuLyoqXG4gKiBQcm9wYWdhdGUgYHZpc1N0YXRlYCByZWR1Y2VyIHdpdGggYSBuZXcgY29uZmlndXJhdGlvbi4gQ3VycmVudCBjb25maWcgd2lsbCBiZSBvdmVycmlkZS5cbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24ucGF5bG9hZCBtYXAgY29uZmlnIHRvIGJlIHByb3BhZ2F0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24ucGF5bG9hZC5jb25maWcgbWFwIGNvbmZpZyB0byBiZSBwcm9wYWdhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLnBheWxvYWQub3B0aW9uIHtrZWVwRXhpc3RpbmdDb25maWc6IHRydWUgfCBmYWxzZX1cbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgcmVjZWl2ZU1hcENvbmZpZ1VwZGF0ZXIgPSAoXG4gIHN0YXRlLFxuICB7cGF5bG9hZDoge2NvbmZpZyA9IHt9LCBvcHRpb25zID0ge319fVxuKSA9PiB7XG4gIGlmICghY29uZmlnLnZpc1N0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGZpbHRlcnMsXG4gICAgbGF5ZXJzLFxuICAgIGludGVyYWN0aW9uQ29uZmlnLFxuICAgIGxheWVyQmxlbmRpbmcsXG4gICAgc3BsaXRNYXBzLFxuICAgIGFuaW1hdGlvbkNvbmZpZ1xuICB9ID0gY29uZmlnLnZpc1N0YXRlO1xuXG4gIGNvbnN0IHtrZWVwRXhpc3RpbmdDb25maWd9ID0gb3B0aW9ucztcblxuICAvLyByZXNldCBjb25maWcgaWYga2VlcEV4aXN0aW5nQ29uZmlnIGlzIGZhbHN5XG4gIGxldCBtZXJnZWRTdGF0ZSA9ICFrZWVwRXhpc3RpbmdDb25maWcgPyByZXNldE1hcENvbmZpZ1VwZGF0ZXIoc3RhdGUpIDogc3RhdGU7XG4gIG1lcmdlZFN0YXRlID0gbWVyZ2VGaWx0ZXJzKG1lcmdlZFN0YXRlLCBmaWx0ZXJzKTtcbiAgbWVyZ2VkU3RhdGUgPSBtZXJnZUxheWVycyhtZXJnZWRTdGF0ZSwgbGF5ZXJzKTtcbiAgbWVyZ2VkU3RhdGUgPSBtZXJnZUludGVyYWN0aW9ucyhtZXJnZWRTdGF0ZSwgaW50ZXJhY3Rpb25Db25maWcpO1xuICBtZXJnZWRTdGF0ZSA9IG1lcmdlTGF5ZXJCbGVuZGluZyhtZXJnZWRTdGF0ZSwgbGF5ZXJCbGVuZGluZyk7XG4gIG1lcmdlZFN0YXRlID0gbWVyZ2VTcGxpdE1hcHMobWVyZ2VkU3RhdGUsIHNwbGl0TWFwcyk7XG4gIG1lcmdlZFN0YXRlID0gbWVyZ2VBbmltYXRpb25Db25maWcobWVyZ2VkU3RhdGUsIGFuaW1hdGlvbkNvbmZpZyk7XG5cbiAgcmV0dXJuIG1lcmdlZFN0YXRlO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGxheWVyIGhvdmVyIGV2ZW50IHdpdGggaG92ZXJlZCBvYmplY3RcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24uaW5mbyBPYmplY3QgaG92ZXJlZCwgcmV0dXJuZWQgYnkgZGVjay5nbFxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBsYXllckhvdmVyVXBkYXRlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgaG92ZXJJbmZvOiBhY3Rpb24uaW5mb1xufSk7XG5cbi8qKlxuICogVHJpZ2dlciBsYXllciBjbGljayBldmVudCB3aXRoIGNsaWNrZWQgb2JqZWN0XG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLmluZm8gT2JqZWN0IGNsaWNrZWQsIHJldHVybmVkIGJ5IGRlY2suZ2xcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgbGF5ZXJDbGlja1VwZGF0ZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIG1vdXNlUG9zOiBzdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZy5jb29yZGluYXRlLmVuYWJsZWRcbiAgICA/IHtcbiAgICAgICAgLi4uc3RhdGUubW91c2VQb3MsXG4gICAgICAgIHBpbm5lZDogc3RhdGUubW91c2VQb3MucGlubmVkID8gbnVsbCA6IGNsb25lRGVlcChzdGF0ZS5tb3VzZVBvcylcbiAgICAgIH1cbiAgICA6IHN0YXRlLm1vdXNlUG9zLFxuICBjbGlja2VkOiBhY3Rpb24uaW5mbyAmJiBhY3Rpb24uaW5mby5waWNrZWQgPyBhY3Rpb24uaW5mbyA6IG51bGxcbn0pO1xuXG4vKipcbiAqIFRyaWdnZXIgbWFwIGNsaWNrIGV2ZW50LCB1bnNlbGVjdCBjbGlja2VkIG9iamVjdFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcENsaWNrVXBkYXRlciA9IHN0YXRlID0+IHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBjbGlja2VkOiBudWxsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgbW91c2VNb3ZlVXBkYXRlciA9IChzdGF0ZSwge2V2dH0pID0+IHtcbiAgaWYgKE9iamVjdC52YWx1ZXMoc3RhdGUuaW50ZXJhY3Rpb25Db25maWcpLnNvbWUoY29uZmlnID0+IGNvbmZpZy5lbmFibGVkKSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIG1vdXNlUG9zOiB7XG4gICAgICAgIC4uLnN0YXRlLm1vdXNlUG9zLFxuICAgICAgICBtb3VzZVBvc2l0aW9uOiBbLi4uZXZ0LnBvaW50XSxcbiAgICAgICAgY29vcmRpbmF0ZTogWy4uLmV2dC5sbmdMYXRdXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn07XG4vKipcbiAqIFRvZ2dsZSB2aXNpYmlsaXR5IG9mIGEgbGF5ZXIgZm9yIGEgc3BsaXQgbWFwXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcnx1bmRlZmluZWR9IGFjdGlvbi5wYXlsb2FkIGluZGV4IG9mIHRoZSBzcGxpdCBtYXBcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgdG9nZ2xlU3BsaXRNYXBVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+XG4gIHN0YXRlLnNwbGl0TWFwcyAmJiBzdGF0ZS5zcGxpdE1hcHMubGVuZ3RoID09PSAwXG4gICAgPyB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAvLyBtYXliZSB3ZSBzaG91bGQgdXNlIGFuIGFycmF5IHRvIHN0b3JlIHN0YXRlIGZvciBhIHNpbmdsZSBtYXAgYXMgd2VsbFxuICAgICAgICAvLyBpZiBjdXJyZW50IG1hcHMgbGVuZ3RoIGlzIGVxdWFsIHRvIDAgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgYWJvdXQgdG8gc3BsaXQgdGhlIHZpZXdcbiAgICAgICAgc3BsaXRNYXBzOiBjb21wdXRlU3BsaXRNYXBMYXllcnMoc3RhdGUubGF5ZXJzKVxuICAgICAgfVxuICAgIDogY2xvc2VTcGVjaWZpY01hcEF0SW5kZXgoc3RhdGUsIGFjdGlvbik7XG5cbi8qKlxuICogVG9nZ2xlIHZpc2liaWxpdHkgb2YgYSBsYXllciBpbiBhIHNwbGl0IG1hcFxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGFjdGlvbi5tYXBJbmRleCBpbmRleCBvZiB0aGUgc3BsaXQgbWFwXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uLmxheWVySWQgaWQgb2YgdGhlIGxheWVyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUxheWVyRm9yTWFwVXBkYXRlciA9IChzdGF0ZSwge21hcEluZGV4LCBsYXllcklkfSkgPT4ge1xuICBjb25zdCB7c3BsaXRNYXBzfSA9IHN0YXRlO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgc3BsaXRNYXBzOiBzcGxpdE1hcHMubWFwKChzbSwgaSkgPT5cbiAgICAgIGkgPT09IG1hcEluZGV4XG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4uc3BsaXRNYXBzW2ldLFxuICAgICAgICAgICAgbGF5ZXJzOiB7XG4gICAgICAgICAgICAgIC4uLnNwbGl0TWFwc1tpXS5sYXllcnMsXG4gICAgICAgICAgICAgIC8vIGlmIGxheWVySWQgbm90IGluIGxheWVycywgc2V0IGl0IHRvIHZpc2libGVcbiAgICAgICAgICAgICAgW2xheWVySWRdOiAhc3BsaXRNYXBzW2ldLmxheWVyc1tsYXllcklkXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgOiBzbVxuICAgIClcbiAgfTtcbn07XG5cbi8qKlxuICogQWRkIG5ldyBkYXRhc2V0IHRvIGB2aXNTdGF0ZWAsIHdpdGggb3B0aW9uIHRvIGxvYWQgYSBtYXAgY29uZmlnIGFsb25nIHdpdGggdGhlIGRhdGFzZXRzXG4gKiBAbWVtYmVyb2YgdmlzU3RhdGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD58T2JqZWN0fSBhY3Rpb24uZGF0YXNldHMgLSAqKipyZXF1aXJlZCoqIGRhdGFzZXRzIGNhbiBiZSBhIGRhdGFzZXQgb3IgYW4gYXJyYXkgb2YgZGF0YXNldHNcbiAqIEVhY2ggZGF0YXNldCBvYmplY3QgbmVlZHMgdG8gaGF2ZSBgaW5mb2AgYW5kIGBkYXRhYCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24uZGF0YXNldHMuaW5mbyAtaW5mbyBvZiBhIGRhdGFzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24uZGF0YXNldHMuaW5mby5pZCAtIGlkIG9mIHRoaXMgZGF0YXNldC4gSWYgY29uZmlnIGlzIGRlZmluZWQsIGBpZGAgc2hvdWxkIG1hdGNoZXMgdGhlIGBkYXRhSWRgIGluIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24uZGF0YXNldHMuaW5mby5sYWJlbCAtIEEgZGlzcGxheSBuYW1lIG9mIHRoaXMgZGF0YXNldFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5kYXRhc2V0cy5kYXRhIC0gKioqcmVxdWlyZWQqKiBUaGUgZGF0YSBvYmplY3QsIGluIGEgdGFidWxhciBmb3JtYXQgd2l0aCAyIHByb3BlcnRpZXMgYGZpZWxkc2AgYW5kIGByb3dzYFxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBhY3Rpb24uZGF0YXNldHMuZGF0YS5maWVsZHMgLSAqKipyZXF1aXJlZCoqIEFycmF5IG9mIGZpZWxkcyxcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24uZGF0YXNldHMuZGF0YS5maWVsZHMubmFtZSAtICoqKnJlcXVpcmVkKiogTmFtZSBvZiB0aGUgZmllbGQsXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gYWN0aW9uLmRhdGFzZXRzLmRhdGEucm93cyAtICoqKnJlcXVpcmVkKiogQXJyYXkgb2Ygcm93cywgaW4gYSB0YWJ1bGFyIGZvcm1hdCB3aXRoIGBmaWVsZHNgIGFuZCBgcm93c2BcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24ub3B0aW9ucyBvcHRpb24gb2JqZWN0IGB7Y2VudGVyTWFwOiB0cnVlLCBrZWVwRXhpc3RpbmdDb25maWc6IGZhbHNlfWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24uY29uZmlnIG1hcCBjb25maWdcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVZpc0RhdGFVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgLy8gZGF0YXNldHMgY2FuIGJlIGEgc2luZ2xlIGRhdGEgZW50cmllcyBvciBhbiBhcnJheSBvZiBtdWx0aXBsZSBkYXRhIGVudHJpZXNcbiAgY29uc3Qge2NvbmZpZywgb3B0aW9uc30gPSBhY3Rpb247XG5cbiAgY29uc3QgZGF0YXNldHMgPSBBcnJheS5pc0FycmF5KGFjdGlvbi5kYXRhc2V0cylcbiAgICA/IGFjdGlvbi5kYXRhc2V0c1xuICAgIDogW2FjdGlvbi5kYXRhc2V0c107XG5cbiAgY29uc3QgbmV3RGF0ZUVudHJpZXMgPSBkYXRhc2V0cy5yZWR1Y2UoXG4gICAgKGFjY3UsIHtpbmZvID0ge30sIGRhdGF9KSA9PiAoe1xuICAgICAgLi4uYWNjdSxcbiAgICAgIC4uLihjcmVhdGVOZXdEYXRhRW50cnkoe2luZm8sIGRhdGF9LCBzdGF0ZS5kYXRhc2V0cykgfHwge30pXG4gICAgfSksXG4gICAge31cbiAgKTtcbiAgaWYgKCFPYmplY3Qua2V5cyhuZXdEYXRlRW50cmllcykubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgLy8gYXBwbHkgY29uZmlnIGlmIHBhc3NlZCBmcm9tIGFjdGlvblxuICBjb25zdCBwcmV2aW91c1N0YXRlID0gY29uZmlnXG4gICAgPyByZWNlaXZlTWFwQ29uZmlnVXBkYXRlcihzdGF0ZSwge1xuICAgICAgICBwYXlsb2FkOiB7Y29uZmlnLCBvcHRpb25zfVxuICAgICAgfSlcbiAgICA6IHN0YXRlO1xuXG4gIGNvbnN0IHN0YXRlV2l0aE5ld0RhdGEgPSB7XG4gICAgLi4ucHJldmlvdXNTdGF0ZSxcbiAgICBkYXRhc2V0czoge1xuICAgICAgLi4ucHJldmlvdXNTdGF0ZS5kYXRhc2V0cyxcbiAgICAgIC4uLm5ld0RhdGVFbnRyaWVzXG4gICAgfVxuICB9O1xuXG4gIC8vIHByZXZpb3VzbHkgc2F2ZWQgY29uZmlnIGJlZm9yZSBkYXRhIGxvYWRlZFxuICBjb25zdCB7XG4gICAgZmlsdGVyVG9CZU1lcmdlZCA9IFtdLFxuICAgIGxheWVyVG9CZU1lcmdlZCA9IFtdLFxuICAgIGludGVyYWN0aW9uVG9CZU1lcmdlZCA9IHt9LFxuICAgIHNwbGl0TWFwc1RvQmVNZXJnZWQgPSBbXVxuICB9ID0gc3RhdGVXaXRoTmV3RGF0YTtcblxuICAvLyBtZXJnZSBzdGF0ZSB3aXRoIHNhdmVkIGZpbHRlcnNcbiAgbGV0IG1lcmdlZFN0YXRlID0gbWVyZ2VGaWx0ZXJzKHN0YXRlV2l0aE5ld0RhdGEsIGZpbHRlclRvQmVNZXJnZWQpO1xuXG4gIC8vIG1lcmdlIHN0YXRlIHdpdGggc2F2ZWQgbGF5ZXJzXG4gIG1lcmdlZFN0YXRlID0gbWVyZ2VMYXllcnMobWVyZ2VkU3RhdGUsIGxheWVyVG9CZU1lcmdlZCk7XG5cbiAgLy8gbWVyZ2Ugc3RhdGUgd2l0aCBzYXZlZCBzcGxpdE1hcHNcbiAgbWVyZ2VkU3RhdGUgPSBtZXJnZVNwbGl0TWFwcyhtZXJnZWRTdGF0ZSwgc3BsaXRNYXBzVG9CZU1lcmdlZCk7XG5cbiAgbGV0IG5ld0xheWVycyA9IG1lcmdlZFN0YXRlLmxheWVycy5maWx0ZXIoXG4gICAgbCA9PiBsLmNvbmZpZy5kYXRhSWQgaW4gbmV3RGF0ZUVudHJpZXNcbiAgKTtcblxuICBpZiAoIW5ld0xheWVycy5sZW5ndGgpIHtcbiAgICAvLyBubyBsYXllciBtZXJnZWQsIGZpbmQgZGVmYXVsdHNcbiAgICBjb25zdCByZXN1bHQgPSBhZGREZWZhdWx0TGF5ZXJzKG1lcmdlZFN0YXRlLCBuZXdEYXRlRW50cmllcyk7XG4gICAgbWVyZ2VkU3RhdGUgPSByZXN1bHQuc3RhdGU7XG4gICAgbmV3TGF5ZXJzID0gcmVzdWx0Lm5ld0xheWVycztcbiAgfVxuXG4gIGlmIChtZXJnZWRTdGF0ZS5zcGxpdE1hcHMubGVuZ3RoKSB7XG4gICAgLy8gaWYgbWFwIGlzIHNwbGl0LCBhZGQgbmV3IGxheWVycyB0byBzcGxpdE1hcHNcbiAgICBuZXdMYXllcnMgPSBtZXJnZWRTdGF0ZS5sYXllcnMuZmlsdGVyKFxuICAgICAgbCA9PiBsLmNvbmZpZy5kYXRhSWQgaW4gbmV3RGF0ZUVudHJpZXNcbiAgICApO1xuICAgIG1lcmdlZFN0YXRlID0ge1xuICAgICAgLi4ubWVyZ2VkU3RhdGUsXG4gICAgICBzcGxpdE1hcHM6IGFkZE5ld0xheWVyc1RvU3BsaXRNYXAobWVyZ2VkU3RhdGUuc3BsaXRNYXBzLCBuZXdMYXllcnMpXG4gICAgfTtcbiAgfVxuXG4gIC8vIG1lcmdlIHN0YXRlIHdpdGggc2F2ZWQgaW50ZXJhY3Rpb25zXG4gIG1lcmdlZFN0YXRlID0gbWVyZ2VJbnRlcmFjdGlvbnMobWVyZ2VkU3RhdGUsIGludGVyYWN0aW9uVG9CZU1lcmdlZCk7XG5cbiAgLy8gaWYgbm8gdG9vbHRpcHMgbWVyZ2VkIGFkZCBkZWZhdWx0IHRvb2x0aXBzXG4gIE9iamVjdC5rZXlzKG5ld0RhdGVFbnRyaWVzKS5mb3JFYWNoKGRhdGFJZCA9PiB7XG4gICAgY29uc3QgdG9vbHRpcEZpZWxkcyA9XG4gICAgICBtZXJnZWRTdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZy50b29sdGlwLmNvbmZpZy5maWVsZHNUb1Nob3dbZGF0YUlkXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9vbHRpcEZpZWxkcykgfHwgIXRvb2x0aXBGaWVsZHMubGVuZ3RoKSB7XG4gICAgICBtZXJnZWRTdGF0ZSA9IGFkZERlZmF1bHRUb29sdGlwcyhtZXJnZWRTdGF0ZSwgbmV3RGF0ZUVudHJpZXNbZGF0YUlkXSk7XG4gICAgfVxuICB9KTtcblxuICBsZXQgdXBkYXRlZFN0YXRlID0gdXBkYXRlQWxsTGF5ZXJEb21haW5EYXRhKFxuICAgIG1lcmdlZFN0YXRlLFxuICAgIE9iamVjdC5rZXlzKG5ld0RhdGVFbnRyaWVzKVxuICApO1xuXG4gIC8vIHJlZ2lzdGVyIGxheWVyIGFuaW1hdGlvbiBkb21haW4sXG4gIC8vIG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyIGxheWVyIGRhdGEgaXMgY2FsY3VsYXRlZFxuICB1cGRhdGVkU3RhdGUgPSB1cGRhdGVBbmltYXRpb25Eb21haW4odXBkYXRlZFN0YXRlKTtcblxuICByZXR1cm4gdXBkYXRlZFN0YXRlO1xufTtcbi8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuLyoqXG4gKiBXaGVuIGEgdXNlciBjbGlja3Mgb24gdGhlIHNwZWNpZmljIG1hcCBjbG9zaW5nIGljb25cbiAqIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNsb3NlIHRoZSBzZWxlY3RlZCBtYXBcbiAqIGFuZCB3aWxsIG1lcmdlIHRoZSByZW1haW5pbmcgb25lIHdpdGggdGhlIGdsb2JhbCBzdGF0ZVxuICogVE9ETzogaSB0aGluayBpbiB0aGUgZnV0dXJlIHRoaXMgYWN0aW9uIHNob3VsZCBiZSBjYWxsZWQgbWVyZ2UgbWFwIGxheWVycyB3aXRoIGdsb2JhbCBzZXR0aW5nc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGB2aXNTdGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gYWN0aW9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqL1xuZnVuY3Rpb24gY2xvc2VTcGVjaWZpY01hcEF0SW5kZXgoc3RhdGUsIGFjdGlvbikge1xuICAvLyByZXRyaWV2ZSBsYXllcnMgbWV0YSBkYXRhIGZyb20gdGhlIHJlbWFpbmluZyBtYXAgdGhhdCB3ZSBuZWVkIHRvIGtlZXBcbiAgY29uc3QgaW5kZXhUb1JldHJpZXZlID0gMSAtIGFjdGlvbi5wYXlsb2FkO1xuICBjb25zdCBtYXBMYXllcnMgPSBzdGF0ZS5zcGxpdE1hcHNbaW5kZXhUb1JldHJpZXZlXS5sYXllcnM7XG4gIGNvbnN0IHtsYXllcnN9ID0gc3RhdGU7XG5cbiAgLy8gdXBkYXRlIGxheWVyIHZpc2liaWxpdHlcbiAgY29uc3QgbmV3TGF5ZXJzID0gbGF5ZXJzLm1hcChsYXllciA9PlxuICAgICFtYXBMYXllcnNbbGF5ZXIuaWRdICYmIGxheWVyLmNvbmZpZy5pc1Zpc2libGVcbiAgICAgID8gbGF5ZXIudXBkYXRlTGF5ZXJDb25maWcoe1xuICAgICAgICAgIC8vIGlmIGxheWVyLmlkIGlzIG5vdCBpbiBtYXBMYXllcnMsIGl0IHNob3VsZCBiZSBpblZpc2libGVcbiAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlXG4gICAgICAgIH0pXG4gICAgICA6IGxheWVyXG4gICk7XG5cbiAgLy8gZGVsZXRlIG1hcFxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGxheWVyczogbmV3TGF5ZXJzLFxuICAgIHNwbGl0TWFwczogW11cbiAgfTtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGZpbGUgbG9hZGluZyBkaXNwYXRjaCBgYWRkRGF0YVRvTWFwYCBpZiBzdWNjZWVkLCBvciBgbG9hZEZpbGVzRXJyYCBpZiBmYWlsZWRcbiAqIEBtZW1iZXJvZiB2aXNTdGF0ZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYHZpc1N0YXRlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBhY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gYWN0aW9uLmZpbGVzIGFycmF5IG9mIGZpbGVibG9iXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRGaWxlc1VwZGF0ZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuXG4gIGNvbnN0IHtmaWxlc30gPSBhY3Rpb247XG4gIGNvbnN0IGZpbGVzVG9Mb2FkID0gZmlsZXMubWFwKGZpbGVCbG9iID0+IHByb2Nlc3NGaWxlVG9Mb2FkKGZpbGVCbG9iKSk7XG4gIC8vIHJlYWRlciAtPiBwYXJzZXIgLT4gYXVnbWVudCAtPiByZWNlaXZlVmlzRGF0YVxuICBjb25zdCBsb2FkRmlsZVRhc2tzID0gW1xuICAgIFRhc2suYWxsKGZpbGVzVG9Mb2FkLm1hcChMT0FEX0ZJTEVfVEFTSykpLmJpbWFwKFxuICAgICAgcmVzdWx0cyA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSByZXN1bHRzLnJlZHVjZShcbiAgICAgICAgICAoZiwgYykgPT4gKHtcbiAgICAgICAgICAgIC8vIHVzaW5nIGNvbmNhdCBoZXJlIGJlY2F1c2UgdGhlIGN1cnJlbnQgZGF0YXNldHMgY291bGQgYmUgYW4gYXJyYXkgb3IgYSBzaW5nbGUgaXRlbVxuICAgICAgICAgICAgZGF0YXNldHM6IGYuZGF0YXNldHMuY29uY2F0KGMuZGF0YXNldHMpLFxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBkZWVwIG1lcmdlIHRoaXMgdGhpbmcgdW5sZXNzIHdlIGZpbmQgYSBiZXR0ZXIgc29sdXRpb25cbiAgICAgICAgICAgIC8vIHRoaXMgY2FzZSB3aWxsIG9ubHkgaGFwcGVuIGlmIHdlIGFsbG93IHRvIGxvYWQgbXVsdGlwbGUga2VwbGVyZ2wganNvbiBmaWxlc1xuICAgICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgICAgIC4uLmYuY29uZmlnLFxuICAgICAgICAgICAgICAuLi4oYy5jb25maWcgfHwge30pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAge2RhdGFzZXRzOiBbXSwgY29uZmlnOiB7fSwgb3B0aW9uczoge2NlbnRlck1hcDogdHJ1ZX19XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBhZGREYXRhVG9NYXAoZGF0YSk7XG4gICAgICB9LFxuICAgICAgbG9hZEZpbGVzRXJyXG4gICAgKVxuICBdO1xuXG4gIHJldHVybiB3aXRoVGFzayhcbiAgICBzdGF0ZSxcbiAgICBsb2FkRmlsZVRhc2tzXG4gICk7XG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byB1cGRhdGUgQWxsIGxheWVyIGRvbWFpbiBhbmQgbGF5ZXIgZGF0YSBvZiBzdGF0ZVxuICogQG1lbWJlcm9mIHZpc1N0YXRlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgdmlzU3RhdGVgXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGRhdGFzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZERlZmF1bHRMYXllcnMoc3RhdGUsIGRhdGFzZXRzKSB7XG4gIGNvbnN0IGRlZmF1bHRMYXllcnMgPSBPYmplY3QudmFsdWVzKGRhdGFzZXRzKS5yZWR1Y2UoXG4gICAgKGFjY3UsIGRhdGFzZXQpID0+IFtcbiAgICAgIC4uLmFjY3UsXG4gICAgICAuLi4oZmluZERlZmF1bHRMYXllcihkYXRhc2V0LCBzdGF0ZS5sYXllckNsYXNzZXMpIHx8IFtdKVxuICAgIF0sXG4gICAgW11cbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHN0YXRlOiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGxheWVyczogWy4uLnN0YXRlLmxheWVycywgLi4uZGVmYXVsdExheWVyc10sXG4gICAgICBsYXllck9yZGVyOiBbXG4gICAgICAgIC8vIHB1dCBuZXcgbGF5ZXJzIG9uIHRvcCBvZiBvbGQgb25lc1xuICAgICAgICAuLi5kZWZhdWx0TGF5ZXJzLm1hcCgoXywgaSkgPT4gc3RhdGUubGF5ZXJzLmxlbmd0aCArIGkpLFxuICAgICAgICAuLi5zdGF0ZS5sYXllck9yZGVyXG4gICAgICBdXG4gICAgfSxcbiAgICBuZXdMYXllcnM6IGRlZmF1bHRMYXllcnNcbiAgfTtcbn1cblxuLyoqXG4gKiBoZWxwZXIgZnVuY3Rpb24gdG8gZmluZCBkZWZhdWx0IHRvb2x0aXBzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhc2V0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZERlZmF1bHRUb29sdGlwcyhzdGF0ZSwgZGF0YXNldCkge1xuICBjb25zdCB0b29sdGlwRmllbGRzID0gZmluZEZpZWxkc1RvU2hvdyhkYXRhc2V0KTtcblxuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIGludGVyYWN0aW9uQ29uZmlnOiB7XG4gICAgICAuLi5zdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZyxcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgLi4uc3RhdGUuaW50ZXJhY3Rpb25Db25maWcudG9vbHRpcCxcbiAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgLy8gZmluZCBkZWZhdWx0IGZpZWxkcyB0byBzaG93IGluIHRvb2x0aXBcbiAgICAgICAgICBmaWVsZHNUb1Nob3c6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLmludGVyYWN0aW9uQ29uZmlnLnRvb2x0aXAuY29uZmlnLmZpZWxkc1RvU2hvdyxcbiAgICAgICAgICAgIC4uLnRvb2x0aXBGaWVsZHNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHVwZGF0ZSBsYXllciBkb21haW5zIGZvciBhbiBhcnJheSBvZiBkYXRzZXRzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXk8c3RyaW5nPn0gZGF0YUlkIGRhdGFzZXQgaWQgb3IgYXJyYXkgb2YgZGF0YXNldCBpZHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXdGaWx0ZXIgaWYgaXMgY2FsbGVkIGJ5IHNldEZpbHRlciwgdGhlIGZpbHRlciB0aGF0IGhhcyBjaGFuZ2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUFsbExheWVyRG9tYWluRGF0YShzdGF0ZSwgZGF0YUlkLCBuZXdGaWx0ZXIpIHtcbiAgY29uc3QgZGF0YUlkcyA9IHR5cGVvZiBkYXRhSWQgPT09ICdzdHJpbmcnID8gW2RhdGFJZF0gOiBkYXRhSWQ7XG4gIGNvbnN0IG5ld0xheWVycyA9IFtdO1xuICBjb25zdCBuZXdMYXllckRhdGFzID0gW107XG5cbiAgc3RhdGUubGF5ZXJzLmZvckVhY2goKG9sZExheWVyLCBpKSA9PiB7XG4gICAgaWYgKG9sZExheWVyLmNvbmZpZy5kYXRhSWQgJiYgZGF0YUlkcy5pbmNsdWRlcyhvbGRMYXllci5jb25maWcuZGF0YUlkKSkge1xuICAgICAgLy8gTm8gbmVlZCB0byByZWNhbGN1bGF0ZSBsYXllciBkb21haW4gaWYgZmlsdGVyIGhhcyBmaXhlZCBkb21haW5cbiAgICAgIGNvbnN0IG5ld0xheWVyID1cbiAgICAgICAgbmV3RmlsdGVyICYmIG5ld0ZpbHRlci5maXhlZERvbWFpblxuICAgICAgICAgID8gb2xkTGF5ZXJcbiAgICAgICAgICA6IG9sZExheWVyLnVwZGF0ZUxheWVyRG9tYWluKFxuICAgICAgICAgICAgICBzdGF0ZS5kYXRhc2V0c1tvbGRMYXllci5jb25maWcuZGF0YUlkXSxcbiAgICAgICAgICAgICAgbmV3RmlsdGVyXG4gICAgICAgICAgICApO1xuXG4gICAgICBjb25zdCB7bGF5ZXJEYXRhLCBsYXllcn0gPSBjYWxjdWxhdGVMYXllckRhdGEoXG4gICAgICAgIG5ld0xheWVyLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgc3RhdGUubGF5ZXJEYXRhW2ldXG4gICAgICApO1xuXG4gICAgICBuZXdMYXllcnMucHVzaChsYXllcik7XG4gICAgICBuZXdMYXllckRhdGFzLnB1c2gobGF5ZXJEYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3TGF5ZXJzLnB1c2gob2xkTGF5ZXIpO1xuICAgICAgbmV3TGF5ZXJEYXRhcy5wdXNoKHN0YXRlLmxheWVyRGF0YVtpXSk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXllcnM6IG5ld0xheWVycyxcbiAgICBsYXllckRhdGE6IG5ld0xheWVyRGF0YXNcbiAgfTtcblxuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVBbmltYXRpb25Eb21haW4oc3RhdGUpIHtcbiAgLy8gbWVyZ2UgYWxsIGFuaW1hdGFibGUgbGF5ZXIgZG9tYWluIGFuZCB1cGRhdGUgZ2xvYmFsIGNvbmZpZ1xuICBjb25zdCBhbmltYXRhYmxlTGF5ZXJzID0gc3RhdGUubGF5ZXJzLmZpbHRlcihcbiAgICBsID0+XG4gICAgICBsLmNvbmZpZy5pc1Zpc2libGUgJiZcbiAgICAgIGwuY29uZmlnLmFuaW1hdGlvbiAmJlxuICAgICAgbC5jb25maWcuYW5pbWF0aW9uLmVuYWJsZWQgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkobC5hbmltYXRpb25Eb21haW4pXG4gICk7XG5cbiAgaWYgKCFhbmltYXRhYmxlTGF5ZXJzLmxlbmd0aCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIGFuaW1hdGlvbkNvbmZpZzogZGVmYXVsdEFuaW1hdGlvbkNvbmZpZ1xuICAgIH07XG4gIH1cblxuICBjb25zdCBtZXJnZWREb21haW4gPSBhbmltYXRhYmxlTGF5ZXJzLnJlZHVjZShcbiAgICAoYWNjdSwgbGF5ZXIpID0+IFtcbiAgICAgIE1hdGgubWluKGFjY3VbMF0sIGxheWVyLmFuaW1hdGlvbkRvbWFpblswXSksXG4gICAgICBNYXRoLm1heChhY2N1WzFdLCBsYXllci5hbmltYXRpb25Eb21haW5bMV0pXG4gICAgXSxcbiAgICBbTnVtYmVyKEluZmluaXR5KSwgLUluZmluaXR5XVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgYW5pbWF0aW9uQ29uZmlnOiB7XG4gICAgICAuLi5zdGF0ZS5hbmltYXRpb25Db25maWcsXG4gICAgICBjdXJyZW50VGltZTogaXNJblJhbmdlKHN0YXRlLmFuaW1hdGlvbkNvbmZpZy5jdXJyZW50VGltZSwgbWVyZ2VkRG9tYWluKVxuICAgICAgICA/IHN0YXRlLmFuaW1hdGlvbkNvbmZpZy5jdXJyZW50VGltZVxuICAgICAgICA6IG1lcmdlZERvbWFpblswXSxcbiAgICAgIGRvbWFpbjogbWVyZ2VkRG9tYWluXG4gICAgfVxuICB9O1xufVxuIl19