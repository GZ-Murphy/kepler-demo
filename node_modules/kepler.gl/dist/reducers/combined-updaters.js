"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addDataToMapComposed = exports.addDataToMapUpdater = exports.defaultAddDataToMapOptions = exports.isValidConfig = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _uiStateUpdaters = require("./ui-state-updaters");

var _visStateUpdaters = require("./vis-state-updaters");

var _mapStateUpdaters = require("./map-state-updaters");

var _mapStyleUpdaters = require("./map-style-updaters");

var _dataUtils = require("../utils/data-utils");

var _schemas = _interopRequireDefault(require("../schemas"));

var _utils = require("../utils/utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// compose action to apply result multiple reducers, with the output of one

/**
 * Some actions will affect the entire kepler.lg instance state.
 * The updaters for these actions is exported as `combinedUpdaters`. These updater take the entire instance state
 * as the first argument. Read more about [Using updaters](../advanced-usage/using-updaters.md)
 * @public
 * @example
 *
 * import keplerGlReducer, {combinedUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    // add data to map after receiving data from remote sources
 *    case 'LOAD_REMOTE_RESOURCE_SUCCESS':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          // pass in kepler.gl instance state to combinedUpdaters
 *          map:  combinedUpdaters.addDataToMapUpdater(
 *           state.keplerGl.map,
 *           {
 *             payload: {
 *               datasets: action.datasets,
 *               options: {readOnly: true},
 *               config: action.config
 *              }
 *            }
 *          )
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable no-unused-vars */
var combinedUpdaters = null;
/* eslint-enable no-unused-vars */

var isValidConfig = function isValidConfig(config) {
  return (0, _utils.isPlainObject)(config) && (0, _utils.isPlainObject)(config.config) && config.version;
};

exports.isValidConfig = isValidConfig;
var defaultAddDataToMapOptions = {
  centerMap: true,
  keepExistingConfig: false
};
/**
 * Combine data and full configuration update in a single action
 *
 * @memberof combinedUpdaters
 * @param {Object} state kepler.gl instance state, containing all subreducer state
 * @param {Object} action
 * @param {Object} action.payload `{datasets, options, config}`
 * @param {Array<Object>|Object} action.payload.datasets - ***required** datasets can be a dataset or an array of datasets
 * Each dataset object needs to have `info` and `data` property.
 * @param {Object} action.payload.datasets.info -info of a dataset
 * @param {string} action.payload.datasets.info.id - id of this dataset. If config is defined, `id` should matches the `dataId` in config.
 * @param {string} action.payload.datasets.info.label - A display name of this dataset
 * @param {Object} action.payload.datasets.data - ***required** The data object, in a tabular format with 2 properties `fields` and `rows`
 * @param {Array<Object>} action.payload.datasets.data.fields - ***required** Array of fields,
 * @param {string} action.payload.datasets.data.fields.name - ***required** Name of the field,
 * @param {Array<Array>} action.payload.datasets.data.rows - ***required** Array of rows, in a tabular format with `fields` and `rows`
 * @param {Object} action.payload.options option object `{centerMap: true}`
 * @param {Object} action.payload.config map config
 * @returns {Object} nextState
 * @public
 */

exports.defaultAddDataToMapOptions = defaultAddDataToMapOptions;

var addDataToMapUpdater = function addDataToMapUpdater(state, _ref) {
  var payload = _ref.payload;
  var datasets = payload.datasets,
      config = payload.config;

  var options = _objectSpread({}, defaultAddDataToMapOptions, {}, payload.options);

  var parsedConfig = config;

  if (isValidConfig(config)) {
    // if passed in saved config
    parsedConfig = _schemas["default"].parseSavedConfig(config);
  }

  var oldLayers = state.visState.layers; // Update visState store

  var mergedState = _objectSpread({}, state, {
    visState: (0, _visStateUpdaters.updateVisDataUpdater)(state.visState, {
      datasets: datasets,
      options: options,
      config: parsedConfig
    })
  });

  var bounds;

  if (options.centerMap) {
    // find map bounds for new layers
    var newLayers = mergedState.visState.layers.filter(function (nl) {
      return !oldLayers.find(function (ol) {
        return ol === nl;
      });
    });
    bounds = (0, _dataUtils.findMapBounds)(newLayers);
  } // Update mapState store


  mergedState = _objectSpread({}, mergedState, {
    mapState: (0, _mapStateUpdaters.receiveMapConfigUpdater)(mergedState.mapState, {
      payload: {
        config: parsedConfig,
        options: options,
        bounds: bounds
      }
    })
  }); // Update mapStyle store

  mergedState = _objectSpread({}, mergedState, {
    mapStyle: (0, _mapStyleUpdaters.receiveMapConfigUpdater)(mergedState.mapStyle, {
      payload: {
        config: parsedConfig,
        options: options
      }
    })
  }); // Update uiState

  mergedState = _objectSpread({}, mergedState, {
    uiState: _objectSpread({}, (0, _uiStateUpdaters.toggleModalUpdater)((0, _uiStateUpdaters.loadFilesSuccessUpdater)(mergedState.uiState), {
      payload: null
    }), {}, options.hasOwnProperty('readOnly') ? {
      readOnly: options.readOnly
    } : {})
  });
  return mergedState;
};

exports.addDataToMapUpdater = addDataToMapUpdater;
var addDataToMapComposed = addDataToMapUpdater;
exports.addDataToMapComposed = addDataToMapComposed;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWR1Y2Vycy9jb21iaW5lZC11cGRhdGVycy5qcyJdLCJuYW1lcyI6WyJjb21iaW5lZFVwZGF0ZXJzIiwiaXNWYWxpZENvbmZpZyIsImNvbmZpZyIsInZlcnNpb24iLCJkZWZhdWx0QWRkRGF0YVRvTWFwT3B0aW9ucyIsImNlbnRlck1hcCIsImtlZXBFeGlzdGluZ0NvbmZpZyIsImFkZERhdGFUb01hcFVwZGF0ZXIiLCJzdGF0ZSIsInBheWxvYWQiLCJkYXRhc2V0cyIsIm9wdGlvbnMiLCJwYXJzZWRDb25maWciLCJLZXBsZXJHbFNjaGVtYSIsInBhcnNlU2F2ZWRDb25maWciLCJvbGRMYXllcnMiLCJ2aXNTdGF0ZSIsImxheWVycyIsIm1lcmdlZFN0YXRlIiwiYm91bmRzIiwibmV3TGF5ZXJzIiwiZmlsdGVyIiwibmwiLCJmaW5kIiwib2wiLCJtYXBTdGF0ZSIsIm1hcFN0eWxlIiwidWlTdGF0ZSIsImhhc093blByb3BlcnR5IiwicmVhZE9ubHkiLCJhZGREYXRhVG9NYXBDb21wb3NlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQUVBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5Q0E7QUFDQSxJQUFNQSxnQkFBZ0IsR0FBRyxJQUF6QjtBQUNBOztBQUVPLElBQU1DLGFBQWEsR0FBRyxTQUFoQkEsYUFBZ0IsQ0FBQUMsTUFBTTtBQUFBLFNBQ2pDLDBCQUFjQSxNQUFkLEtBQXlCLDBCQUFjQSxNQUFNLENBQUNBLE1BQXJCLENBQXpCLElBQXlEQSxNQUFNLENBQUNDLE9BRC9CO0FBQUEsQ0FBNUI7OztBQUVBLElBQU1DLDBCQUEwQixHQUFHO0FBQ3hDQyxFQUFBQSxTQUFTLEVBQUUsSUFENkI7QUFFeENDLEVBQUFBLGtCQUFrQixFQUFFO0FBRm9CLENBQW5DO0FBSVA7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCTyxJQUFNQyxtQkFBbUIsR0FBRyxTQUF0QkEsbUJBQXNCLENBQUNDLEtBQUQsUUFBc0I7QUFBQSxNQUFiQyxPQUFhLFFBQWJBLE9BQWE7QUFBQSxNQUNoREMsUUFEZ0QsR0FDNUJELE9BRDRCLENBQ2hEQyxRQURnRDtBQUFBLE1BQ3RDUixNQURzQyxHQUM1Qk8sT0FENEIsQ0FDdENQLE1BRHNDOztBQUd2RCxNQUFNUyxPQUFPLHFCQUNSUCwwQkFEUSxNQUVSSyxPQUFPLENBQUNFLE9BRkEsQ0FBYjs7QUFLQSxNQUFJQyxZQUFZLEdBQUdWLE1BQW5COztBQUVBLE1BQUlELGFBQWEsQ0FBQ0MsTUFBRCxDQUFqQixFQUEyQjtBQUN6QjtBQUNBVSxJQUFBQSxZQUFZLEdBQUdDLG9CQUFlQyxnQkFBZixDQUFnQ1osTUFBaEMsQ0FBZjtBQUNEOztBQUNELE1BQU1hLFNBQVMsR0FBR1AsS0FBSyxDQUFDUSxRQUFOLENBQWVDLE1BQWpDLENBZHVELENBZ0J2RDs7QUFDQSxNQUFJQyxXQUFXLHFCQUNWVixLQURVO0FBRWJRLElBQUFBLFFBQVEsRUFBRSw0Q0FBNkJSLEtBQUssQ0FBQ1EsUUFBbkMsRUFBNkM7QUFDckROLE1BQUFBLFFBQVEsRUFBUkEsUUFEcUQ7QUFFckRDLE1BQUFBLE9BQU8sRUFBUEEsT0FGcUQ7QUFHckRULE1BQUFBLE1BQU0sRUFBRVU7QUFINkMsS0FBN0M7QUFGRyxJQUFmOztBQVNBLE1BQUlPLE1BQUo7O0FBQ0EsTUFBSVIsT0FBTyxDQUFDTixTQUFaLEVBQXVCO0FBQ3JCO0FBQ0EsUUFBTWUsU0FBUyxHQUFHRixXQUFXLENBQUNGLFFBQVosQ0FBcUJDLE1BQXJCLENBQTRCSSxNQUE1QixDQUNoQixVQUFBQyxFQUFFO0FBQUEsYUFBSSxDQUFDUCxTQUFTLENBQUNRLElBQVYsQ0FBZSxVQUFBQyxFQUFFO0FBQUEsZUFBSUEsRUFBRSxLQUFLRixFQUFYO0FBQUEsT0FBakIsQ0FBTDtBQUFBLEtBRGMsQ0FBbEI7QUFHQUgsSUFBQUEsTUFBTSxHQUFHLDhCQUFjQyxTQUFkLENBQVQ7QUFDRCxHQWpDc0QsQ0FtQ3ZEOzs7QUFDQUYsRUFBQUEsV0FBVyxxQkFDTkEsV0FETTtBQUVUTyxJQUFBQSxRQUFRLEVBQUUsK0NBQXNCUCxXQUFXLENBQUNPLFFBQWxDLEVBQTRDO0FBQ3BEaEIsTUFBQUEsT0FBTyxFQUFFO0FBQUNQLFFBQUFBLE1BQU0sRUFBRVUsWUFBVDtBQUF1QkQsUUFBQUEsT0FBTyxFQUFQQSxPQUF2QjtBQUFnQ1EsUUFBQUEsTUFBTSxFQUFOQTtBQUFoQztBQUQyQyxLQUE1QztBQUZELElBQVgsQ0FwQ3VELENBMkN2RDs7QUFDQUQsRUFBQUEsV0FBVyxxQkFDTkEsV0FETTtBQUVUUSxJQUFBQSxRQUFRLEVBQUUsK0NBQXNCUixXQUFXLENBQUNRLFFBQWxDLEVBQTRDO0FBQ3BEakIsTUFBQUEsT0FBTyxFQUFFO0FBQUNQLFFBQUFBLE1BQU0sRUFBRVUsWUFBVDtBQUF1QkQsUUFBQUEsT0FBTyxFQUFQQTtBQUF2QjtBQUQyQyxLQUE1QztBQUZELElBQVgsQ0E1Q3VELENBbUR2RDs7QUFDQU8sRUFBQUEsV0FBVyxxQkFDTkEsV0FETTtBQUVUUyxJQUFBQSxPQUFPLG9CQUNGLHlDQUFtQiw4Q0FBd0JULFdBQVcsQ0FBQ1MsT0FBcEMsQ0FBbkIsRUFBaUU7QUFDbEVsQixNQUFBQSxPQUFPLEVBQUU7QUFEeUQsS0FBakUsQ0FERSxNQUlERSxPQUFPLENBQUNpQixjQUFSLENBQXVCLFVBQXZCLElBQ0E7QUFBQ0MsTUFBQUEsUUFBUSxFQUFFbEIsT0FBTyxDQUFDa0I7QUFBbkIsS0FEQSxHQUVBLEVBTkM7QUFGRSxJQUFYO0FBWUEsU0FBT1gsV0FBUDtBQUNELENBakVNOzs7QUFtRUEsSUFBTVksb0JBQW9CLEdBQUd2QixtQkFBN0IiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTkgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge3RvZ2dsZU1vZGFsVXBkYXRlciwgbG9hZEZpbGVzU3VjY2Vzc1VwZGF0ZXJ9IGZyb20gJy4vdWktc3RhdGUtdXBkYXRlcnMnO1xuaW1wb3J0IHt1cGRhdGVWaXNEYXRhVXBkYXRlciBhcyB2aXNTdGF0ZVVwZGF0ZVZpc0RhdGFVcGRhdGVyfSBmcm9tICcuL3Zpcy1zdGF0ZS11cGRhdGVycyc7XG5pbXBvcnQge3JlY2VpdmVNYXBDb25maWdVcGRhdGVyIGFzIHN0YXRlTWFwQ29uZmlnVXBkYXRlcn0gZnJvbSAnLi9tYXAtc3RhdGUtdXBkYXRlcnMnO1xuaW1wb3J0IHtyZWNlaXZlTWFwQ29uZmlnVXBkYXRlciBhcyBzdHlsZU1hcENvbmZpZ1VwZGF0ZXJ9IGZyb20gJy4vbWFwLXN0eWxlLXVwZGF0ZXJzJztcbmltcG9ydCB7ZmluZE1hcEJvdW5kc30gZnJvbSAndXRpbHMvZGF0YS11dGlscyc7XG5pbXBvcnQgS2VwbGVyR2xTY2hlbWEgZnJvbSAnc2NoZW1hcyc7XG5pbXBvcnQge2lzUGxhaW5PYmplY3R9IGZyb20gJ3V0aWxzL3V0aWxzJztcblxuLy8gY29tcG9zZSBhY3Rpb24gdG8gYXBwbHkgcmVzdWx0IG11bHRpcGxlIHJlZHVjZXJzLCB3aXRoIHRoZSBvdXRwdXQgb2Ygb25lXG5cbi8qKlxuICogU29tZSBhY3Rpb25zIHdpbGwgYWZmZWN0IHRoZSBlbnRpcmUga2VwbGVyLmxnIGluc3RhbmNlIHN0YXRlLlxuICogVGhlIHVwZGF0ZXJzIGZvciB0aGVzZSBhY3Rpb25zIGlzIGV4cG9ydGVkIGFzIGBjb21iaW5lZFVwZGF0ZXJzYC4gVGhlc2UgdXBkYXRlciB0YWtlIHRoZSBlbnRpcmUgaW5zdGFuY2Ugc3RhdGVcbiAqIGFzIHRoZSBmaXJzdCBhcmd1bWVudC4gUmVhZCBtb3JlIGFib3V0IFtVc2luZyB1cGRhdGVyc10oLi4vYWR2YW5jZWQtdXNhZ2UvdXNpbmctdXBkYXRlcnMubWQpXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCBrZXBsZXJHbFJlZHVjZXIsIHtjb21iaW5lZFVwZGF0ZXJzfSBmcm9tICdrZXBsZXIuZ2wvcmVkdWNlcnMnO1xuICogLy8gUm9vdCBSZWR1Y2VyXG4gKiBjb25zdCByZWR1Y2VycyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gKiAga2VwbGVyR2w6IGtlcGxlckdsUmVkdWNlcixcbiAqICBhcHA6IGFwcFJlZHVjZXJcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGNvbXBvc2VkUmVkdWNlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gKiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICogICAgLy8gYWRkIGRhdGEgdG8gbWFwIGFmdGVyIHJlY2VpdmluZyBkYXRhIGZyb20gcmVtb3RlIHNvdXJjZXNcbiAqICAgIGNhc2UgJ0xPQURfUkVNT1RFX1JFU09VUkNFX1NVQ0NFU1MnOlxuICogICAgICByZXR1cm4ge1xuICogICAgICAgIC4uLnN0YXRlLFxuICogICAgICAgIGtlcGxlckdsOiB7XG4gKiAgICAgICAgICAuLi5zdGF0ZS5rZXBsZXJHbCxcbiAqICAgICAgICAgIC8vIHBhc3MgaW4ga2VwbGVyLmdsIGluc3RhbmNlIHN0YXRlIHRvIGNvbWJpbmVkVXBkYXRlcnNcbiAqICAgICAgICAgIG1hcDogIGNvbWJpbmVkVXBkYXRlcnMuYWRkRGF0YVRvTWFwVXBkYXRlcihcbiAqICAgICAgICAgICBzdGF0ZS5rZXBsZXJHbC5tYXAsXG4gKiAgICAgICAgICAge1xuICogICAgICAgICAgICAgcGF5bG9hZDoge1xuICogICAgICAgICAgICAgICBkYXRhc2V0czogYWN0aW9uLmRhdGFzZXRzLFxuICogICAgICAgICAgICAgICBvcHRpb25zOiB7cmVhZE9ubHk6IHRydWV9LFxuICogICAgICAgICAgICAgICBjb25maWc6IGFjdGlvbi5jb25maWdcbiAqICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgIH1cbiAqICAgICAgICAgIClcbiAqICAgICAgICB9XG4gKiAgICAgIH07XG4gKiAgfVxuICogIHJldHVybiByZWR1Y2VycyhzdGF0ZSwgYWN0aW9uKTtcbiAqIH07XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgY29tcG9zZWRSZWR1Y2VyO1xuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuY29uc3QgY29tYmluZWRVcGRhdGVycyA9IG51bGw7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmV4cG9ydCBjb25zdCBpc1ZhbGlkQ29uZmlnID0gY29uZmlnID0+XG4gIGlzUGxhaW5PYmplY3QoY29uZmlnKSAmJiBpc1BsYWluT2JqZWN0KGNvbmZpZy5jb25maWcpICYmIGNvbmZpZy52ZXJzaW9uO1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRBZGREYXRhVG9NYXBPcHRpb25zID0ge1xuICBjZW50ZXJNYXA6IHRydWUsXG4gIGtlZXBFeGlzdGluZ0NvbmZpZzogZmFsc2Vcbn07XG4vKipcbiAqIENvbWJpbmUgZGF0YSBhbmQgZnVsbCBjb25maWd1cmF0aW9uIHVwZGF0ZSBpbiBhIHNpbmdsZSBhY3Rpb25cbiAqXG4gKiBAbWVtYmVyb2YgY29tYmluZWRVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGtlcGxlci5nbCBpbnN0YW5jZSBzdGF0ZSwgY29udGFpbmluZyBhbGwgc3VicmVkdWNlciBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5wYXlsb2FkIGB7ZGF0YXNldHMsIG9wdGlvbnMsIGNvbmZpZ31gXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD58T2JqZWN0fSBhY3Rpb24ucGF5bG9hZC5kYXRhc2V0cyAtICoqKnJlcXVpcmVkKiogZGF0YXNldHMgY2FuIGJlIGEgZGF0YXNldCBvciBhbiBhcnJheSBvZiBkYXRhc2V0c1xuICogRWFjaCBkYXRhc2V0IG9iamVjdCBuZWVkcyB0byBoYXZlIGBpbmZvYCBhbmQgYGRhdGFgIHByb3BlcnR5LlxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5wYXlsb2FkLmRhdGFzZXRzLmluZm8gLWluZm8gb2YgYSBkYXRhc2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uLnBheWxvYWQuZGF0YXNldHMuaW5mby5pZCAtIGlkIG9mIHRoaXMgZGF0YXNldC4gSWYgY29uZmlnIGlzIGRlZmluZWQsIGBpZGAgc2hvdWxkIG1hdGNoZXMgdGhlIGBkYXRhSWRgIGluIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24ucGF5bG9hZC5kYXRhc2V0cy5pbmZvLmxhYmVsIC0gQSBkaXNwbGF5IG5hbWUgb2YgdGhpcyBkYXRhc2V0XG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLnBheWxvYWQuZGF0YXNldHMuZGF0YSAtICoqKnJlcXVpcmVkKiogVGhlIGRhdGEgb2JqZWN0LCBpbiBhIHRhYnVsYXIgZm9ybWF0IHdpdGggMiBwcm9wZXJ0aWVzIGBmaWVsZHNgIGFuZCBgcm93c2BcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gYWN0aW9uLnBheWxvYWQuZGF0YXNldHMuZGF0YS5maWVsZHMgLSAqKipyZXF1aXJlZCoqIEFycmF5IG9mIGZpZWxkcyxcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24ucGF5bG9hZC5kYXRhc2V0cy5kYXRhLmZpZWxkcy5uYW1lIC0gKioqcmVxdWlyZWQqKiBOYW1lIG9mIHRoZSBmaWVsZCxcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSBhY3Rpb24ucGF5bG9hZC5kYXRhc2V0cy5kYXRhLnJvd3MgLSAqKipyZXF1aXJlZCoqIEFycmF5IG9mIHJvd3MsIGluIGEgdGFidWxhciBmb3JtYXQgd2l0aCBgZmllbGRzYCBhbmQgYHJvd3NgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLnBheWxvYWQub3B0aW9ucyBvcHRpb24gb2JqZWN0IGB7Y2VudGVyTWFwOiB0cnVlfWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24ucGF5bG9hZC5jb25maWcgbWFwIGNvbmZpZ1xuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBhZGREYXRhVG9NYXBVcGRhdGVyID0gKHN0YXRlLCB7cGF5bG9hZH0pID0+IHtcbiAgY29uc3Qge2RhdGFzZXRzLCBjb25maWd9ID0gcGF5bG9hZDtcblxuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRBZGREYXRhVG9NYXBPcHRpb25zLFxuICAgIC4uLnBheWxvYWQub3B0aW9uc1xuICB9O1xuXG4gIGxldCBwYXJzZWRDb25maWcgPSBjb25maWc7XG5cbiAgaWYgKGlzVmFsaWRDb25maWcoY29uZmlnKSkge1xuICAgIC8vIGlmIHBhc3NlZCBpbiBzYXZlZCBjb25maWdcbiAgICBwYXJzZWRDb25maWcgPSBLZXBsZXJHbFNjaGVtYS5wYXJzZVNhdmVkQ29uZmlnKGNvbmZpZyk7XG4gIH1cbiAgY29uc3Qgb2xkTGF5ZXJzID0gc3RhdGUudmlzU3RhdGUubGF5ZXJzO1xuXG4gIC8vIFVwZGF0ZSB2aXNTdGF0ZSBzdG9yZVxuICBsZXQgbWVyZ2VkU3RhdGUgPSB7XG4gICAgLi4uc3RhdGUsXG4gICAgdmlzU3RhdGU6IHZpc1N0YXRlVXBkYXRlVmlzRGF0YVVwZGF0ZXIoc3RhdGUudmlzU3RhdGUsIHtcbiAgICAgIGRhdGFzZXRzLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNvbmZpZzogcGFyc2VkQ29uZmlnXG4gICAgfSlcbiAgfTtcblxuICBsZXQgYm91bmRzO1xuICBpZiAob3B0aW9ucy5jZW50ZXJNYXApIHtcbiAgICAvLyBmaW5kIG1hcCBib3VuZHMgZm9yIG5ldyBsYXllcnNcbiAgICBjb25zdCBuZXdMYXllcnMgPSBtZXJnZWRTdGF0ZS52aXNTdGF0ZS5sYXllcnMuZmlsdGVyKFxuICAgICAgbmwgPT4gIW9sZExheWVycy5maW5kKG9sID0+IG9sID09PSBubClcbiAgICApO1xuICAgIGJvdW5kcyA9IGZpbmRNYXBCb3VuZHMobmV3TGF5ZXJzKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBtYXBTdGF0ZSBzdG9yZVxuICBtZXJnZWRTdGF0ZSA9IHtcbiAgICAuLi5tZXJnZWRTdGF0ZSxcbiAgICBtYXBTdGF0ZTogc3RhdGVNYXBDb25maWdVcGRhdGVyKG1lcmdlZFN0YXRlLm1hcFN0YXRlLCB7XG4gICAgICBwYXlsb2FkOiB7Y29uZmlnOiBwYXJzZWRDb25maWcsIG9wdGlvbnMsIGJvdW5kc31cbiAgICB9KVxuICB9O1xuXG4gIC8vIFVwZGF0ZSBtYXBTdHlsZSBzdG9yZVxuICBtZXJnZWRTdGF0ZSA9IHtcbiAgICAuLi5tZXJnZWRTdGF0ZSxcbiAgICBtYXBTdHlsZTogc3R5bGVNYXBDb25maWdVcGRhdGVyKG1lcmdlZFN0YXRlLm1hcFN0eWxlLCB7XG4gICAgICBwYXlsb2FkOiB7Y29uZmlnOiBwYXJzZWRDb25maWcsIG9wdGlvbnN9XG4gICAgfSlcbiAgfTtcblxuICAvLyBVcGRhdGUgdWlTdGF0ZVxuICBtZXJnZWRTdGF0ZSA9IHtcbiAgICAuLi5tZXJnZWRTdGF0ZSxcbiAgICB1aVN0YXRlOiB7XG4gICAgICAuLi50b2dnbGVNb2RhbFVwZGF0ZXIobG9hZEZpbGVzU3VjY2Vzc1VwZGF0ZXIobWVyZ2VkU3RhdGUudWlTdGF0ZSksIHtcbiAgICAgICAgcGF5bG9hZDogbnVsbFxuICAgICAgfSksXG4gICAgICAuLi4ob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgncmVhZE9ubHknKVxuICAgICAgICA/IHtyZWFkT25seTogb3B0aW9ucy5yZWFkT25seX1cbiAgICAgICAgOiB7fSlcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIG1lcmdlZFN0YXRlO1xufTtcblxuZXhwb3J0IGNvbnN0IGFkZERhdGFUb01hcENvbXBvc2VkID0gYWRkRGF0YVRvTWFwVXBkYXRlcjtcbiJdfQ==