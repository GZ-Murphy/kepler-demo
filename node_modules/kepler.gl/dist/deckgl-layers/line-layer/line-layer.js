"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _deck = require("deck.gl");

var _constants = _interopRequireDefault(require("@luma.gl/constants"));

var _shaderUtils = require("../layer-utils/shader-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var defaultProps = _objectSpread({}, _deck.LineLayer.defaultProps, {
  // show arc if source is in brush
  brushSource: true,
  // show arc if target is in brush
  brushTarget: true,
  enableBrushing: true,
  getWidth: function getWidth(d) {
    return d.strokeWidth;
  },
  getTargetColor: function getTargetColor(x) {
    return x.color || [0, 0, 0, 255];
  },
  strokeScale: 1,
  // brush radius in meters
  brushRadius: 100000,
  mousePosition: [0, 0]
});

function addBrushingVsShader(vs) {
  var targetColorVs = (0, _shaderUtils.editShader)(vs, 'line target color vs', 'attribute vec4 instanceColors;', 'attribute vec4 instanceColors; attribute vec4 instanceTargetColors;');
  var brushingVs = (0, _shaderUtils.editShader)(targetColorVs, 'line brushing vs', 'vec2 offset = getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels);', 'vec2 offset = brushing_getExtrusionOffset(target.xy - source.xy, positions.y, project_uViewportSize, vec4(instanceSourcePositions.xy, instanceTargetPositions.xy), instanceWidths);');
  return (0, _shaderUtils.editShader)(brushingVs, 'line color vs', 'vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;', "vec4 color = mix(instanceColors, instanceTargetColors, positions.x) / 255.;" + "vColor = vec4(color.rgb, color.a * opacity);");
}

var LineBrushingLayer =
/*#__PURE__*/
function (_LineLayer) {
  (0, _inherits2["default"])(LineBrushingLayer, _LineLayer);

  function LineBrushingLayer() {
    (0, _classCallCheck2["default"])(this, LineBrushingLayer);
    return (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(LineBrushingLayer).apply(this, arguments));
  }

  (0, _createClass2["default"])(LineBrushingLayer, [{
    key: "getShaders",
    value: function getShaders() {
      var shaders = (0, _get2["default"])((0, _getPrototypeOf2["default"])(LineBrushingLayer.prototype), "getShaders", this).call(this); // const addons = getExtrusion + isPicked + isPtInRange;

      return {
        // ...shaders,
        vs: addBrushingVsShader(shaders.vs),
        fs: shaders.fs,
        // vs: this.props.fp64 ? addons + vs64 : addons + vs,
        modules: shaders.modules.concat(['brushing'])
      };
    }
  }, {
    key: "initializeState",
    value: function initializeState() {
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(LineBrushingLayer.prototype), "initializeState", this).call(this);
      var attributeManager = this.state.attributeManager;
      attributeManager.addInstanced({
        instanceTargetColors: {
          size: 4,
          type: _constants["default"].UNSIGNED_BYTE,
          accessor: 'getTargetColor',
          update: this.calculateInstanceTargetColors
        }
      });
    }
  }, {
    key: "draw",
    value: function draw(_ref) {
      var uniforms = _ref.uniforms;
      var _this$props = this.props,
          brushSource = _this$props.brushSource,
          brushTarget = _this$props.brushTarget,
          brushRadius = _this$props.brushRadius,
          enableBrushing = _this$props.enableBrushing,
          mousePosition = _this$props.mousePosition,
          strokeScale = _this$props.strokeScale;
      (0, _get2["default"])((0, _getPrototypeOf2["default"])(LineBrushingLayer.prototype), "draw", this).call(this, {
        uniforms: _objectSpread({}, uniforms, {
          brushing_uBrushSource: brushSource ? 1 : 0,
          brushing_uBrushTarget: brushTarget ? 1 : 0,
          brushing_uBrushRadius: brushRadius,
          brushing_uEnableBrushing: enableBrushing ? 1 : 0,
          brushing_uStrokeScale: strokeScale,
          brushing_uMousePosition: mousePosition ? new Float32Array(this.unproject(mousePosition)) : defaultProps.mousePosition
        })
      });
    }
  }, {
    key: "calculateInstanceTargetColors",
    value: function calculateInstanceTargetColors(attribute) {
      var _this$props2 = this.props,
          data = _this$props2.data,
          getTargetColor = _this$props2.getTargetColor;
      var value = attribute.value,
          size = attribute.size;
      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;
          var color = getTargetColor(object);
          value[i + 0] = color[0];
          value[i + 1] = color[1];
          value[i + 2] = color[2];
          value[i + 3] = isNaN(color[3]) ? 255 : color[3];
          i += size;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return LineBrushingLayer;
}(_deck.LineLayer);

exports["default"] = LineBrushingLayer;
LineBrushingLayer.layerName = 'LineBrushingLayer';
LineBrushingLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kZWNrZ2wtbGF5ZXJzL2xpbmUtbGF5ZXIvbGluZS1sYXllci5qcyJdLCJuYW1lcyI6WyJkZWZhdWx0UHJvcHMiLCJMaW5lTGF5ZXIiLCJicnVzaFNvdXJjZSIsImJydXNoVGFyZ2V0IiwiZW5hYmxlQnJ1c2hpbmciLCJnZXRXaWR0aCIsImQiLCJzdHJva2VXaWR0aCIsImdldFRhcmdldENvbG9yIiwieCIsImNvbG9yIiwic3Ryb2tlU2NhbGUiLCJicnVzaFJhZGl1cyIsIm1vdXNlUG9zaXRpb24iLCJhZGRCcnVzaGluZ1ZzU2hhZGVyIiwidnMiLCJ0YXJnZXRDb2xvclZzIiwiYnJ1c2hpbmdWcyIsIkxpbmVCcnVzaGluZ0xheWVyIiwic2hhZGVycyIsImZzIiwibW9kdWxlcyIsImNvbmNhdCIsImF0dHJpYnV0ZU1hbmFnZXIiLCJzdGF0ZSIsImFkZEluc3RhbmNlZCIsImluc3RhbmNlVGFyZ2V0Q29sb3JzIiwic2l6ZSIsInR5cGUiLCJHTCIsIlVOU0lHTkVEX0JZVEUiLCJhY2Nlc3NvciIsInVwZGF0ZSIsImNhbGN1bGF0ZUluc3RhbmNlVGFyZ2V0Q29sb3JzIiwidW5pZm9ybXMiLCJwcm9wcyIsImJydXNoaW5nX3VCcnVzaFNvdXJjZSIsImJydXNoaW5nX3VCcnVzaFRhcmdldCIsImJydXNoaW5nX3VCcnVzaFJhZGl1cyIsImJydXNoaW5nX3VFbmFibGVCcnVzaGluZyIsImJydXNoaW5nX3VTdHJva2VTY2FsZSIsImJydXNoaW5nX3VNb3VzZVBvc2l0aW9uIiwiRmxvYXQzMkFycmF5IiwidW5wcm9qZWN0IiwiYXR0cmlidXRlIiwiZGF0YSIsInZhbHVlIiwiaSIsIm9iamVjdCIsImlzTmFOIiwibGF5ZXJOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsSUFBTUEsWUFBWSxxQkFDYkMsZ0JBQVVELFlBREc7QUFFaEI7QUFDQUUsRUFBQUEsV0FBVyxFQUFF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LyBDb3B5cmlnaHQgKGMpIDIwMTkgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0xpbmVMYXllcn0gZnJvbSAnZGVjay5nbCc7XG5pbXBvcnQgR0wgZnJvbSAnQGx1bWEuZ2wvY29uc3RhbnRzJztcbmltcG9ydCB7ZWRpdFNoYWRlcn0gZnJvbSAnZGVja2dsLWxheWVycy9sYXllci11dGlscy9zaGFkZXItdXRpbHMnO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIC4uLkxpbmVMYXllci5kZWZhdWx0UHJvcHMsXG4gIC8vIHNob3cgYXJjIGlmIHNvdXJjZSBpcyBpbiBicnVzaFxuICBicnVzaFNvdXJjZTogdHJ1ZSxcbiAgLy8gc2hvdyBhcmMgaWYgdGFyZ2V0IGlzIGluIGJydXNoXG4gIGJydXNoVGFyZ2V0OiB0cnVlLFxuICBlbmFibGVCcnVzaGluZzogdHJ1ZSxcbiAgZ2V0V2lkdGg6IGQgPT4gZC5zdHJva2VXaWR0aCxcbiAgZ2V0VGFyZ2V0Q29sb3I6IHggPT4geC5jb2xvciB8fCBbMCwgMCwgMCwgMjU1XSxcbiAgc3Ryb2tlU2NhbGU6IDEsXG5cbiAgLy8gYnJ1c2ggcmFkaXVzIGluIG1ldGVyc1xuICBicnVzaFJhZGl1czogMTAwMDAwLFxuICBtb3VzZVBvc2l0aW9uOiBbMCwgMF1cbn07XG5cbmZ1bmN0aW9uIGFkZEJydXNoaW5nVnNTaGFkZXIodnMpIHtcbiAgY29uc3QgdGFyZ2V0Q29sb3JWcyA9IGVkaXRTaGFkZXIoXG4gICAgdnMsXG4gICAgJ2xpbmUgdGFyZ2V0IGNvbG9yIHZzJyxcbiAgICAnYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7JyxcbiAgICAnYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VDb2xvcnM7IGF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlVGFyZ2V0Q29sb3JzOydcbiAgKTtcblxuICBjb25zdCBicnVzaGluZ1ZzID0gZWRpdFNoYWRlcihcbiAgICB0YXJnZXRDb2xvclZzLFxuICAgICdsaW5lIGJydXNoaW5nIHZzJyxcbiAgICAndmVjMiBvZmZzZXQgPSBnZXRFeHRydXNpb25PZmZzZXQodGFyZ2V0Lnh5IC0gc291cmNlLnh5LCBwb3NpdGlvbnMueSwgd2lkdGhQaXhlbHMpOycsXG4gICAgJ3ZlYzIgb2Zmc2V0ID0gYnJ1c2hpbmdfZ2V0RXh0cnVzaW9uT2Zmc2V0KHRhcmdldC54eSAtIHNvdXJjZS54eSwgcG9zaXRpb25zLnksIHByb2plY3RfdVZpZXdwb3J0U2l6ZSwgdmVjNChpbnN0YW5jZVNvdXJjZVBvc2l0aW9ucy54eSwgaW5zdGFuY2VUYXJnZXRQb3NpdGlvbnMueHkpLCBpbnN0YW5jZVdpZHRocyk7J1xuICApO1xuXG4gIHJldHVybiBlZGl0U2hhZGVyKFxuICAgIGJydXNoaW5nVnMsXG4gICAgJ2xpbmUgY29sb3IgdnMnLFxuICAgICd2Q29sb3IgPSB2ZWM0KGluc3RhbmNlQ29sb3JzLnJnYiwgaW5zdGFuY2VDb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjsnLFxuICAgIGB2ZWM0IGNvbG9yID0gbWl4KGluc3RhbmNlQ29sb3JzLCBpbnN0YW5jZVRhcmdldENvbG9ycywgcG9zaXRpb25zLngpIC8gMjU1LjtgICtcbiAgICBgdkNvbG9yID0gdmVjNChjb2xvci5yZ2IsIGNvbG9yLmEgKiBvcGFjaXR5KTtgXG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUJydXNoaW5nTGF5ZXIgZXh0ZW5kcyBMaW5lTGF5ZXIge1xuICBnZXRTaGFkZXJzKCkge1xuICAgIGNvbnN0IHNoYWRlcnMgPSBzdXBlci5nZXRTaGFkZXJzKCk7XG4gICAgLy8gY29uc3QgYWRkb25zID0gZ2V0RXh0cnVzaW9uICsgaXNQaWNrZWQgKyBpc1B0SW5SYW5nZTtcblxuICAgIHJldHVybiB7XG4gICAgICAvLyAuLi5zaGFkZXJzLFxuICAgICAgdnM6IGFkZEJydXNoaW5nVnNTaGFkZXIoc2hhZGVycy52cyksXG4gICAgICBmczogc2hhZGVycy5mcyxcbiAgICAgIC8vIHZzOiB0aGlzLnByb3BzLmZwNjQgPyBhZGRvbnMgKyB2czY0IDogYWRkb25zICsgdnMsXG4gICAgICBtb2R1bGVzOiBzaGFkZXJzLm1vZHVsZXMuY29uY2F0KFsnYnJ1c2hpbmcnXSlcbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIHN1cGVyLmluaXRpYWxpemVTdGF0ZSgpO1xuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgYXR0cmlidXRlTWFuYWdlci5hZGRJbnN0YW5jZWQoe1xuICAgICAgaW5zdGFuY2VUYXJnZXRDb2xvcnM6IHtcbiAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgYWNjZXNzb3I6ICdnZXRUYXJnZXRDb2xvcicsXG4gICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVRhcmdldENvbG9yc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZHJhdyh7dW5pZm9ybXN9KSB7XG4gICAgY29uc3Qge1xuICAgICAgYnJ1c2hTb3VyY2UsXG4gICAgICBicnVzaFRhcmdldCxcbiAgICAgIGJydXNoUmFkaXVzLFxuICAgICAgZW5hYmxlQnJ1c2hpbmcsXG4gICAgICBtb3VzZVBvc2l0aW9uLFxuICAgICAgc3Ryb2tlU2NhbGVcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIHN1cGVyLmRyYXcoe1xuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgLi4udW5pZm9ybXMsXG4gICAgICAgIGJydXNoaW5nX3VCcnVzaFNvdXJjZTogYnJ1c2hTb3VyY2UgPyAxIDogMCxcbiAgICAgICAgYnJ1c2hpbmdfdUJydXNoVGFyZ2V0OiBicnVzaFRhcmdldCA/IDEgOiAwLFxuICAgICAgICBicnVzaGluZ191QnJ1c2hSYWRpdXM6IGJydXNoUmFkaXVzLFxuICAgICAgICBicnVzaGluZ191RW5hYmxlQnJ1c2hpbmc6IGVuYWJsZUJydXNoaW5nID8gMSA6IDAsXG4gICAgICAgIGJydXNoaW5nX3VTdHJva2VTY2FsZTogc3Ryb2tlU2NhbGUsXG4gICAgICAgIGJydXNoaW5nX3VNb3VzZVBvc2l0aW9uOiBtb3VzZVBvc2l0aW9uXG4gICAgICAgICAgPyBuZXcgRmxvYXQzMkFycmF5KHRoaXMudW5wcm9qZWN0KG1vdXNlUG9zaXRpb24pKVxuICAgICAgICAgIDogZGVmYXVsdFByb3BzLm1vdXNlUG9zaXRpb25cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluc3RhbmNlVGFyZ2V0Q29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IHtkYXRhLCBnZXRUYXJnZXRDb2xvcn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZ2V0VGFyZ2V0Q29sb3Iob2JqZWN0KTtcbiAgICAgIHZhbHVlW2kgKyAwXSA9IGNvbG9yWzBdO1xuICAgICAgdmFsdWVbaSArIDFdID0gY29sb3JbMV07XG4gICAgICB2YWx1ZVtpICsgMl0gPSBjb2xvclsyXTtcbiAgICAgIHZhbHVlW2kgKyAzXSA9IGlzTmFOKGNvbG9yWzNdKSA/IDI1NSA6IGNvbG9yWzNdO1xuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxufVxuXG5MaW5lQnJ1c2hpbmdMYXllci5sYXllck5hbWUgPSAnTGluZUJydXNoaW5nTGF5ZXInO1xuTGluZUJydXNoaW5nTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19