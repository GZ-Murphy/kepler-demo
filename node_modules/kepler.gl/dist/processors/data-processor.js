"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processCsvData = processCsvData;
exports.parseRowsByFields = parseRowsByFields;
exports.getSampleForTypeAnalyze = getSampleForTypeAnalyze;
exports.parseCsvRowsByFieldType = parseCsvRowsByFieldType;
exports.getFieldsFromData = getFieldsFromData;
exports.renameDuplicateFields = renameDuplicateFields;
exports.analyzerTypeToFieldType = analyzerTypeToFieldType;
exports.processRowObject = processRowObject;
exports.processGeojson = processGeojson;
exports.formatCsv = formatCsv;
exports.validateInputData = validateInputData;
exports.processKeplerglJSON = processKeplerglJSON;
exports.Processors = exports.PARSE_FIELD_VALUE_FROM_STRING = exports.ACCEPTED_ANALYZER_TYPES = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _d3Dsv = require("d3-dsv");

var _d3Array = require("d3-array");

var _window = require("global/window");

var _assert = _interopRequireDefault(require("assert"));

var _typeAnalyzer = require("type-analyzer");

var _geojsonNormalize = _interopRequireDefault(require("@mapbox/geojson-normalize"));

var _defaultSettings = require("../constants/default-settings");

var _dataUtils = require("../utils/data-utils");

var _schemas = _interopRequireDefault(require("../schemas"));

var _userGuides = require("../constants/user-guides");

var _utils = require("../utils/utils");

var _PARSE_FIELD_VALUE_FR;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var ACCEPTED_ANALYZER_TYPES = [_typeAnalyzer.DATA_TYPES.DATE, _typeAnalyzer.DATA_TYPES.TIME, _typeAnalyzer.DATA_TYPES.DATETIME, _typeAnalyzer.DATA_TYPES.NUMBER, _typeAnalyzer.DATA_TYPES.INT, _typeAnalyzer.DATA_TYPES.FLOAT, _typeAnalyzer.DATA_TYPES.BOOLEAN, _typeAnalyzer.DATA_TYPES.STRING, _typeAnalyzer.DATA_TYPES.GEOMETRY, _typeAnalyzer.DATA_TYPES.GEOMETRY_FROM_STRING, _typeAnalyzer.DATA_TYPES.PAIR_GEOMETRY_FROM_STRING, _typeAnalyzer.DATA_TYPES.ZIPCODE, _typeAnalyzer.DATA_TYPES.ARRAY, _typeAnalyzer.DATA_TYPES.OBJECT]; // if any of these value occurs in csv, parse it to null;

exports.ACCEPTED_ANALYZER_TYPES = ACCEPTED_ANALYZER_TYPES;
var CSV_NULLS = ['', 'null', 'NULL', 'Null', 'NaN', '\N'];
var IGNORE_DATA_TYPES = Object.keys(_typeAnalyzer.DATA_TYPES).filter(function (type) {
  return !ACCEPTED_ANALYZER_TYPES.includes(type);
});
var PARSE_FIELD_VALUE_FROM_STRING = (_PARSE_FIELD_VALUE_FR = {}, (0, _defineProperty2["default"])(_PARSE_FIELD_VALUE_FR, _defaultSettings.ALL_FIELD_TYPES["boolean"], {
  valid: function valid(d) {
    return typeof d === 'boolean';
  },
  parse: function parse(d) {
    return d === 'true' || d === 'True' || d === '1';
  }
}), (0, _defineProperty2["default"])(_PARSE_FIELD_VALUE_FR, _defaultSettings.ALL_FIELD_TYPES.integer, {
  valid: function valid(d) {
    return parseInt(d, 10) === d;
  },
  parse: function parse(d) {
    return parseInt(d, 10);
  }
}), (0, _defineProperty2["default"])(_PARSE_FIELD_VALUE_FR, _defaultSettings.ALL_FIELD_TYPES.timestamp, {
  valid: function valid(d, field) {
    return ['x', 'X'].includes(field.format) ? typeof d === 'number' : typeof d === 'string';
  },
  parse: function parse(d, field) {
    return ['x', 'X'].includes(field.format) ? Number(d) : d;
  }
}), (0, _defineProperty2["default"])(_PARSE_FIELD_VALUE_FR, _defaultSettings.ALL_FIELD_TYPES.real, {
  valid: function valid(d) {
    return parseFloat(d) === d;
  },
  parse: parseFloat
}), _PARSE_FIELD_VALUE_FR);
/**
 * Process csv data, output a data object with `{fields: [], rows: []}`.
 * The data object can be wrapped in a `dataset` and pass to [`addDataToMap`](../actions/actions.md#adddatatomap)
 * @param {string} rawData raw csv string
 * @returns {Object} data object `{fields: [], rows: []}`
 * @public
 * @example
 * import {processCsvData} from 'kepler.gl/processors';
 *
 * const testData = `gps_data.utc_timestamp,gps_data.lat,gps_data.lng,gps_data.types,epoch,has_result,id,time,begintrip_ts_utc,begintrip_ts_local,date
 * 2016-09-17 00:09:55,29.9900937,31.2590542,driver_analytics,1472688000000,False,1,2016-09-23T00:00:00.000Z,2016-10-01 09:41:39+00:00,2016-10-01 09:41:39+00:00,2016-09-23
 * 2016-09-17 00:10:56,29.9927699,31.2461142,driver_analytics,1472688000000,False,2,2016-09-23T00:00:00.000Z,2016-10-01 09:46:37+00:00,2016-10-01 16:46:37+00:00,2016-09-23
 * 2016-09-17 00:11:56,29.9907261,31.2312742,driver_analytics,1472688000000,False,3,2016-09-23T00:00:00.000Z,,,2016-09-23
 * 2016-09-17 00:12:58,29.9870074,31.2175827,driver_analytics,1472688000000,False,4,2016-09-23T00:00:00.000Z,,,2016-09-23`
 *
 * const dataset = {
 *  info: {id: 'test_data', label: 'My Csv'},
 *  data: processCsvData(testData)
 * };
 *
 * dispatch(addDataToMap({
 *  datasets: [dataset],
 *  options: {centerMap: true, readOnly: true}
 * }));
 */

exports.PARSE_FIELD_VALUE_FROM_STRING = PARSE_FIELD_VALUE_FROM_STRING;

function processCsvData(rawData) {
  // here we assume the csv file that people uploaded will have first row
  // as name of the column
  // TODO: add a alert at upload csv to remind define first row
  var result = (0, _d3Dsv.csvParseRows)(rawData);

  if (!Array.isArray(result) || result.length < 2) {
    // looks like an empty file, throw error to be catch
    throw new Error('Read File Failed: CSV is empty');
  }

  var _result = (0, _toArray2["default"])(result),
      headerRow = _result[0],
      rows = _result.slice(1);

  cleanUpFalsyCsvValue(rows); // No need to run type detection on every data point
  // here we get a list of none null values to run analyze on

  var sample = getSampleForTypeAnalyze({
    fields: headerRow,
    allData: rows
  });
  var fields = getFieldsFromData(sample, headerRow);
  var parsedRows = parseRowsByFields(rows, fields);
  return {
    fields: fields,
    rows: parsedRows
  };
}
/**
 * Parse rows of csv by analyzed field types. So that `'1'` -> `1`, `'True'` -> `true`
 * @param {Array<Array>} rows
 * @param {Array<Object} fields
 */


function parseRowsByFields(rows, fields) {
  // Edit rows in place
  var geojsonFieldIdx = fields.findIndex(function (f) {
    return f.name === '_geojson';
  });
  fields.forEach(parseCsvRowsByFieldType.bind(null, rows, geojsonFieldIdx));
  return rows;
}
/**
 * Getting sample data for analyzing field type.
 *
 * @param {Array<string>} fields an array of field names
 * @param {Array<Array>} allData
 * @param {Array} sampleCount
 * @returns {Array} formatted fields
 */


function getSampleForTypeAnalyze(_ref) {
  var fields = _ref.fields,
      allData = _ref.allData,
      _ref$sampleCount = _ref.sampleCount,
      sampleCount = _ref$sampleCount === void 0 ? 50 : _ref$sampleCount;
  var total = Math.min(sampleCount, allData.length); // const fieldOrder = fields.map(f => f.name);

  var sample = (0, _d3Array.range)(0, total, 1).map(function (d) {
    return {};
  }); // collect sample data for each field

  fields.forEach(function (field, fieldIdx) {
    // data counter
    var i = 0; // sample counter

    var j = 0;

    while (j < total) {
      if (i >= allData.length) {
        // if depleted data pool
        sample[j][field] = null;
        j++;
      } else if ((0, _dataUtils.notNullorUndefined)(allData[i][fieldIdx])) {
        sample[j][field] = allData[i][fieldIdx];
        j++;
        i++;
      } else {
        i++;
      }
    }
  });
  return sample;
}
/**
 * Convert falsy value in csv including `'', 'null', 'NULL', 'Null', 'NaN'` to `null`,
 * so that type-analyzer won't detect it as string
 *
 * @param {Array<Array>} rows
 */


function cleanUpFalsyCsvValue(rows) {
  for (var i = 0; i < rows.length; i++) {
    for (var j = 0; j < rows[i].length; j++) {
      // analyzer will set any fields to 'string' if there are empty values
      // which will be parsed as '' by d3.csv
      // here we parse empty data as null
      // TODO: create warning when deltect `CSV_NULLS` in the data
      if (!rows[i][j] || CSV_NULLS.includes(rows[i][j])) {
        rows[i][j] = null;
      }
    }
  }
}
/**
 * Process uploaded csv file to parse value by field type
 *
 * @param {Array<Array>} rows
 * @param {Object} field
 * @param {Number} i
 * @returns {void}
 */


function parseCsvRowsByFieldType(rows, geoFieldIdx, field, i) {
  var parser = PARSE_FIELD_VALUE_FROM_STRING[field.type];

  if (parser) {
    // check first not null value of it's already parsed
    var first = rows.find(function (r) {
      return (0, _dataUtils.notNullorUndefined)(r[i]);
    });

    if (!first || parser.valid(first[i], field)) {
      return;
    }

    rows.forEach(function (row) {
      // parse string value based on field type
      if (row[i] !== null) {
        row[i] = parser.parse(row[i], field);

        if (geoFieldIdx > -1 && row[geoFieldIdx] && row[geoFieldIdx].properties) {
          row[geoFieldIdx].properties[field.name] = row[i];
        }
      }
    });
  }
}
/**
 * Analyze field types from data in `string` format, e.g. uploaded csv.
 * Assign `type`, `tableFieldIndex` and `format` (timestamp only) to each field
 *
 * @param {Array<Object>} data array of row object
 * @param {Array} fieldOrder array of field names as string
 * @returns {Array<Object>} formatted fields
 * @public
 * @example
 *
 * import {getFieldsFromData} from 'kepler.gl/processors';
 * const data = [{
 *   time: '2016-09-17 00:09:55',
 *   value: '4',
 *   surge: '1.2',
 *   isTrip: 'true',
 *   zeroOnes: '0'
 * }, {
 *   time: '2016-09-17 00:30:08',
 *   value: '3',
 *   surge: null,
 *   isTrip: 'false',
 *   zeroOnes: '1'
 * }, {
 *   time: null,
 *   value: '2',
 *   surge: '1.3',
 *   isTrip: null,
 *   zeroOnes: '1'
 * }];
 *
 * const fieldOrder = ['time', 'value', 'surge', 'isTrip', 'zeroOnes'];
 * const fields = getFieldsFromData(data, fieldOrder);
 * // fields = [
 * // {name: 'time', format: 'YYYY-M-D H:m:s', tableFieldIndex: 1, type: 'timestamp'},
 * // {name: 'value', format: '', tableFieldIndex: 4, type: 'integer'},
 * // {name: 'surge', format: '', tableFieldIndex: 5, type: 'real'},
 * // {name: 'isTrip', format: '', tableFieldIndex: 6, type: 'boolean'},
 * // {name: 'zeroOnes', format: '', tableFieldIndex: 7, type: 'integer'}];
 *
 */


function getFieldsFromData(data, fieldOrder) {
  // add a check for epoch timestamp
  var metadata = _typeAnalyzer.Analyzer.computeColMeta(data, [{
    regex: /.*geojson|all_points/g,
    dataType: 'GEOMETRY'
  }], {
    ignoredDataTypes: IGNORE_DATA_TYPES
  });

  var _renameDuplicateField = renameDuplicateFields(fieldOrder),
      fieldByIndex = _renameDuplicateField.fieldByIndex;

  var result = fieldOrder.reduce(function (orderedArray, field, index) {
    var name = fieldByIndex[index];
    var fieldMeta = metadata.find(function (m) {
      return m.key === field;
    });

    var _ref2 = fieldMeta || {},
        type = _ref2.type,
        format = _ref2.format;

    orderedArray[index] = {
      name: name,
      format: format,
      tableFieldIndex: index + 1,
      type: analyzerTypeToFieldType(type)
    };
    return orderedArray;
  }, []);
  return result;
}
/**
 * pass in an array of field names, rename duplicated one
 * and return a map from old field index to new name
 *
 * @param {Array} fieldOrder
 * @returns {Object} new field name by index
 */


function renameDuplicateFields(fieldOrder) {
  return fieldOrder.reduce(function (accu, field, i) {
    var allNames = accu.allNames;
    var fieldName = field; // add a counter to duplicated names

    if (allNames.includes(field)) {
      var counter = 0;

      while (allNames.includes("".concat(field, "-").concat(counter))) {
        counter++;
      }

      fieldName = "".concat(field, "-").concat(counter);
    }

    accu.fieldByIndex[i] = fieldName;
    accu.allNames.push(fieldName);
    return accu;
  }, {
    allNames: [],
    fieldByIndex: {}
  });
}
/**
 * Convert type-analyzer output to kepler.gl field types
 *
 * @param {string} aType
 * @returns {string} corresponding type in `ALL_FIELD_TYPES`
 */

/* eslint-disable complexity */


function analyzerTypeToFieldType(aType) {
  var DATE = _typeAnalyzer.DATA_TYPES.DATE,
      TIME = _typeAnalyzer.DATA_TYPES.TIME,
      DATETIME = _typeAnalyzer.DATA_TYPES.DATETIME,
      NUMBER = _typeAnalyzer.DATA_TYPES.NUMBER,
      INT = _typeAnalyzer.DATA_TYPES.INT,
      FLOAT = _typeAnalyzer.DATA_TYPES.FLOAT,
      BOOLEAN = _typeAnalyzer.DATA_TYPES.BOOLEAN,
      STRING = _typeAnalyzer.DATA_TYPES.STRING,
      GEOMETRY = _typeAnalyzer.DATA_TYPES.GEOMETRY,
      GEOMETRY_FROM_STRING = _typeAnalyzer.DATA_TYPES.GEOMETRY_FROM_STRING,
      PAIR_GEOMETRY_FROM_STRING = _typeAnalyzer.DATA_TYPES.PAIR_GEOMETRY_FROM_STRING,
      ZIPCODE = _typeAnalyzer.DATA_TYPES.ZIPCODE,
      ARRAY = _typeAnalyzer.DATA_TYPES.ARRAY,
      OBJECT = _typeAnalyzer.DATA_TYPES.OBJECT; // TODO: un recognized types
  // CURRENCY PERCENT NONE

  switch (aType) {
    case DATE:
      return _defaultSettings.ALL_FIELD_TYPES.date;

    case TIME:
    case DATETIME:
      return _defaultSettings.ALL_FIELD_TYPES.timestamp;

    case NUMBER:
    case FLOAT:
      return _defaultSettings.ALL_FIELD_TYPES.real;

    case INT:
      return _defaultSettings.ALL_FIELD_TYPES.integer;

    case BOOLEAN:
      return _defaultSettings.ALL_FIELD_TYPES["boolean"];

    case GEOMETRY:
    case GEOMETRY_FROM_STRING:
    case PAIR_GEOMETRY_FROM_STRING:
    case ARRAY:
    case OBJECT:
      // TODO: create a new data type for objects and arrays
      return _defaultSettings.ALL_FIELD_TYPES.geojson;

    case STRING:
    case ZIPCODE:
      return _defaultSettings.ALL_FIELD_TYPES.string;

    default:
      _window.console.warn("Unsupported analyzer type: ".concat(aType));

      return _defaultSettings.ALL_FIELD_TYPES.string;
  }
}
/* eslint-enable complexity */

/**
 * Process data where each row is an object, output can be passed to [`addDataToMap`](../actions/actions.md#adddatatomap)
 * @param {Array<Object>} rawData an array of row object, each object should have the same number of keys
 * @returns {Object} dataset containing `fields` and `rows`
 * @public
 * @example
 * import {addDataToMap} from 'kepler.gl/actions';
 * import {processRowObject} from 'kepler.gl/processors';
 *
 * const data = [
 *  {lat: 31.27, lng: 127.56, value: 3},
 *  {lat: 31.22, lng: 126.26, value: 1}
 * ];
 *
 * dispatch(addDataToMap({
 *  datasets: {
 *    info: {label: 'My Data', id: 'my_data'},
 *    data: processRowObject(data)
 *  }
 * }));
 */


function processRowObject(rawData) {
  if (!Array.isArray(rawData) || !rawData.length) {
    return null;
  }

  var keys = Object.keys(rawData[0]);
  var rows = rawData.map(function (d) {
    return keys.map(function (key) {
      return d[key];
    });
  }); // pick samples

  var sampleData = (0, _dataUtils.getSampleData)(rawData, 500);
  var fields = getFieldsFromData(sampleData, keys);
  var parsedRows = parseRowsByFields(rows, fields);
  return {
    fields: fields,
    rows: parsedRows
  };
}
/**
 * Process GeoJSON [`FeatureCollection`](http://wiki.geojson.org/GeoJSON_draft_version_6#FeatureCollection),
 * output a data object with `{fields: [], rows: []}`.
 * The data object can be wrapped in a `dataset` and pass to [`addDataToMap`](../actions/actions.md#adddatatomap)
 *
 * @param {Object} rawData raw geojson feature collection
 * @returns {Object} dataset containing `fields` and `rows`
 * @public
 * @example
 * import {addDataToMap} from 'kepler.gl/actions';
 * import {processGeojson} from 'kepler.gl/processors';
 *
 * const geojson = {
 * 	"type" : "FeatureCollection",
 * 	"features" : [{
 * 		"type" : "Feature",
 * 		"properties" : {
 * 			"capacity" : "10",
 * 			"type" : "U-Rack"
 * 		},
 * 		"geometry" : {
 * 			"type" : "Point",
 * 			"coordinates" : [ -71.073283, 42.417500 ]
 * 		}
 * 	}]
 * };
 *
 * dispatch(addDataToMap({
 *  datasets: {
 *    info: {
 *      label: 'Sample Taxi Trips in New York City',
 *      id: 'test_trip_data'
 *    },
 *    data: processGeojson(geojson)
 *  }
 * }));
 */


function processGeojson(rawData) {
  var normalizedGeojson = (0, _geojsonNormalize["default"])(rawData);

  if (!normalizedGeojson || !Array.isArray(normalizedGeojson.features)) {
    var error = new Error("Read File Failed: File is not a valid GeoJSON. Read more about [supported file format](".concat(_userGuides.GUIDES_FILE_FORMAT, ")"));
    throw error; // fail to normalize geojson
  } // getting all feature fields


  var allData = normalizedGeojson.features.reduce(function (accu, f, i) {
    if (f.geometry) {
      accu.push(_objectSpread({
        // add feature to _geojson field
        _geojson: f
      }, f.properties || {}));
    }

    return accu;
  }, []); // get all the field

  var fields = allData.reduce(function (prev, curr) {
    Object.keys(curr).forEach(function (key) {
      if (!prev.includes(key)) {
        prev.push(key);
      }
    });
    return prev;
  }, []); // make sure each feature has exact same fields

  allData.forEach(function (d) {
    fields.forEach(function (f) {
      if (!(f in d)) {
        d[f] = null;
      }
    });
  });
  var processRow = processRowObject(allData);
  return processRow;
}
/**
 * On export data to csv
 * @param {Array<Array>} data `dataset.allData` or filtered data `dataset.data`
 * @param {Array<Object>} fields `dataset.fields`
 * @returns {string} csv string
 */


function formatCsv(data, fields) {
  var columns = fields.map(function (f) {
    return f.name;
  });
  var formattedData = [columns]; // parse geojson object as string

  data.forEach(function (row) {
    formattedData.push(row.map(function (d, i) {
      return (0, _dataUtils.parseFieldValue)(d, fields[i].type);
    }));
  });
  return (0, _d3Dsv.csvFormatRows)(formattedData);
}
/**
 * Validate input data, adding missing field types, rename duplicate columns
 * @param {Object} data dataset.data
 * @param {Array<Object>} data.fields an array of fields
 * @param {Array<Object>} data.rows an array of data rows
 * @returns {{allData: Array, fields: Array}}
 */


function validateInputData(data) {
  if (!(0, _utils.isPlainObject)(data)) {
    (0, _assert["default"])('addDataToMap Error: dataset.data cannot be null');
    return null;
  } else if (!Array.isArray(data.fields)) {
    (0, _assert["default"])('addDataToMap Error: expect dataset.data.fields to be an array');
    return null;
  } else if (!Array.isArray(data.rows)) {
    (0, _assert["default"])('addDataToMap Error: expect dataset.data.rows to be an array');
    return null;
  }

  var fields = data.fields,
      rows = data.rows; // check if all fields has name, format and type

  var allValid = fields.every(function (f, i) {
    if (!(0, _utils.isPlainObject)(f)) {
      (0, _assert["default"])("fields needs to be an array of object, but find ".concat((0, _typeof2["default"])(f)));
      fields[i] = {};
    }

    if (!f.name) {
      (0, _assert["default"])("field.name is required but missing in ".concat(JSON.stringify(f))); // assign a name

      fields[i].name = "column_".concat(i);
    }

    if (!_defaultSettings.ALL_FIELD_TYPES[f.type]) {
      (0, _assert["default"])("unknown field type ".concat(f.type));
      return false;
    } // check time format is correct based on first 10 not empty element


    if (f.type === _defaultSettings.ALL_FIELD_TYPES.timestamp) {
      var sample = findNonEmptyRowsAtField(rows, i, 10).map(function (r) {
        return {
          ts: r[i]
        };
      });

      var analyzedType = _typeAnalyzer.Analyzer.computeColMeta(sample)[0];

      return analyzedType.category === 'TIME' && analyzedType.format === f.format;
    }

    return true;
  });

  if (allValid) {
    return {
      rows: rows,
      fields: fields
    };
  } // if any field has missing type, recalculate it for everyone
  // because we simply lost faith in humanity


  var sampleData = getSampleForTypeAnalyze({
    fields: fields.map(function (f) {
      return f.name;
    }),
    allData: rows
  });
  var fieldOrder = fields.map(function (f) {
    return f.name;
  });
  var meta = getFieldsFromData(sampleData, fieldOrder);
  var updatedFields = fields.map(function (f, i) {
    return _objectSpread({}, f, {
      type: meta[i].type,
      format: meta[i].format
    });
  });
  return {
    fields: updatedFields,
    rows: rows
  };
}

function findNonEmptyRowsAtField(rows, fieldIdx, total) {
  var sample = [];
  var i = 0;

  while (sample.length < total && i < rows.length) {
    if ((0, _dataUtils.notNullorUndefined)(rows[i][fieldIdx])) {
      sample.push(rows[i]);
    }

    i++;
  }

  return sample;
}
/**
 * Process saved kepler.gl json to be pass to [`addDataToMap`](../actions/actions.md#adddatatomap).
 * The json object should contain `datasets` and `config`.
 * @param {Object} rawData
 * @param {Array} rawData.datasets
 * @param {Object} rawData.config
 * @returns {Object} datasets and config `{datasets: {}, config: {}}`
 * @public
 * @example
 * import {addDataToMap} from 'kepler.gl/actions';
 * import {processKeplerglJSON} from 'kepler.gl/processors';
 *
 * dispatch(addDataToMap(processKeplerglJSON(keplerGlJson)));
 */


function processKeplerglJSON(rawData) {
  return rawData ? _schemas["default"].load(rawData.datasets, rawData.config) : null;
}

var Processors = {
  processGeojson: processGeojson,
  processCsvData: processCsvData,
  processRowObject: processRowObject,
  processKeplerglJSON: processKeplerglJSON,
  analyzerTypeToFieldType: analyzerTypeToFieldType,
  getFieldsFromData: getFieldsFromData,
  parseCsvRowsByFieldType: parseCsvRowsByFieldType,
  formatCsv: formatCsv
};
exports.Processors = Processors;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wcm9jZXNzb3JzL2RhdGEtcHJvY2Vzc29yLmpzIl0sIm5hbWVzIjpbIkFDQ0VQVEVEX0FOQUxZWkVSX1RZUEVTIiwiQW5hbHl6ZXJEQVRBX1RZUEVTIiwiREFURSIsIlRJTUUiLCJEQVRFVElNRSIsIk5VTUJFUiIsIklOVCIsIkZMT0FUIiwiQk9PTEVBTiIsIlNUUklORyIsIkdFT01FVFJZIiwiR0VPTUVUUllfRlJPTV9TVFJJTkciLCJQQUlSX0dFT01FVFJZX0ZST01fU1RSSU5HIiwiWklQQ09ERSIsIkFSUkFZIiwiT0JKRUNUIiwiQ1NWX05VTExTIiwiSUdOT1JFX0RBVEFfVFlQRVMiLCJPYmplY3QiLCJrZXlzIiwiZmlsdGVyIiwidHlwZSIsImluY2x1ZGVzIiwiUEFSU0VfRklFTERfVkFMVUVfRlJPTV9TVFJJTkciLCJBTExfRklFTERfVFlQRVMiLCJ2YWxpZCIsImQiLCJwYXJzZSIsImludGVnZXIiLCJwYXJzZUludCIsInRpbWVzdGFtcCIsImZpZWxkIiwiZm9ybWF0IiwiTnVtYmVyIiwicmVhbCIsInBhcnNlRmxvYXQiLCJwcm9jZXNzQ3N2RGF0YSIsInJhd0RhdGEiLCJyZXN1bHQiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJFcnJvciIsImhlYWRlclJvdyIsInJvd3MiLCJjbGVhblVwRmFsc3lDc3ZWYWx1ZSIsInNhbXBsZSIsImdldFNhbXBsZUZvclR5cGVBbmFseXplIiwiZmllbGRzIiwiYWxsRGF0YSIsImdldEZpZWxkc0Zyb21EYXRhIiwicGFyc2VkUm93cyIsInBhcnNlUm93c0J5RmllbGRzIiwiZ2VvanNvbkZpZWxkSWR4IiwiZmluZEluZGV4IiwiZiIsIm5hbWUiLCJmb3JFYWNoIiwicGFyc2VDc3ZSb3dzQnlGaWVsZFR5cGUiLCJiaW5kIiwic2FtcGxlQ291bnQiLCJ0b3RhbCIsIk1hdGgiLCJtaW4iLCJtYXAiLCJmaWVsZElkeCIsImkiLCJqIiwiZ2VvRmllbGRJZHgiLCJwYXJzZXIiLCJmaXJzdCIsImZpbmQiLCJyIiwicm93IiwicHJvcGVydGllcyIsImRhdGEiLCJmaWVsZE9yZGVyIiwibWV0YWRhdGEiLCJBbmFseXplciIsImNvbXB1dGVDb2xNZXRhIiwicmVnZXgiLCJkYXRhVHlwZSIsImlnbm9yZWREYXRhVHlwZXMiLCJyZW5hbWVEdXBsaWNhdGVGaWVsZHMiLCJmaWVsZEJ5SW5kZXgiLCJyZWR1Y2UiLCJvcmRlcmVkQXJyYXkiLCJpbmRleCIsImZpZWxkTWV0YSIsIm0iLCJrZXkiLCJ0YWJsZUZpZWxkSW5kZXgiLCJhbmFseXplclR5cGVUb0ZpZWxkVHlwZSIsImFjY3UiLCJhbGxOYW1lcyIsImZpZWxkTmFtZSIsImNvdW50ZXIiLCJwdXNoIiwiYVR5cGUiLCJkYXRlIiwiZ2VvanNvbiIsInN0cmluZyIsImdsb2JhbENvbnNvbGUiLCJ3YXJuIiwicHJvY2Vzc1Jvd09iamVjdCIsInNhbXBsZURhdGEiLCJwcm9jZXNzR2VvanNvbiIsIm5vcm1hbGl6ZWRHZW9qc29uIiwiZmVhdHVyZXMiLCJlcnJvciIsIkdVSURFU19GSUxFX0ZPUk1BVCIsImdlb21ldHJ5IiwiX2dlb2pzb24iLCJwcmV2IiwiY3VyciIsInByb2Nlc3NSb3ciLCJmb3JtYXRDc3YiLCJjb2x1bW5zIiwiZm9ybWF0dGVkRGF0YSIsInZhbGlkYXRlSW5wdXREYXRhIiwiYWxsVmFsaWQiLCJldmVyeSIsIkpTT04iLCJzdHJpbmdpZnkiLCJmaW5kTm9uRW1wdHlSb3dzQXRGaWVsZCIsInRzIiwiYW5hbHl6ZWRUeXBlIiwiY2F0ZWdvcnkiLCJtZXRhIiwidXBkYXRlZEZpZWxkcyIsInByb2Nlc3NLZXBsZXJnbEpTT04iLCJLZXBsZXJHbFNjaGVtYSIsImxvYWQiLCJkYXRhc2V0cyIsImNvbmZpZyIsIlByb2Nlc3NvcnMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFLQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7QUFFTyxJQUFN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QSxPQUFPLEdBQUc4RixvQkFBZUMsSUFBZixDQUFvQi9GLE9BQU8sQ0FBQ2dHLFFBQTVCLEVBQXNDaEcsT0FBTyxDQUFDaUcsTUFBOUMsQ0FBSCxHQUEyRCxJQUF6RTtBQUNEOztBQUVNLElBQU1DLFVBQVUsR0FBRztBQUN4QjdCLEVBQUFBLGNBQWMsRUFBZEEsY0FEd0I7QUFFeEJ0RSxFQUFBQSxjQUFjLEVBQWRBLGNBRndCO0FBR3hCb0UsRUFBQUEsZ0JBQWdCLEVBQWhCQSxnQkFId0I7QUFJeEIwQixFQUFBQSxtQkFBbUIsRUFBbkJBLG1CQUp3QjtBQUt4QnRDLEVBQUFBLHVCQUF1QixFQUF2QkEsdUJBTHdCO0FBTXhCMUMsRUFBQUEsaUJBQWlCLEVBQWpCQSxpQkFOd0I7QUFPeEJRLEVBQUFBLHVCQUF1QixFQUF2QkEsdUJBUHdCO0FBUXhCMEQsRUFBQUEsU0FBUyxFQUFUQTtBQVJ3QixDQUFuQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxOSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Y3N2UGFyc2VSb3dzLCBjc3ZGb3JtYXRSb3dzfSBmcm9tICdkMy1kc3YnO1xuaW1wb3J0IHtyYW5nZX0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHtjb25zb2xlIGFzIGdsb2JhbENvbnNvbGV9IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHtBbmFseXplciwgREFUQV9UWVBFUyBhcyBBbmFseXplckRBVEFfVFlQRVN9IGZyb20gJ3R5cGUtYW5hbHl6ZXInO1xuaW1wb3J0IG5vcm1hbGl6ZSBmcm9tICdAbWFwYm94L2dlb2pzb24tbm9ybWFsaXplJztcbmltcG9ydCB7QUxMX0ZJRUxEX1RZUEVTfSBmcm9tICdjb25zdGFudHMvZGVmYXVsdC1zZXR0aW5ncyc7XG5pbXBvcnQge1xuICBub3ROdWxsb3JVbmRlZmluZWQsXG4gIHBhcnNlRmllbGRWYWx1ZSxcbiAgZ2V0U2FtcGxlRGF0YVxufSBmcm9tICd1dGlscy9kYXRhLXV0aWxzJztcbmltcG9ydCBLZXBsZXJHbFNjaGVtYSBmcm9tICdzY2hlbWFzJztcbmltcG9ydCB7R1VJREVTX0ZJTEVfRk9STUFUfSBmcm9tICdjb25zdGFudHMvdXNlci1ndWlkZXMnO1xuaW1wb3J0IHtpc1BsYWluT2JqZWN0fSBmcm9tICd1dGlscy91dGlscyc7XG5cbmV4cG9ydCBjb25zdCBBQ0NFUFRFRF9BTkFMWVpFUl9UWVBFUyA9IFtcbiAgQW5hbHl6ZXJEQVRBX1RZUEVTLkRBVEUsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5USU1FLFxuICBBbmFseXplckRBVEFfVFlQRVMuREFURVRJTUUsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5OVU1CRVIsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5JTlQsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5GTE9BVCxcbiAgQW5hbHl6ZXJEQVRBX1RZUEVTLkJPT0xFQU4sXG4gIEFuYWx5emVyREFUQV9UWVBFUy5TVFJJTkcsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5HRU9NRVRSWSxcbiAgQW5hbHl6ZXJEQVRBX1RZUEVTLkdFT01FVFJZX0ZST01fU1RSSU5HLFxuICBBbmFseXplckRBVEFfVFlQRVMuUEFJUl9HRU9NRVRSWV9GUk9NX1NUUklORyxcbiAgQW5hbHl6ZXJEQVRBX1RZUEVTLlpJUENPREUsXG4gIEFuYWx5emVyREFUQV9UWVBFUy5BUlJBWSxcbiAgQW5hbHl6ZXJEQVRBX1RZUEVTLk9CSkVDVFxuXTtcblxuLy8gaWYgYW55IG9mIHRoZXNlIHZhbHVlIG9jY3VycyBpbiBjc3YsIHBhcnNlIGl0IHRvIG51bGw7XG5jb25zdCBDU1ZfTlVMTFMgPSBbJycsICdudWxsJywgJ05VTEwnLCAnTnVsbCcsICdOYU4nLCAnXFxOJ107XG5cbmNvbnN0IElHTk9SRV9EQVRBX1RZUEVTID0gT2JqZWN0LmtleXMoQW5hbHl6ZXJEQVRBX1RZUEVTKS5maWx0ZXIoXG4gIHR5cGUgPT4gIUFDQ0VQVEVEX0FOQUxZWkVSX1RZUEVTLmluY2x1ZGVzKHR5cGUpXG4pO1xuXG5leHBvcnQgY29uc3QgUEFSU0VfRklFTERfVkFMVUVfRlJPTV9TVFJJTkcgPSB7XG4gIFtBTExfRklFTERfVFlQRVMuYm9vbGVhbl06IHtcbiAgICB2YWxpZDogZCA9PiB0eXBlb2YgZCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHBhcnNlOiBkID0+IGQgPT09ICd0cnVlJyB8fCBkID09PSAnVHJ1ZScgfHwgZCA9PT0gJzEnXG4gIH0sXG4gIFtBTExfRklFTERfVFlQRVMuaW50ZWdlcl06IHtcbiAgICB2YWxpZDogZCA9PiBwYXJzZUludChkLCAxMCkgPT09IGQsXG4gICAgcGFyc2U6IGQgPT4gcGFyc2VJbnQoZCwgMTApXG4gIH0sXG4gIFtBTExfRklFTERfVFlQRVMudGltZXN0YW1wXToge1xuICAgIHZhbGlkOiAoZCwgZmllbGQpID0+XG4gICAgICBbJ3gnLCAnWCddLmluY2x1ZGVzKGZpZWxkLmZvcm1hdClcbiAgICAgICAgPyB0eXBlb2YgZCA9PT0gJ251bWJlcidcbiAgICAgICAgOiB0eXBlb2YgZCA9PT0gJ3N0cmluZycsXG4gICAgcGFyc2U6IChkLCBmaWVsZCkgPT4gKFsneCcsICdYJ10uaW5jbHVkZXMoZmllbGQuZm9ybWF0KSA/IE51bWJlcihkKSA6IGQpXG4gIH0sXG4gIFtBTExfRklFTERfVFlQRVMucmVhbF06IHtcbiAgICB2YWxpZDogZCA9PiBwYXJzZUZsb2F0KGQpID09PSBkLFxuICAgIHBhcnNlOiBwYXJzZUZsb2F0XG4gIH1cbn07XG5cbi8qKlxuICogUHJvY2VzcyBjc3YgZGF0YSwgb3V0cHV0IGEgZGF0YSBvYmplY3Qgd2l0aCBge2ZpZWxkczogW10sIHJvd3M6IFtdfWAuXG4gKiBUaGUgZGF0YSBvYmplY3QgY2FuIGJlIHdyYXBwZWQgaW4gYSBgZGF0YXNldGAgYW5kIHBhc3MgdG8gW2BhZGREYXRhVG9NYXBgXSguLi9hY3Rpb25zL2FjdGlvbnMubWQjYWRkZGF0YXRvbWFwKVxuICogQHBhcmFtIHtzdHJpbmd9IHJhd0RhdGEgcmF3IGNzdiBzdHJpbmdcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRhdGEgb2JqZWN0IGB7ZmllbGRzOiBbXSwgcm93czogW119YFxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7cHJvY2Vzc0NzdkRhdGF9IGZyb20gJ2tlcGxlci5nbC9wcm9jZXNzb3JzJztcbiAqXG4gKiBjb25zdCB0ZXN0RGF0YSA9IGBncHNfZGF0YS51dGNfdGltZXN0YW1wLGdwc19kYXRhLmxhdCxncHNfZGF0YS5sbmcsZ3BzX2RhdGEudHlwZXMsZXBvY2gsaGFzX3Jlc3VsdCxpZCx0aW1lLGJlZ2ludHJpcF90c191dGMsYmVnaW50cmlwX3RzX2xvY2FsLGRhdGVcbiAqIDIwMTYtMDktMTcgMDA6MDk6NTUsMjkuOTkwMDkzNywzMS4yNTkwNTQyLGRyaXZlcl9hbmFseXRpY3MsMTQ3MjY4ODAwMDAwMCxGYWxzZSwxLDIwMTYtMDktMjNUMDA6MDA6MDAuMDAwWiwyMDE2LTEwLTAxIDA5OjQxOjM5KzAwOjAwLDIwMTYtMTAtMDEgMDk6NDE6MzkrMDA6MDAsMjAxNi0wOS0yM1xuICogMjAxNi0wOS0xNyAwMDoxMDo1NiwyOS45OTI3Njk5LDMxLjI0NjExNDIsZHJpdmVyX2FuYWx5dGljcywxNDcyNjg4MDAwMDAwLEZhbHNlLDIsMjAxNi0wOS0yM1QwMDowMDowMC4wMDBaLDIwMTYtMTAtMDEgMDk6NDY6MzcrMDA6MDAsMjAxNi0xMC0wMSAxNjo0NjozNyswMDowMCwyMDE2LTA5LTIzXG4gKiAyMDE2LTA5LTE3IDAwOjExOjU2LDI5Ljk5MDcyNjEsMzEuMjMxMjc0Mixkcml2ZXJfYW5hbHl0aWNzLDE0NzI2ODgwMDAwMDAsRmFsc2UsMywyMDE2LTA5LTIzVDAwOjAwOjAwLjAwMFosLCwyMDE2LTA5LTIzXG4gKiAyMDE2LTA5LTE3IDAwOjEyOjU4LDI5Ljk4NzAwNzQsMzEuMjE3NTgyNyxkcml2ZXJfYW5hbHl0aWNzLDE0NzI2ODgwMDAwMDAsRmFsc2UsNCwyMDE2LTA5LTIzVDAwOjAwOjAwLjAwMFosLCwyMDE2LTA5LTIzYFxuICpcbiAqIGNvbnN0IGRhdGFzZXQgPSB7XG4gKiAgaW5mbzoge2lkOiAndGVzdF9kYXRhJywgbGFiZWw6ICdNeSBDc3YnfSxcbiAqICBkYXRhOiBwcm9jZXNzQ3N2RGF0YSh0ZXN0RGF0YSlcbiAqIH07XG4gKlxuICogZGlzcGF0Y2goYWRkRGF0YVRvTWFwKHtcbiAqICBkYXRhc2V0czogW2RhdGFzZXRdLFxuICogIG9wdGlvbnM6IHtjZW50ZXJNYXA6IHRydWUsIHJlYWRPbmx5OiB0cnVlfVxuICogfSkpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0NzdkRhdGEocmF3RGF0YSkge1xuICAvLyBoZXJlIHdlIGFzc3VtZSB0aGUgY3N2IGZpbGUgdGhhdCBwZW9wbGUgdXBsb2FkZWQgd2lsbCBoYXZlIGZpcnN0IHJvd1xuICAvLyBhcyBuYW1lIG9mIHRoZSBjb2x1bW5cbiAgLy8gVE9ETzogYWRkIGEgYWxlcnQgYXQgdXBsb2FkIGNzdiB0byByZW1pbmQgZGVmaW5lIGZpcnN0IHJvd1xuICBjb25zdCByZXN1bHQgPSBjc3ZQYXJzZVJvd3MocmF3RGF0YSk7XG4gIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHQpIHx8IHJlc3VsdC5sZW5ndGggPCAyKSB7XG4gICAgLy8gbG9va3MgbGlrZSBhbiBlbXB0eSBmaWxlLCB0aHJvdyBlcnJvciB0byBiZSBjYXRjaFxuICAgIHRocm93IG5ldyBFcnJvcignUmVhZCBGaWxlIEZhaWxlZDogQ1NWIGlzIGVtcHR5Jyk7XG4gIH1cblxuICBjb25zdCBbaGVhZGVyUm93LCAuLi5yb3dzXSA9IHJlc3VsdDtcblxuICBjbGVhblVwRmFsc3lDc3ZWYWx1ZShyb3dzKTtcbiAgLy8gTm8gbmVlZCB0byBydW4gdHlwZSBkZXRlY3Rpb24gb24gZXZlcnkgZGF0YSBwb2ludFxuICAvLyBoZXJlIHdlIGdldCBhIGxpc3Qgb2Ygbm9uZSBudWxsIHZhbHVlcyB0byBydW4gYW5hbHl6ZSBvblxuICBjb25zdCBzYW1wbGUgPSBnZXRTYW1wbGVGb3JUeXBlQW5hbHl6ZSh7ZmllbGRzOiBoZWFkZXJSb3csIGFsbERhdGE6IHJvd3N9KTtcblxuICBjb25zdCBmaWVsZHMgPSBnZXRGaWVsZHNGcm9tRGF0YShzYW1wbGUsIGhlYWRlclJvdyk7XG5cbiAgY29uc3QgcGFyc2VkUm93cyA9IHBhcnNlUm93c0J5RmllbGRzKHJvd3MsIGZpZWxkcyk7XG5cbiAgcmV0dXJuIHtmaWVsZHMsIHJvd3M6IHBhcnNlZFJvd3N9O1xufVxuXG4vKipcbiAqIFBhcnNlIHJvd3Mgb2YgY3N2IGJ5IGFuYWx5emVkIGZpZWxkIHR5cGVzLiBTbyB0aGF0IGAnMSdgIC0+IGAxYCwgYCdUcnVlJ2AgLT4gYHRydWVgXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gcm93c1xuICogQHBhcmFtIHtBcnJheTxPYmplY3R9IGZpZWxkc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSb3dzQnlGaWVsZHMocm93cywgZmllbGRzKSB7XG4gIC8vIEVkaXQgcm93cyBpbiBwbGFjZVxuICBjb25zdCBnZW9qc29uRmllbGRJZHggPSBmaWVsZHMuZmluZEluZGV4KGYgPT4gZi5uYW1lID09PSAnX2dlb2pzb24nKTtcbiAgZmllbGRzLmZvckVhY2gocGFyc2VDc3ZSb3dzQnlGaWVsZFR5cGUuYmluZChudWxsLCByb3dzLCBnZW9qc29uRmllbGRJZHgpKTtcblxuICByZXR1cm4gcm93cztcbn1cbi8qKlxuICogR2V0dGluZyBzYW1wbGUgZGF0YSBmb3IgYW5hbHl6aW5nIGZpZWxkIHR5cGUuXG4gKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBmaWVsZHMgYW4gYXJyYXkgb2YgZmllbGQgbmFtZXNcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSBhbGxEYXRhXG4gKiBAcGFyYW0ge0FycmF5fSBzYW1wbGVDb3VudFxuICogQHJldHVybnMge0FycmF5fSBmb3JtYXR0ZWQgZmllbGRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTYW1wbGVGb3JUeXBlQW5hbHl6ZSh7ZmllbGRzLCBhbGxEYXRhLCBzYW1wbGVDb3VudCA9IDUwfSkge1xuICBjb25zdCB0b3RhbCA9IE1hdGgubWluKHNhbXBsZUNvdW50LCBhbGxEYXRhLmxlbmd0aCk7XG4gIC8vIGNvbnN0IGZpZWxkT3JkZXIgPSBmaWVsZHMubWFwKGYgPT4gZi5uYW1lKTtcbiAgY29uc3Qgc2FtcGxlID0gcmFuZ2UoMCwgdG90YWwsIDEpLm1hcChkID0+ICh7fSkpO1xuXG4gIC8vIGNvbGxlY3Qgc2FtcGxlIGRhdGEgZm9yIGVhY2ggZmllbGRcbiAgZmllbGRzLmZvckVhY2goKGZpZWxkLCBmaWVsZElkeCkgPT4ge1xuICAgIC8vIGRhdGEgY291bnRlclxuICAgIGxldCBpID0gMDtcbiAgICAvLyBzYW1wbGUgY291bnRlclxuICAgIGxldCBqID0gMDtcblxuICAgIHdoaWxlIChqIDwgdG90YWwpIHtcbiAgICAgIGlmIChpID49IGFsbERhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIGlmIGRlcGxldGVkIGRhdGEgcG9vbFxuICAgICAgICBzYW1wbGVbal1bZmllbGRdID0gbnVsbDtcbiAgICAgICAgaisrO1xuICAgICAgfSBlbHNlIGlmIChub3ROdWxsb3JVbmRlZmluZWQoYWxsRGF0YVtpXVtmaWVsZElkeF0pKSB7XG4gICAgICAgIHNhbXBsZVtqXVtmaWVsZF0gPSBhbGxEYXRhW2ldW2ZpZWxkSWR4XTtcbiAgICAgICAgaisrO1xuICAgICAgICBpKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc2FtcGxlO1xufVxuXG4vKipcbiAqIENvbnZlcnQgZmFsc3kgdmFsdWUgaW4gY3N2IGluY2x1ZGluZyBgJycsICdudWxsJywgJ05VTEwnLCAnTnVsbCcsICdOYU4nYCB0byBgbnVsbGAsXG4gKiBzbyB0aGF0IHR5cGUtYW5hbHl6ZXIgd29uJ3QgZGV0ZWN0IGl0IGFzIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSByb3dzXG4gKi9cbmZ1bmN0aW9uIGNsZWFuVXBGYWxzeUNzdlZhbHVlKHJvd3MpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3dzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAvLyBhbmFseXplciB3aWxsIHNldCBhbnkgZmllbGRzIHRvICdzdHJpbmcnIGlmIHRoZXJlIGFyZSBlbXB0eSB2YWx1ZXNcbiAgICAgIC8vIHdoaWNoIHdpbGwgYmUgcGFyc2VkIGFzICcnIGJ5IGQzLmNzdlxuICAgICAgLy8gaGVyZSB3ZSBwYXJzZSBlbXB0eSBkYXRhIGFzIG51bGxcbiAgICAgIC8vIFRPRE86IGNyZWF0ZSB3YXJuaW5nIHdoZW4gZGVsdGVjdCBgQ1NWX05VTExTYCBpbiB0aGUgZGF0YVxuICAgICAgaWYgKCFyb3dzW2ldW2pdIHx8IENTVl9OVUxMUy5pbmNsdWRlcyhyb3dzW2ldW2pdKSkge1xuICAgICAgICByb3dzW2ldW2pdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9jZXNzIHVwbG9hZGVkIGNzdiBmaWxlIHRvIHBhcnNlIHZhbHVlIGJ5IGZpZWxkIHR5cGVcbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gcm93c1xuICogQHBhcmFtIHtPYmplY3R9IGZpZWxkXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNzdlJvd3NCeUZpZWxkVHlwZShyb3dzLCBnZW9GaWVsZElkeCwgZmllbGQsIGkpIHtcbiAgY29uc3QgcGFyc2VyID0gUEFSU0VfRklFTERfVkFMVUVfRlJPTV9TVFJJTkdbZmllbGQudHlwZV07XG4gIGlmIChwYXJzZXIpIHtcbiAgICAvLyBjaGVjayBmaXJzdCBub3QgbnVsbCB2YWx1ZSBvZiBpdCdzIGFscmVhZHkgcGFyc2VkXG4gICAgY29uc3QgZmlyc3QgPSByb3dzLmZpbmQociA9PiBub3ROdWxsb3JVbmRlZmluZWQocltpXSkpO1xuICAgIGlmICghZmlyc3QgfHwgcGFyc2VyLnZhbGlkKGZpcnN0W2ldLCBmaWVsZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAvLyBwYXJzZSBzdHJpbmcgdmFsdWUgYmFzZWQgb24gZmllbGQgdHlwZVxuICAgICAgaWYgKHJvd1tpXSAhPT0gbnVsbCkge1xuICAgICAgICByb3dbaV0gPSBwYXJzZXIucGFyc2Uocm93W2ldLCBmaWVsZCk7XG4gICAgICAgIGlmIChnZW9GaWVsZElkeCA+IC0xICYmIHJvd1tnZW9GaWVsZElkeF0gJiYgcm93W2dlb0ZpZWxkSWR4XS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcm93W2dlb0ZpZWxkSWR4XS5wcm9wZXJ0aWVzW2ZpZWxkLm5hbWVdID0gcm93W2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbmFseXplIGZpZWxkIHR5cGVzIGZyb20gZGF0YSBpbiBgc3RyaW5nYCBmb3JtYXQsIGUuZy4gdXBsb2FkZWQgY3N2LlxuICogQXNzaWduIGB0eXBlYCwgYHRhYmxlRmllbGRJbmRleGAgYW5kIGBmb3JtYXRgICh0aW1lc3RhbXAgb25seSkgdG8gZWFjaCBmaWVsZFxuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZGF0YSBhcnJheSBvZiByb3cgb2JqZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBmaWVsZE9yZGVyIGFycmF5IG9mIGZpZWxkIG5hbWVzIGFzIHN0cmluZ1xuICogQHJldHVybnMge0FycmF5PE9iamVjdD59IGZvcm1hdHRlZCBmaWVsZHNcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IHtnZXRGaWVsZHNGcm9tRGF0YX0gZnJvbSAna2VwbGVyLmdsL3Byb2Nlc3NvcnMnO1xuICogY29uc3QgZGF0YSA9IFt7XG4gKiAgIHRpbWU6ICcyMDE2LTA5LTE3IDAwOjA5OjU1JyxcbiAqICAgdmFsdWU6ICc0JyxcbiAqICAgc3VyZ2U6ICcxLjInLFxuICogICBpc1RyaXA6ICd0cnVlJyxcbiAqICAgemVyb09uZXM6ICcwJ1xuICogfSwge1xuICogICB0aW1lOiAnMjAxNi0wOS0xNyAwMDozMDowOCcsXG4gKiAgIHZhbHVlOiAnMycsXG4gKiAgIHN1cmdlOiBudWxsLFxuICogICBpc1RyaXA6ICdmYWxzZScsXG4gKiAgIHplcm9PbmVzOiAnMSdcbiAqIH0sIHtcbiAqICAgdGltZTogbnVsbCxcbiAqICAgdmFsdWU6ICcyJyxcbiAqICAgc3VyZ2U6ICcxLjMnLFxuICogICBpc1RyaXA6IG51bGwsXG4gKiAgIHplcm9PbmVzOiAnMSdcbiAqIH1dO1xuICpcbiAqIGNvbnN0IGZpZWxkT3JkZXIgPSBbJ3RpbWUnLCAndmFsdWUnLCAnc3VyZ2UnLCAnaXNUcmlwJywgJ3plcm9PbmVzJ107XG4gKiBjb25zdCBmaWVsZHMgPSBnZXRGaWVsZHNGcm9tRGF0YShkYXRhLCBmaWVsZE9yZGVyKTtcbiAqIC8vIGZpZWxkcyA9IFtcbiAqIC8vIHtuYW1lOiAndGltZScsIGZvcm1hdDogJ1lZWVktTS1EIEg6bTpzJywgdGFibGVGaWVsZEluZGV4OiAxLCB0eXBlOiAndGltZXN0YW1wJ30sXG4gKiAvLyB7bmFtZTogJ3ZhbHVlJywgZm9ybWF0OiAnJywgdGFibGVGaWVsZEluZGV4OiA0LCB0eXBlOiAnaW50ZWdlcid9LFxuICogLy8ge25hbWU6ICdzdXJnZScsIGZvcm1hdDogJycsIHRhYmxlRmllbGRJbmRleDogNSwgdHlwZTogJ3JlYWwnfSxcbiAqIC8vIHtuYW1lOiAnaXNUcmlwJywgZm9ybWF0OiAnJywgdGFibGVGaWVsZEluZGV4OiA2LCB0eXBlOiAnYm9vbGVhbid9LFxuICogLy8ge25hbWU6ICd6ZXJvT25lcycsIGZvcm1hdDogJycsIHRhYmxlRmllbGRJbmRleDogNywgdHlwZTogJ2ludGVnZXInfV07XG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRzRnJvbURhdGEoZGF0YSwgZmllbGRPcmRlcikge1xuICAvLyBhZGQgYSBjaGVjayBmb3IgZXBvY2ggdGltZXN0YW1wXG4gIGNvbnN0IG1ldGFkYXRhID0gQW5hbHl6ZXIuY29tcHV0ZUNvbE1ldGEoXG4gICAgZGF0YSxcbiAgICBbe3JlZ2V4OiAvLipnZW9qc29ufGFsbF9wb2ludHMvZywgZGF0YVR5cGU6ICdHRU9NRVRSWSd9XSxcbiAgICB7aWdub3JlZERhdGFUeXBlczogSUdOT1JFX0RBVEFfVFlQRVN9XG4gICk7XG5cbiAgY29uc3Qge2ZpZWxkQnlJbmRleH0gPSByZW5hbWVEdXBsaWNhdGVGaWVsZHMoZmllbGRPcmRlcik7XG5cbiAgY29uc3QgcmVzdWx0ID0gZmllbGRPcmRlci5yZWR1Y2UoKG9yZGVyZWRBcnJheSwgZmllbGQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgbmFtZSA9IGZpZWxkQnlJbmRleFtpbmRleF07XG5cbiAgICBjb25zdCBmaWVsZE1ldGEgPSBtZXRhZGF0YS5maW5kKG0gPT4gbS5rZXkgPT09IGZpZWxkKTtcbiAgICBjb25zdCB7dHlwZSwgZm9ybWF0fSA9IGZpZWxkTWV0YSB8fCB7fTtcblxuICAgIG9yZGVyZWRBcnJheVtpbmRleF0gPSB7XG4gICAgICBuYW1lLFxuICAgICAgZm9ybWF0LFxuICAgICAgdGFibGVGaWVsZEluZGV4OiBpbmRleCArIDEsXG4gICAgICB0eXBlOiBhbmFseXplclR5cGVUb0ZpZWxkVHlwZSh0eXBlKVxuICAgIH07XG4gICAgcmV0dXJuIG9yZGVyZWRBcnJheTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogcGFzcyBpbiBhbiBhcnJheSBvZiBmaWVsZCBuYW1lcywgcmVuYW1lIGR1cGxpY2F0ZWQgb25lXG4gKiBhbmQgcmV0dXJuIGEgbWFwIGZyb20gb2xkIGZpZWxkIGluZGV4IHRvIG5ldyBuYW1lXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZmllbGRPcmRlclxuICogQHJldHVybnMge09iamVjdH0gbmV3IGZpZWxkIG5hbWUgYnkgaW5kZXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmFtZUR1cGxpY2F0ZUZpZWxkcyhmaWVsZE9yZGVyKSB7XG4gIHJldHVybiBmaWVsZE9yZGVyLnJlZHVjZShcbiAgICAoYWNjdSwgZmllbGQsIGkpID0+IHtcbiAgICAgIGNvbnN0IHthbGxOYW1lc30gPSBhY2N1O1xuICAgICAgbGV0IGZpZWxkTmFtZSA9IGZpZWxkO1xuXG4gICAgICAvLyBhZGQgYSBjb3VudGVyIHRvIGR1cGxpY2F0ZWQgbmFtZXNcbiAgICAgIGlmIChhbGxOYW1lcy5pbmNsdWRlcyhmaWVsZCkpIHtcbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgICAgICB3aGlsZSAoYWxsTmFtZXMuaW5jbHVkZXMoYCR7ZmllbGR9LSR7Y291bnRlcn1gKSkge1xuICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgICBmaWVsZE5hbWUgPSBgJHtmaWVsZH0tJHtjb3VudGVyfWA7XG4gICAgICB9XG5cbiAgICAgIGFjY3UuZmllbGRCeUluZGV4W2ldID0gZmllbGROYW1lO1xuICAgICAgYWNjdS5hbGxOYW1lcy5wdXNoKGZpZWxkTmFtZSk7XG5cbiAgICAgIHJldHVybiBhY2N1O1xuICAgIH0sXG4gICAge2FsbE5hbWVzOiBbXSwgZmllbGRCeUluZGV4OiB7fX1cbiAgKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHR5cGUtYW5hbHl6ZXIgb3V0cHV0IHRvIGtlcGxlci5nbCBmaWVsZCB0eXBlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhVHlwZVxuICogQHJldHVybnMge3N0cmluZ30gY29ycmVzcG9uZGluZyB0eXBlIGluIGBBTExfRklFTERfVFlQRVNgXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmFseXplclR5cGVUb0ZpZWxkVHlwZShhVHlwZSkge1xuICBjb25zdCB7XG4gICAgREFURSxcbiAgICBUSU1FLFxuICAgIERBVEVUSU1FLFxuICAgIE5VTUJFUixcbiAgICBJTlQsXG4gICAgRkxPQVQsXG4gICAgQk9PTEVBTixcbiAgICBTVFJJTkcsXG4gICAgR0VPTUVUUlksXG4gICAgR0VPTUVUUllfRlJPTV9TVFJJTkcsXG4gICAgUEFJUl9HRU9NRVRSWV9GUk9NX1NUUklORyxcbiAgICBaSVBDT0RFLFxuICAgIEFSUkFZLFxuICAgIE9CSkVDVFxuICB9ID0gQW5hbHl6ZXJEQVRBX1RZUEVTO1xuXG4gIC8vIFRPRE86IHVuIHJlY29nbml6ZWQgdHlwZXNcbiAgLy8gQ1VSUkVOQ1kgUEVSQ0VOVCBOT05FXG4gIHN3aXRjaCAoYVR5cGUpIHtcbiAgICBjYXNlIERBVEU6XG4gICAgICByZXR1cm4gQUxMX0ZJRUxEX1RZUEVTLmRhdGU7XG4gICAgY2FzZSBUSU1FOlxuICAgIGNhc2UgREFURVRJTUU6XG4gICAgICByZXR1cm4gQUxMX0ZJRUxEX1RZUEVTLnRpbWVzdGFtcDtcbiAgICBjYXNlIE5VTUJFUjpcbiAgICBjYXNlIEZMT0FUOlxuICAgICAgcmV0dXJuIEFMTF9GSUVMRF9UWVBFUy5yZWFsO1xuICAgIGNhc2UgSU5UOlxuICAgICAgcmV0dXJuIEFMTF9GSUVMRF9UWVBFUy5pbnRlZ2VyO1xuICAgIGNhc2UgQk9PTEVBTjpcbiAgICAgIHJldHVybiBBTExfRklFTERfVFlQRVMuYm9vbGVhbjtcbiAgICBjYXNlIEdFT01FVFJZOlxuICAgIGNhc2UgR0VPTUVUUllfRlJPTV9TVFJJTkc6XG4gICAgY2FzZSBQQUlSX0dFT01FVFJZX0ZST01fU1RSSU5HOlxuICAgIGNhc2UgQVJSQVk6XG4gICAgY2FzZSBPQkpFQ1Q6XG4gICAgICAvLyBUT0RPOiBjcmVhdGUgYSBuZXcgZGF0YSB0eXBlIGZvciBvYmplY3RzIGFuZCBhcnJheXNcbiAgICAgIHJldHVybiBBTExfRklFTERfVFlQRVMuZ2VvanNvbjtcbiAgICBjYXNlIFNUUklORzpcbiAgICBjYXNlIFpJUENPREU6XG4gICAgICByZXR1cm4gQUxMX0ZJRUxEX1RZUEVTLnN0cmluZztcbiAgICBkZWZhdWx0OlxuICAgICAgZ2xvYmFsQ29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCBhbmFseXplciB0eXBlOiAke2FUeXBlfWApO1xuICAgICAgcmV0dXJuIEFMTF9GSUVMRF9UWVBFUy5zdHJpbmc7XG4gIH1cbn1cbi8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuXG4vKipcbiAqIFByb2Nlc3MgZGF0YSB3aGVyZSBlYWNoIHJvdyBpcyBhbiBvYmplY3QsIG91dHB1dCBjYW4gYmUgcGFzc2VkIHRvIFtgYWRkRGF0YVRvTWFwYF0oLi4vYWN0aW9ucy9hY3Rpb25zLm1kI2FkZGRhdGF0b21hcClcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcmF3RGF0YSBhbiBhcnJheSBvZiByb3cgb2JqZWN0LCBlYWNoIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Yga2V5c1xuICogQHJldHVybnMge09iamVjdH0gZGF0YXNldCBjb250YWluaW5nIGBmaWVsZHNgIGFuZCBgcm93c2BcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQge2FkZERhdGFUb01hcH0gZnJvbSAna2VwbGVyLmdsL2FjdGlvbnMnO1xuICogaW1wb3J0IHtwcm9jZXNzUm93T2JqZWN0fSBmcm9tICdrZXBsZXIuZ2wvcHJvY2Vzc29ycyc7XG4gKlxuICogY29uc3QgZGF0YSA9IFtcbiAqICB7bGF0OiAzMS4yNywgbG5nOiAxMjcuNTYsIHZhbHVlOiAzfSxcbiAqICB7bGF0OiAzMS4yMiwgbG5nOiAxMjYuMjYsIHZhbHVlOiAxfVxuICogXTtcbiAqXG4gKiBkaXNwYXRjaChhZGREYXRhVG9NYXAoe1xuICogIGRhdGFzZXRzOiB7XG4gKiAgICBpbmZvOiB7bGFiZWw6ICdNeSBEYXRhJywgaWQ6ICdteV9kYXRhJ30sXG4gKiAgICBkYXRhOiBwcm9jZXNzUm93T2JqZWN0KGRhdGEpXG4gKiAgfVxuICogfSkpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1Jvd09iamVjdChyYXdEYXRhKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShyYXdEYXRhKSB8fCAhcmF3RGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyYXdEYXRhWzBdKTtcbiAgY29uc3Qgcm93cyA9IHJhd0RhdGEubWFwKGQgPT4ga2V5cy5tYXAoa2V5ID0+IGRba2V5XSkpO1xuXG4gIC8vIHBpY2sgc2FtcGxlc1xuICBjb25zdCBzYW1wbGVEYXRhID0gZ2V0U2FtcGxlRGF0YShyYXdEYXRhLCA1MDApO1xuICBjb25zdCBmaWVsZHMgPSBnZXRGaWVsZHNGcm9tRGF0YShzYW1wbGVEYXRhLCBrZXlzKTtcbiAgY29uc3QgcGFyc2VkUm93cyA9IHBhcnNlUm93c0J5RmllbGRzKHJvd3MsIGZpZWxkcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBmaWVsZHMsXG4gICAgcm93czogcGFyc2VkUm93c1xuICB9O1xufVxuXG4vKipcbiAqIFByb2Nlc3MgR2VvSlNPTiBbYEZlYXR1cmVDb2xsZWN0aW9uYF0oaHR0cDovL3dpa2kuZ2VvanNvbi5vcmcvR2VvSlNPTl9kcmFmdF92ZXJzaW9uXzYjRmVhdHVyZUNvbGxlY3Rpb24pLFxuICogb3V0cHV0IGEgZGF0YSBvYmplY3Qgd2l0aCBge2ZpZWxkczogW10sIHJvd3M6IFtdfWAuXG4gKiBUaGUgZGF0YSBvYmplY3QgY2FuIGJlIHdyYXBwZWQgaW4gYSBgZGF0YXNldGAgYW5kIHBhc3MgdG8gW2BhZGREYXRhVG9NYXBgXSguLi9hY3Rpb25zL2FjdGlvbnMubWQjYWRkZGF0YXRvbWFwKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByYXdEYXRhIHJhdyBnZW9qc29uIGZlYXR1cmUgY29sbGVjdGlvblxuICogQHJldHVybnMge09iamVjdH0gZGF0YXNldCBjb250YWluaW5nIGBmaWVsZHNgIGFuZCBgcm93c2BcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQge2FkZERhdGFUb01hcH0gZnJvbSAna2VwbGVyLmdsL2FjdGlvbnMnO1xuICogaW1wb3J0IHtwcm9jZXNzR2VvanNvbn0gZnJvbSAna2VwbGVyLmdsL3Byb2Nlc3NvcnMnO1xuICpcbiAqIGNvbnN0IGdlb2pzb24gPSB7XG4gKiBcdFwidHlwZVwiIDogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogXHRcImZlYXR1cmVzXCIgOiBbe1xuICogXHRcdFwidHlwZVwiIDogXCJGZWF0dXJlXCIsXG4gKiBcdFx0XCJwcm9wZXJ0aWVzXCIgOiB7XG4gKiBcdFx0XHRcImNhcGFjaXR5XCIgOiBcIjEwXCIsXG4gKiBcdFx0XHRcInR5cGVcIiA6IFwiVS1SYWNrXCJcbiAqIFx0XHR9LFxuICogXHRcdFwiZ2VvbWV0cnlcIiA6IHtcbiAqIFx0XHRcdFwidHlwZVwiIDogXCJQb2ludFwiLFxuICogXHRcdFx0XCJjb29yZGluYXRlc1wiIDogWyAtNzEuMDczMjgzLCA0Mi40MTc1MDAgXVxuICogXHRcdH1cbiAqIFx0fV1cbiAqIH07XG4gKlxuICogZGlzcGF0Y2goYWRkRGF0YVRvTWFwKHtcbiAqICBkYXRhc2V0czoge1xuICogICAgaW5mbzoge1xuICogICAgICBsYWJlbDogJ1NhbXBsZSBUYXhpIFRyaXBzIGluIE5ldyBZb3JrIENpdHknLFxuICogICAgICBpZDogJ3Rlc3RfdHJpcF9kYXRhJ1xuICogICAgfSxcbiAqICAgIGRhdGE6IHByb2Nlc3NHZW9qc29uKGdlb2pzb24pXG4gKiAgfVxuICogfSkpO1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0dlb2pzb24ocmF3RGF0YSkge1xuICBjb25zdCBub3JtYWxpemVkR2VvanNvbiA9IG5vcm1hbGl6ZShyYXdEYXRhKTtcblxuICBpZiAoIW5vcm1hbGl6ZWRHZW9qc29uIHx8ICFBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRHZW9qc29uLmZlYXR1cmVzKSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgYFJlYWQgRmlsZSBGYWlsZWQ6IEZpbGUgaXMgbm90IGEgdmFsaWQgR2VvSlNPTi4gUmVhZCBtb3JlIGFib3V0IFtzdXBwb3J0ZWQgZmlsZSBmb3JtYXRdKCR7R1VJREVTX0ZJTEVfRk9STUFUfSlgXG4gICAgKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgICAvLyBmYWlsIHRvIG5vcm1hbGl6ZSBnZW9qc29uXG4gIH1cblxuICAvLyBnZXR0aW5nIGFsbCBmZWF0dXJlIGZpZWxkc1xuICBjb25zdCBhbGxEYXRhID0gbm9ybWFsaXplZEdlb2pzb24uZmVhdHVyZXMucmVkdWNlKChhY2N1LCBmLCBpKSA9PiB7XG4gICAgaWYgKGYuZ2VvbWV0cnkpIHtcbiAgICAgIGFjY3UucHVzaCh7XG4gICAgICAgIC8vIGFkZCBmZWF0dXJlIHRvIF9nZW9qc29uIGZpZWxkXG4gICAgICAgIF9nZW9qc29uOiBmLFxuICAgICAgICAuLi4oZi5wcm9wZXJ0aWVzIHx8IHt9KVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1O1xuICB9LCBbXSk7XG5cbiAgLy8gZ2V0IGFsbCB0aGUgZmllbGRcbiAgY29uc3QgZmllbGRzID0gYWxsRGF0YS5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcbiAgICBPYmplY3Qua2V5cyhjdXJyKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoIXByZXYuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBwcmV2LnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJldjtcbiAgfSwgW10pO1xuXG4gIC8vIG1ha2Ugc3VyZSBlYWNoIGZlYXR1cmUgaGFzIGV4YWN0IHNhbWUgZmllbGRzXG4gIGFsbERhdGEuZm9yRWFjaChkID0+IHtcbiAgICBmaWVsZHMuZm9yRWFjaChmID0+IHtcbiAgICAgIGlmICghKGYgaW4gZCkpIHtcbiAgICAgICAgZFtmXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGNvbnN0IHByb2Nlc3NSb3cgPSBwcm9jZXNzUm93T2JqZWN0KGFsbERhdGEpO1xuICByZXR1cm4gcHJvY2Vzc1Jvdztcbn1cblxuLyoqXG4gKiBPbiBleHBvcnQgZGF0YSB0byBjc3ZcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk+fSBkYXRhIGBkYXRhc2V0LmFsbERhdGFgIG9yIGZpbHRlcmVkIGRhdGEgYGRhdGFzZXQuZGF0YWBcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZmllbGRzIGBkYXRhc2V0LmZpZWxkc2BcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGNzdiBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdENzdihkYXRhLCBmaWVsZHMpIHtcbiAgY29uc3QgY29sdW1ucyA9IGZpZWxkcy5tYXAoZiA9PiBmLm5hbWUpO1xuICBjb25zdCBmb3JtYXR0ZWREYXRhID0gW2NvbHVtbnNdO1xuXG4gIC8vIHBhcnNlIGdlb2pzb24gb2JqZWN0IGFzIHN0cmluZ1xuICBkYXRhLmZvckVhY2gocm93ID0+IHtcbiAgICBmb3JtYXR0ZWREYXRhLnB1c2gocm93Lm1hcCgoZCwgaSkgPT4gcGFyc2VGaWVsZFZhbHVlKGQsIGZpZWxkc1tpXS50eXBlKSkpO1xuICB9KTtcblxuICByZXR1cm4gY3N2Rm9ybWF0Um93cyhmb3JtYXR0ZWREYXRhKTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBpbnB1dCBkYXRhLCBhZGRpbmcgbWlzc2luZyBmaWVsZCB0eXBlcywgcmVuYW1lIGR1cGxpY2F0ZSBjb2x1bW5zXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSBkYXRhc2V0LmRhdGFcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZGF0YS5maWVsZHMgYW4gYXJyYXkgb2YgZmllbGRzXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGRhdGEucm93cyBhbiBhcnJheSBvZiBkYXRhIHJvd3NcbiAqIEByZXR1cm5zIHt7YWxsRGF0YTogQXJyYXksIGZpZWxkczogQXJyYXl9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVJbnB1dERhdGEoZGF0YSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBhc3NlcnQoJ2FkZERhdGFUb01hcCBFcnJvcjogZGF0YXNldC5kYXRhIGNhbm5vdCBiZSBudWxsJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YS5maWVsZHMpKSB7XG4gICAgYXNzZXJ0KCdhZGREYXRhVG9NYXAgRXJyb3I6IGV4cGVjdCBkYXRhc2V0LmRhdGEuZmllbGRzIHRvIGJlIGFuIGFycmF5Jyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YS5yb3dzKSkge1xuICAgIGFzc2VydCgnYWRkRGF0YVRvTWFwIEVycm9yOiBleHBlY3QgZGF0YXNldC5kYXRhLnJvd3MgdG8gYmUgYW4gYXJyYXknKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHtmaWVsZHMsIHJvd3N9ID0gZGF0YTtcblxuICAvLyBjaGVjayBpZiBhbGwgZmllbGRzIGhhcyBuYW1lLCBmb3JtYXQgYW5kIHR5cGVcbiAgY29uc3QgYWxsVmFsaWQgPSBmaWVsZHMuZXZlcnkoKGYsIGkpID0+IHtcblxuICAgIGlmICghaXNQbGFpbk9iamVjdChmKSkge1xuICAgICAgYXNzZXJ0KGBmaWVsZHMgbmVlZHMgdG8gYmUgYW4gYXJyYXkgb2Ygb2JqZWN0LCBidXQgZmluZCAke3R5cGVvZiBmfWApO1xuICAgICAgZmllbGRzW2ldID0ge307XG4gICAgfVxuXG4gICAgaWYgKCFmLm5hbWUpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgYGZpZWxkLm5hbWUgaXMgcmVxdWlyZWQgYnV0IG1pc3NpbmcgaW4gJHtKU09OLnN0cmluZ2lmeShmKX1gXG4gICAgICApO1xuICAgICAgLy8gYXNzaWduIGEgbmFtZVxuICAgICAgZmllbGRzW2ldLm5hbWUgPSBgY29sdW1uXyR7aX1gO1xuICAgIH1cblxuICAgIGlmICghQUxMX0ZJRUxEX1RZUEVTW2YudHlwZV0pIHtcbiAgICAgIGFzc2VydChgdW5rbm93biBmaWVsZCB0eXBlICR7Zi50eXBlfWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIHRpbWUgZm9ybWF0IGlzIGNvcnJlY3QgYmFzZWQgb24gZmlyc3QgMTAgbm90IGVtcHR5IGVsZW1lbnRcbiAgICBpZiAoZi50eXBlID09PSBBTExfRklFTERfVFlQRVMudGltZXN0YW1wKSB7XG4gICAgICBjb25zdCBzYW1wbGUgPSBmaW5kTm9uRW1wdHlSb3dzQXRGaWVsZChyb3dzLCBpLCAxMClcbiAgICAgICAgLm1hcChyID0+ICh7dHM6IHJbaV19KSk7XG4gICAgICBjb25zdCBhbmFseXplZFR5cGUgPSBBbmFseXplci5jb21wdXRlQ29sTWV0YShzYW1wbGUpWzBdO1xuICAgICAgcmV0dXJuIGFuYWx5emVkVHlwZS5jYXRlZ29yeSA9PT0gJ1RJTUUnICYmIGFuYWx5emVkVHlwZS5mb3JtYXQgPT09IGYuZm9ybWF0O1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICBpZiAoYWxsVmFsaWQpIHtcbiAgICByZXR1cm4ge3Jvd3MsIGZpZWxkc307XG4gIH1cblxuICAvLyBpZiBhbnkgZmllbGQgaGFzIG1pc3NpbmcgdHlwZSwgcmVjYWxjdWxhdGUgaXQgZm9yIGV2ZXJ5b25lXG4gIC8vIGJlY2F1c2Ugd2Ugc2ltcGx5IGxvc3QgZmFpdGggaW4gaHVtYW5pdHlcbiAgY29uc3Qgc2FtcGxlRGF0YSA9IGdldFNhbXBsZUZvclR5cGVBbmFseXplKHtcbiAgICBmaWVsZHM6IGZpZWxkcy5tYXAoZiA9PiBmLm5hbWUpLFxuICAgIGFsbERhdGE6IHJvd3NcbiAgfSk7XG4gIGNvbnN0IGZpZWxkT3JkZXIgPSBmaWVsZHMubWFwKGYgPT4gZi5uYW1lKTtcbiAgY29uc3QgbWV0YSA9IGdldEZpZWxkc0Zyb21EYXRhKHNhbXBsZURhdGEsIGZpZWxkT3JkZXIpO1xuICBjb25zdCB1cGRhdGVkRmllbGRzID0gZmllbGRzLm1hcCgoZiwgaSkgPT4gKHtcbiAgICAuLi5mLFxuICAgIHR5cGU6IG1ldGFbaV0udHlwZSxcbiAgICBmb3JtYXQ6IG1ldGFbaV0uZm9ybWF0XG4gIH0pKTtcblxuICByZXR1cm4ge2ZpZWxkczogdXBkYXRlZEZpZWxkcywgcm93c307XG59XG5cbmZ1bmN0aW9uIGZpbmROb25FbXB0eVJvd3NBdEZpZWxkKHJvd3MsIGZpZWxkSWR4LCB0b3RhbCkge1xuICBjb25zdCBzYW1wbGUgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoc2FtcGxlLmxlbmd0aCA8IHRvdGFsICYmIGkgPCByb3dzLmxlbmd0aCkge1xuICAgIGlmIChub3ROdWxsb3JVbmRlZmluZWQocm93c1tpXVtmaWVsZElkeF0pKSB7XG4gICAgICBzYW1wbGUucHVzaChyb3dzW2ldKTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBzYW1wbGU7XG59XG4vKipcbiAqIFByb2Nlc3Mgc2F2ZWQga2VwbGVyLmdsIGpzb24gdG8gYmUgcGFzcyB0byBbYGFkZERhdGFUb01hcGBdKC4uL2FjdGlvbnMvYWN0aW9ucy5tZCNhZGRkYXRhdG9tYXApLlxuICogVGhlIGpzb24gb2JqZWN0IHNob3VsZCBjb250YWluIGBkYXRhc2V0c2AgYW5kIGBjb25maWdgLlxuICogQHBhcmFtIHtPYmplY3R9IHJhd0RhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IHJhd0RhdGEuZGF0YXNldHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByYXdEYXRhLmNvbmZpZ1xuICogQHJldHVybnMge09iamVjdH0gZGF0YXNldHMgYW5kIGNvbmZpZyBge2RhdGFzZXRzOiB7fSwgY29uZmlnOiB7fX1gXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHthZGREYXRhVG9NYXB9IGZyb20gJ2tlcGxlci5nbC9hY3Rpb25zJztcbiAqIGltcG9ydCB7cHJvY2Vzc0tlcGxlcmdsSlNPTn0gZnJvbSAna2VwbGVyLmdsL3Byb2Nlc3NvcnMnO1xuICpcbiAqIGRpc3BhdGNoKGFkZERhdGFUb01hcChwcm9jZXNzS2VwbGVyZ2xKU09OKGtlcGxlckdsSnNvbikpKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NLZXBsZXJnbEpTT04ocmF3RGF0YSkge1xuICByZXR1cm4gcmF3RGF0YSA/IEtlcGxlckdsU2NoZW1hLmxvYWQocmF3RGF0YS5kYXRhc2V0cywgcmF3RGF0YS5jb25maWcpIDogbnVsbDtcbn1cblxuZXhwb3J0IGNvbnN0IFByb2Nlc3NvcnMgPSB7XG4gIHByb2Nlc3NHZW9qc29uLFxuICBwcm9jZXNzQ3N2RGF0YSxcbiAgcHJvY2Vzc1Jvd09iamVjdCxcbiAgcHJvY2Vzc0tlcGxlcmdsSlNPTixcbiAgYW5hbHl6ZXJUeXBlVG9GaWVsZFR5cGUsXG4gIGdldEZpZWxkc0Zyb21EYXRhLFxuICBwYXJzZUNzdlJvd3NCeUZpZWxkVHlwZSxcbiAgZm9ybWF0Q3N2XG59O1xuIl19