"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.pointVisConfigs = exports.pointOptionalColumns = exports.pointRequiredColumns = exports.pointLabelResolver = exports.pointLabelAccessor = exports.pointPosResolver = exports.pointPosAccessor = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _lodash = _interopRequireDefault(require("lodash.memoize"));

var _lodash2 = _interopRequireDefault(require("lodash.uniq"));

var _deck = require("deck.gl");

var _baseLayer = _interopRequireDefault(require("../base-layer"));

var _scatterplotBrushingLayer = _interopRequireDefault(require("../../deckgl-layers/scatterplot-brushing-layer/scatterplot-brushing-layer"));

var _colorUtils = require("../../utils/color-utils");

var _pointLayerIcon = _interopRequireDefault(require("./point-layer-icon"));

var _defaultSettings = require("../../constants/default-settings");

var _viewportMercatorProject = require("viewport-mercator-project");

var _dataUtils = require("../../utils/data-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var pointPosAccessor = function pointPosAccessor(_ref) {
  var lat = _ref.lat,
      lng = _ref.lng,
      altitude = _ref.altitude;
  return function (d) {
    return [// lng
    d.data[lng.fieldIdx], // lat
    d.data[lat.fieldIdx], altitude && altitude.fieldIdx > -1 ? d.data[altitude.fieldIdx] : 0];
  };
};

exports.pointPosAccessor = pointPosAccessor;

var pointPosResolver = function pointPosResolver(_ref2) {
  var lat = _ref2.lat,
      lng = _ref2.lng,
      altitude = _ref2.altitude;
  return "".concat(lat.fieldIdx, "-").concat(lng.fieldIdx, "-").concat(altitude ? altitude.fieldIdx : 'z');
};

exports.pointPosResolver = pointPosResolver;

var pointLabelAccessor = function pointLabelAccessor(textLabel) {
  return function (d) {
    var val = d.data[textLabel.field.tableFieldIndex - 1];
    return (0, _dataUtils.notNullorUndefined)(val) ? String(val) : '';
  };
};

exports.pointLabelAccessor = pointLabelAccessor;

var pointLabelResolver = function pointLabelResolver(textLabel) {
  return textLabel.field && textLabel.field.tableFieldIndex;
};

exports.pointLabelResolver = pointLabelResolver;
var pointRequiredColumns = ['lat', 'lng'];
exports.pointRequiredColumns = pointRequiredColumns;
var pointOptionalColumns = ['altitude'];
exports.pointOptionalColumns = pointOptionalColumns;
var pointVisConfigs = {
  radius: 'radius',
  fixedRadius: 'fixedRadius',
  opacity: 'opacity',
  outline: 'outline',
  thickness: 'thickness',
  strokeColor: 'strokeColor',
  colorRange: 'colorRange',
  strokeColorRange: 'strokeColorRange',
  radiusRange: 'radiusRange',
  filled: {
    type: 'boolean',
    label: 'Fill Color',
    defaultValue: true,
    property: 'filled'
  }
};
exports.pointVisConfigs = pointVisConfigs;

var PointLayer =
/*#__PURE__*/
function (_Layer) {
  (0, _inherits2["default"])(PointLayer, _Layer);

  function PointLayer(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, PointLayer);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(PointLayer).call(this, props));

    _this.registerVisConfig(pointVisConfigs);

    _this.getPosition = (0, _lodash["default"])(pointPosAccessor, pointPosResolver);
    _this.getText = [(0, _lodash["default"])(pointLabelAccessor, pointLabelResolver)];
    return _this;
  }

  (0, _createClass2["default"])(PointLayer, [{
    key: "getPositionAccessor",
    value: function getPositionAccessor() {
      return this.getPosition(this.config.columns);
    }
  }, {
    key: "getDefaultLayerConfig",
    value: function getDefaultLayerConfig() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return _objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(PointLayer.prototype), "getDefaultLayerConfig", this).call(this, props), {
        // add stroke color visual channel
        strokeColorField: null,
        strokeColorDomain: [0, 1],
        strokeColorScale: 'quantile'
      });
    } // TODO: fix complexity

    /* eslint-disable complexity */

  }, {
    key: "formatLayerData",
    value: function formatLayerData(_, allData, filteredIndex, oldLayerData) {
      var _this2 = this;

      var opt = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      var _this$config = this.config,
          colorScale = _this$config.colorScale,
          colorDomain = _this$config.colorDomain,
          colorField = _this$config.colorField,
          strokeColorField = _this$config.strokeColorField,
          strokeColorScale = _this$config.strokeColorScale,
          strokeColorDomain = _this$config.strokeColorDomain,
          color = _this$config.color,
          sizeField = _this$config.sizeField,
          sizeScale = _this$config.sizeScale,
          sizeDomain = _this$config.sizeDomain,
          textLabel = _this$config.textLabel,
          _this$config$visConfi = _this$config.visConfig,
          radiusRange = _this$config$visConfi.radiusRange,
          fixedRadius = _this$config$visConfi.fixedRadius,
          colorRange = _this$config$visConfi.colorRange,
          strokeColorRange = _this$config$visConfi.strokeColorRange,
          strokeColor = _this$config$visConfi.strokeColor; // fill color

      var cScale = colorField && this.getVisChannelScale(colorScale, colorDomain, colorRange.colors.map(_colorUtils.hexToRgb)); // stroke color

      var scScale = strokeColorField && this.getVisChannelScale(strokeColorScale, strokeColorDomain, strokeColorRange.colors.map(_colorUtils.hexToRgb)); // point radius

      var rScale = sizeField && this.getVisChannelScale(sizeScale, sizeDomain, radiusRange, fixedRadius);
      var getPosition = this.getPositionAccessor();

      if (!oldLayerData || oldLayerData.getPosition !== getPosition) {
        this.updateLayerMeta(allData, getPosition);
      }

      var data;

      if (oldLayerData && oldLayerData.data && opt.sameData && oldLayerData.getPosition === getPosition) {
        data = oldLayerData.data;
      } else {
        data = filteredIndex.reduce(function (accu, index) {
          var pos = getPosition({
            data: allData[index]
          }); // if doesn't have point lat or lng, do not add the point
          // deck.gl can't handle position = null

          if (!pos.every(Number.isFinite)) {
            return accu;
          }

          accu.push({
            data: allData[index]
          });
          return accu;
        }, []);
      } // get all distinct characters in the text labels


      var getRadius = rScale ? function (d) {
        return _this2.getEncodedChannelValue(rScale, d.data, sizeField, 0);
      } : 1;
      var getFillColor = cScale ? function (d) {
        return _this2.getEncodedChannelValue(cScale, d.data, colorField);
      } : color;
      var getLineColor = scScale ? function (d) {
        return _this2.getEncodedChannelValue(scScale, d.data, strokeColorField);
      } : strokeColor || color; // TODO: this should be cleaned up in the gpu-data-filter branch

      var textLabels = textLabel.map(function (tl, i) {
        if (!tl.field) {
          // if no field selected,
          return {
            getText: null,
            characterSet: []
          };
        }

        if (!_this2.getText[i]) {
          _this2.getText[i] = (0, _lodash["default"])(pointLabelAccessor, pointLabelResolver);
        }

        var getText = _this2.getText[i](tl);

        var characterSet;

        if (oldLayerData && Array.isArray(oldLayerData.textLabels) && oldLayerData.textLabels[i] && opt.sameData && oldLayerData.textLabels[i].getText === getText) {
          characterSet = oldLayerData.textLabels[i].characterSet;
        } else {
          var allLabels = tl.field ? data.map(getText) : [];
          characterSet = (0, _lodash2["default"])(allLabels.join(''));
        }

        return {
          characterSet: characterSet,
          getText: getText
        };
      });
      return {
        data: data,
        getPosition: getPosition,
        getFillColor: getFillColor,
        getLineColor: getLineColor,
        getRadius: getRadius,
        textLabels: textLabels
      };
    }
    /* eslint-enable complexity */

  }, {
    key: "updateLayerMeta",
    value: function updateLayerMeta(allData) {
      var getPosition = this.getPositionAccessor();
      var bounds = this.getPointsBounds(allData, function (d) {
        return getPosition({
          data: d
        });
      });
      this.updateMeta({
        bounds: bounds
      });
    }
  }, {
    key: "getTextOffset",
    value: function getTextOffset(config, radiusScale, getRadius, mapState) {
      var distanceScale = (0, _viewportMercatorProject.getDistanceScales)(mapState);
      var xMult = config.anchor === 'middle' ? 0 : config.anchor === 'start' ? 1 : -1;
      var yMult = config.alignment === 'center' ? 0 : config.alignment === 'bottom' ? 1 : -1;
      var sizeOffset = config.alignment === 'center' ? 0 : config.alignment === 'bottom' ? config.size : config.size;
      var pixelRadius = radiusScale * distanceScale.pixelsPerMeter[0];
      var padding = 20;
      return typeof getRadius === 'function' ? function (d) {
        return [xMult * (getRadius(d) * pixelRadius + padding), yMult * (getRadius(d) * pixelRadius + padding + sizeOffset)];
      } : [xMult * (getRadius * pixelRadius + padding), yMult * (getRadius * pixelRadius + padding + sizeOffset)];
    }
  }, {
    key: "renderLayer",
    value: function renderLayer(_ref3) {
      var _this3 = this;

      var data = _ref3.data,
          idx = _ref3.idx,
          layerInteraction = _ref3.layerInteraction,
          objectHovered = _ref3.objectHovered,
          mapState = _ref3.mapState,
          interactionConfig = _ref3.interactionConfig;
      var enableBrushing = interactionConfig.brush.enabled;
      var radiusScale = this.getRadiusScaleByZoom(mapState);

      var layerProps = _objectSpread({
        // TODO: support setting stroke and fill simultaneously
        stroked: this.config.visConfig.outline,
        filled: this.config.visConfig.filled,
        radiusMinPixels: 0,
        lineWidthMinPixels: this.config.visConfig.thickness,
        radiusScale: radiusScale
      }, this.config.visConfig.fixedRadius ? {} : {
        radiusMaxPixels: 500
      });

      var interaction = {
        autoHighlight: !enableBrushing,
        enableBrushing: enableBrushing,
        brushRadius: interactionConfig.brush.config.size * 1000,
        highlightColor: this.config.highlightColor
      };
      var textLabel = this.config.textLabel;
      var updateTriggers = {
        getPosition: {
          columns: this.config.columns
        },
        getRadius: {
          sizeField: this.config.sizeField,
          radiusRange: this.config.visConfig.radiusRange,
          fixedRadius: this.config.visConfig.fixedRadius,
          sizeScale: this.config.sizeScale
        },
        getFillColor: {
          color: this.config.color,
          colorField: this.config.colorField,
          colorRange: this.config.visConfig.colorRange,
          colorScale: this.config.colorScale
        },
        getLineColor: {
          color: this.config.visConfig.strokeColor,
          colorField: this.config.strokeColorField,
          colorRange: this.config.visConfig.strokeColorRange,
          colorScale: this.config.strokeColorScale
        }
      };
      return [new _scatterplotBrushingLayer["default"](_objectSpread({}, layerProps, {}, layerInteraction, {}, data, {}, interaction, {
        idx: idx,
        id: this.id,
        opacity: this.config.visConfig.opacity,
        pickable: true,
        parameters: {
          // circles will be flat on the map when the altitude column is not used
          depthTest: this.config.columns.altitude.fieldIdx > -1
        },
        updateTriggers: updateTriggers
      }))].concat((0, _toConsumableArray2["default"])(this.isLayerHovered(objectHovered) ? [new _scatterplotBrushingLayer["default"](_objectSpread({}, layerProps, {
        id: "".concat(this.id, "-hovered"),
        data: [objectHovered.object],
        getLineColor: this.config.highlightColor,
        getFillColor: this.config.highlightColor,
        getRadius: data.getRadius,
        getPosition: data.getPosition,
        pickable: false
      }))] : []), (0, _toConsumableArray2["default"])(data.textLabels.reduce(function (accu, d, i) {
        if (d.getText) {
          accu.push(new _deck.TextLayer(_objectSpread({}, layerInteraction, {
            id: "".concat(_this3.id, "-label-").concat(textLabel[i].field.name),
            data: data.data,
            getPosition: data.getPosition,
            getText: d.getText,
            characterSet: d.characterSet,
            getPixelOffset: _this3.getTextOffset(textLabel[i], radiusScale, data.getRadius, mapState),
            getSize: 1,
            sizeScale: textLabel[i].size,
            getTextAnchor: textLabel[i].anchor,
            getAlignmentBaseline: textLabel[i].alignment,
            getColor: textLabel[i].color,
            parameters: {
              // text will always show on top of all layers
              depthTest: false
            },
            updateTriggers: {
              getPosition: _this3.config.columns,
              getText: textLabel[i].field.name,
              getPixelOffset: _objectSpread({}, updateTriggers.getRadius, {
                mapState: mapState,
                anchor: textLabel[i].anchor,
                alignment: textLabel[i].alignment
              }),
              getTextAnchor: textLabel[i].anchor,
              getAlignmentBaseline: textLabel[i].alignment,
              getColor: textLabel[i].color
            }
          })));
        }

        return accu;
      }, [])));
    }
  }, {
    key: "type",
    get: function get() {
      return 'point';
    }
  }, {
    key: "isAggregated",
    get: function get() {
      return false;
    }
  }, {
    key: "layerIcon",
    get: function get() {
      return _pointLayerIcon["default"];
    }
  }, {
    key: "requiredLayerColumns",
    get: function get() {
      return pointRequiredColumns;
    }
  }, {
    key: "optionalColumns",
    get: function get() {
      return pointOptionalColumns;
    }
  }, {
    key: "columnPairs",
    get: function get() {
      return this.defaultPointColumnPairs;
    }
  }, {
    key: "noneLayerDataAffectingProps",
    get: function get() {
      return [].concat((0, _toConsumableArray2["default"])((0, _get2["default"])((0, _getPrototypeOf2["default"])(PointLayer.prototype), "noneLayerDataAffectingProps", this)), ['radius']);
    }
  }, {
    key: "visualChannels",
    get: function get() {
      return {
        color: _objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(PointLayer.prototype), "visualChannels", this).color, {
          condition: function condition(config) {
            return config.visConfig.filled;
          }
        }),
        strokeColor: {
          property: 'strokeColor',
          field: 'strokeColorField',
          scale: 'strokeColorScale',
          domain: 'strokeColorDomain',
          range: 'strokeColorRange',
          key: 'strokeColor',
          channelScaleType: _defaultSettings.CHANNEL_SCALES.color,
          condition: function condition(config) {
            return config.visConfig.outline;
          }
        },
        size: _objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(PointLayer.prototype), "visualChannels", this).size, {
          range: 'radiusRange',
          property: 'radius',
          channelScaleType: 'radius'
        })
      };
    }
  }], [{
    key: "findDefaultLayerProps",
    value: function findDefaultLayerProps(_ref4) {
      var _ref4$fieldPairs = _ref4.fieldPairs,
          fieldPairs = _ref4$fieldPairs === void 0 ? [] : _ref4$fieldPairs;
      var props = []; // Make layer for each pair

      fieldPairs.forEach(function (pair) {
        // find fields for tableFieldIndex
        var latField = pair.pair.lat;
        var lngField = pair.pair.lng;
        var layerName = pair.defaultName;
        var prop = {
          label: layerName.length ? layerName : 'Point'
        }; // default layer color for begintrip and dropoff point

        if (latField.value in _defaultSettings.DEFAULT_LAYER_COLOR) {
          prop.color = (0, _colorUtils.hexToRgb)(_defaultSettings.DEFAULT_LAYER_COLOR[latField.value]);
        } // set the first layer to be visible


        if (props.length === 0) {
          prop.isVisible = true;
        }

        prop.columns = {
          lat: latField,
          lng: lngField,
          altitude: {
            value: null,
            fieldIdx: -1,
            optional: true
          }
        };
        props.push(prop);
      });
      return {
        props: props
      };
    }
  }]);
  return PointLayer;
}(_baseLayer["default"]);

exports["default"] = PointLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9sYXllcnMvcG9pbnQtbGF5ZXIvcG9pbnQtbGF5ZXIuanMiXSwibmFtZXMiOlsicG9pbnRQb3NBY2Nlc3NvciIsImxhdCIsImxuZyIsImFsdGl0dWRlIiwiZCIsImRhdGEiLCJmaWVsZElkeCIsInBvaW50UG9zUmVzb2x2ZXIiLCJwb2ludExhYmVsQWNjZXNzb3IiLCJ0ZXh0TGFiZWwiLCJ2YWwiLCJmaWVsZCIsInRhYmxlRmllbGRJbmRleCIsIlN0cmluZyIsInBvaW50TGFiZWxSZXNvbHZlciIsInBvaW50UmVxdWlyZWRDb2x1bW5zIiwicG9pbnRPcHRpb25hbENvbHVtbnMiLCJwb2ludFZpc0NvbmZpZ3MiLCJyYWRpdXMiLCJmaXhlZFJhZGl1cyIsIm9wYWNpdHkiLCJvdXRsaW5lIiwidGhpY2tuZXNzIiwic3Ryb2tlQ29sb3IiLCJjb2xvclJhbmdlIiwic3Ryb2tlQ29sb3JSYW5nZSIsInJhZGl1c1JhbmdlIiwiZmlsbGVkIiwidHlwZSIsImxhYmVsIiwiZGVmYXVsdFZhbHVlIiwicHJvcGVydHkiLCJQb2ludExheWVyIiwicHJvcHMiLCJyZWdpc3RlclZpc0NvbmZpZyIsImdldFBvc2l0aW9uIiwiZ2V0VGV4dCIsImNvbmZpZyIsImNvbHVtbnMiLCJzdHJva2VDb2xvckZpZWxkIiwic3Ryb2tlQ29sb3JEb21haW4iLCJzdHJva2VDb2xvclNjYWxlIiwiXyIsImFsbERhdGEiLCJmaWx0ZXJlZEluZGV4Iiwib2xkTGF5ZXJEYXRhIiwib3B0IiwiY29sb3JTY2FsZSIsImNvbG9yRG9tYWluIiwiY29sb3JGaWVsZCIsImNvbG9yIiwic2l6ZUZpZWxkIiwic2l6ZVNjYWxlIiwic2l6ZURvbWFpbiIsInZpc0NvbmZpZyIsImNTY2FsZSIsImdldFZpc0NoYW5uZWxTY2FsZSIsImNvbG9ycyIsIm1hcCIsImhleFRvUmdiIiwic2NTY2FsZSIsInJTY2FsZSIsImdldFBvc2l0aW9uQWNjZXNzb3IiLCJ1cGRhdGVMYXllck1ldGEiLCJzYW1lRGF0YSIsInJlZHVjZSIsImFjY3UiLCJpbmRleCIsInBvcyIsImV2ZXJ5IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJwdXNoIiwiZ2V0UmFkaXVzIiwiZ2V0RW5jb2RlZENoYW5uZWxWYWx1ZSIsImdldEZpbGxDb2xvciIsImdldExpbmVDb2xvciIsInRleHRMYWJlbHMiLCJ0bCIsImkiLCJjaGFyYWN0ZXJTZXQiLCJBcnJheSIsImlzQXJyYXkiLCJhbGxMYWJlbHMiLCJqb2luIiwiYm91bmRzIiwiZ2V0UG9pbnRzQm91bmRzIiwidXBkYXRlTWV0YSIsInJhZGl1c1NjYWxlIiwibWFwU3RhdGUiLCJkaXN0YW5jZVNjYWxlIiwieE11bHQiLCJhbmNob3IiLCJ5TXVsdCIsImFsaWdubWVudCIsInNpemVPZmZzZXQiLCJzaXplIiwicGl4ZWxSYWRpdXMiLCJwaXhlbHNQZXJNZXRlciIsInBhZGRpbmciLCJpZHgiLCJsYXllckludGVyYWN0aW9uIiwib2JqZWN0SG92ZXJlZCIsImludGVyYWN0aW9uQ29uZmlnIiwiZW5hYmxlQnJ1c2hpbmciLCJicnVzaCIsImVuYWJsZWQiLCJnZXRSYWRpdXNTY2FsZUJ5Wm9vbSIsImxheWVyUHJvcHMiLCJzdHJva2VkIiwicmFkaXVzTWluUGl4ZWxzIiwibGluZVdpZHRoTWluUGl4ZWxzIiwicmFkaXVzTWF4UGl4ZWxzIiwiaW50ZXJhY3Rpb24iLCJhdXRvSGlnaGxpZ2h0IiwiYnJ1c2hSYWRpdXMiLCJoaWdobGlnaHRDb2xvciIsInVwZGF0ZVRyaWdnZXJzIiwiU2NhdHRlcnBsb3RCcnVzaGluZ0xheWVyIiwiaWQiLCJwaWNrYWJsZSIsInBhcmFtZXRlcnMiLCJkZXB0aFRlc3QiLCJpc0xheWVySG92ZXJlZCIsIm9iamVjdCIsIlRleHRMYXllciIsIm5hbWUiLCJnZXRQaXhlbE9mZnNldCIsImdldFRleHRPZmZzZXQiLCJnZXRTaXplIiwiZ2V0VGV4dEFuY2hvciIsImdldEFsaWdubWVudEJhc2VsaW5lIiwiZ2V0Q29sb3IiLCJQb2ludExheWVySWNvbiIsImRlZmF1bHRQb2ludENvbHVtblBhaXJzIiwiY29uZGl0aW9uIiwic2NhbGUiLCJkb21haW4iLCJyYW5nZSIsImtleSIsImNoYW5uZWxTY2FsZVR5cGUiLCJDSEFOTkVMX1NDQUxFUyIsImZpZWxkUGFpcnMiLCJmb3JFYWNoIiwicGFpciIsImxhdEZpZWxkIiwibG5nRmllbGQiLCJsYXllck5hbWUiLCJkZWZhdWx0TmFtZSIsInByb3AiLCJsZW5ndGgiLCJ2YWx1ZSIsIkRFRkFVTFRfTEFZRVJfQ09MT1IiLCJpc1Zpc2libGUiLCJvcHRpb25hbCIsIkxheWVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFFTyxJQUFNQSxnQkFBZ0IsR0FBRyxTQUFuQkEsZ0JBQW1CO0FBQUEsTUFBRUMsR0FBRixRQUFFQSxHQUFGO0FBQUEsTUFBT0MsR0FBUCxRQUFPQSxHQUFQO0FBQUEsTUFBWUMsUUFBWixRQUFZQSxRQUFaO0FBQUEsU0FBMEIsVUFBQUMsQ0FBQztBQUFBLFdBQUksQ0FDN0Q7QUFDQUEsSUFBQUEsQ0FBQyxDQUFDQyxJQUFGLENBQU9ILEdBQUcsQ0FBQ0ksUUFBWCxDQUY2RCxFQUc3RDtBQUNBRixJQUFBQSxDQUFDLENBQUNDLElBQUYsQ0FBT0osR0FBRyxDQUFDSyxRQUFYLENBSjZELEVBSzdESCxRQUFRLElBQUlBLFFBQVEsQ0FBQ0csUUFBVCxHQUFvQixDQUFDLENBQWpDLEdBQXFDRixDQUFDLENBQUNDLElBQUYsQ0FBT0YsUUFBUSxDQUFDRyxRQUFoQixDQUFyQyxHQUFpRSxDQUxKLENBQUo7QUFBQSxHQUEzQjtBQUFBLENBQXpCOzs7O0FBUUEsSUFBTUMsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQjtBQUFBLE1BQUVOLEdBQUYsU0FBRUEsR0FBRjtBQUFBLE1BQU9DLEdBQVAsU0FBT0EsR0FBUDtBQUFBLE1BQVlDLFFBQVosU0FBWUEsUUFBWjtBQUFBLG1CQUMz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LEdBQWU7QUFDYnJDLFVBQUFBLEdBQUcsRUFBRWdKLFFBRFE7QUFFYi9JLFVBQUFBLEdBQUcsRUFBRWdKLFFBRlE7QUFHYi9JLFVBQUFBLFFBQVEsRUFBRTtBQUFDb0osWUFBQUEsS0FBSyxFQUFFLElBQVI7QUFBY2pKLFlBQUFBLFFBQVEsRUFBRSxDQUFDLENBQXpCO0FBQTRCb0osWUFBQUEsUUFBUSxFQUFFO0FBQXRDO0FBSEcsU0FBZjtBQU1BekgsUUFBQUEsS0FBSyxDQUFDdUMsSUFBTixDQUFXNkUsSUFBWDtBQUNELE9BM0JEO0FBNkJBLGFBQU87QUFBQ3BILFFBQUFBLEtBQUssRUFBTEE7QUFBRCxPQUFQO0FBQ0Q7OztFQW5HcUMwSCxxQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxOSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBtZW1vaXplIGZyb20gJ2xvZGFzaC5tZW1vaXplJztcbmltcG9ydCB1bmlxIGZyb20gJ2xvZGFzaC51bmlxJztcbmltcG9ydCB7VGV4dExheWVyfSBmcm9tICdkZWNrLmdsJztcblxuaW1wb3J0IExheWVyIGZyb20gJy4uL2Jhc2UtbGF5ZXInO1xuaW1wb3J0IFNjYXR0ZXJwbG90QnJ1c2hpbmdMYXllciBmcm9tICdkZWNrZ2wtbGF5ZXJzL3NjYXR0ZXJwbG90LWJydXNoaW5nLWxheWVyL3NjYXR0ZXJwbG90LWJydXNoaW5nLWxheWVyJztcbmltcG9ydCB7aGV4VG9SZ2J9IGZyb20gJ3V0aWxzL2NvbG9yLXV0aWxzJztcbmltcG9ydCBQb2ludExheWVySWNvbiBmcm9tICcuL3BvaW50LWxheWVyLWljb24nO1xuaW1wb3J0IHtERUZBVUxUX0xBWUVSX0NPTE9SLCBDSEFOTkVMX1NDQUxFU30gZnJvbSAnY29uc3RhbnRzL2RlZmF1bHQtc2V0dGluZ3MnO1xuaW1wb3J0IHtnZXREaXN0YW5jZVNjYWxlc30gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5pbXBvcnQge25vdE51bGxvclVuZGVmaW5lZH0gZnJvbSAndXRpbHMvZGF0YS11dGlscyc7XG5cbmV4cG9ydCBjb25zdCBwb2ludFBvc0FjY2Vzc29yID0gKHtsYXQsIGxuZywgYWx0aXR1ZGV9KSA9PiBkID0+IFtcbiAgLy8gbG5nXG4gIGQuZGF0YVtsbmcuZmllbGRJZHhdLFxuICAvLyBsYXRcbiAgZC5kYXRhW2xhdC5maWVsZElkeF0sXG4gIGFsdGl0dWRlICYmIGFsdGl0dWRlLmZpZWxkSWR4ID4gLTEgPyBkLmRhdGFbYWx0aXR1ZGUuZmllbGRJZHhdIDogMFxuXTtcblxuZXhwb3J0IGNvbnN0IHBvaW50UG9zUmVzb2x2ZXIgPSAoe2xhdCwgbG5nLCBhbHRpdHVkZX0pID0+XG4gIGAke2xhdC5maWVsZElkeH0tJHtsbmcuZmllbGRJZHh9LSR7YWx0aXR1ZGUgPyBhbHRpdHVkZS5maWVsZElkeCA6ICd6J31gO1xuXG5leHBvcnQgY29uc3QgcG9pbnRMYWJlbEFjY2Vzc29yID0gdGV4dExhYmVsID0+IGQgPT4ge1xuICBjb25zdCB2YWwgPSBkLmRhdGFbdGV4dExhYmVsLmZpZWxkLnRhYmxlRmllbGRJbmRleCAtIDFdO1xuICByZXR1cm4gbm90TnVsbG9yVW5kZWZpbmVkKHZhbCkgPyBTdHJpbmcodmFsKSA6ICcnO1xufTtcblxuZXhwb3J0IGNvbnN0IHBvaW50TGFiZWxSZXNvbHZlciA9IHRleHRMYWJlbCA9PlxuICB0ZXh0TGFiZWwuZmllbGQgJiYgdGV4dExhYmVsLmZpZWxkLnRhYmxlRmllbGRJbmRleDtcblxuZXhwb3J0IGNvbnN0IHBvaW50UmVxdWlyZWRDb2x1bW5zID0gWydsYXQnLCAnbG5nJ107XG5leHBvcnQgY29uc3QgcG9pbnRPcHRpb25hbENvbHVtbnMgPSBbJ2FsdGl0dWRlJ107XG5cbmV4cG9ydCBjb25zdCBwb2ludFZpc0NvbmZpZ3MgPSB7XG4gIHJhZGl1czogJ3JhZGl1cycsXG4gIGZpeGVkUmFkaXVzOiAnZml4ZWRSYWRpdXMnLFxuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIG91dGxpbmU6ICdvdXRsaW5lJyxcbiAgdGhpY2tuZXNzOiAndGhpY2tuZXNzJyxcbiAgc3Ryb2tlQ29sb3I6ICdzdHJva2VDb2xvcicsXG4gIGNvbG9yUmFuZ2U6ICdjb2xvclJhbmdlJyxcbiAgc3Ryb2tlQ29sb3JSYW5nZTogJ3N0cm9rZUNvbG9yUmFuZ2UnLFxuICByYWRpdXNSYW5nZTogJ3JhZGl1c1JhbmdlJyxcbiAgZmlsbGVkOiB7XG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGxhYmVsOiAnRmlsbCBDb2xvcicsXG4gICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICAgIHByb3BlcnR5OiAnZmlsbGVkJ1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludExheWVyIGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMucmVnaXN0ZXJWaXNDb25maWcocG9pbnRWaXNDb25maWdzKTtcbiAgICB0aGlzLmdldFBvc2l0aW9uID0gbWVtb2l6ZShwb2ludFBvc0FjY2Vzc29yLCBwb2ludFBvc1Jlc29sdmVyKTtcbiAgICB0aGlzLmdldFRleHQgPSBbbWVtb2l6ZShwb2ludExhYmVsQWNjZXNzb3IsIHBvaW50TGFiZWxSZXNvbHZlcildO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdwb2ludCc7XG4gIH1cblxuICBnZXQgaXNBZ2dyZWdhdGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGdldCBsYXllckljb24oKSB7XG4gICAgcmV0dXJuIFBvaW50TGF5ZXJJY29uO1xuICB9XG4gIGdldCByZXF1aXJlZExheWVyQ29sdW1ucygpIHtcbiAgICByZXR1cm4gcG9pbnRSZXF1aXJlZENvbHVtbnM7XG4gIH1cblxuICBnZXQgb3B0aW9uYWxDb2x1bW5zKCkge1xuICAgIHJldHVybiBwb2ludE9wdGlvbmFsQ29sdW1ucztcbiAgfVxuXG4gIGdldCBjb2x1bW5QYWlycygpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0UG9pbnRDb2x1bW5QYWlycztcbiAgfVxuXG4gIGdldCBub25lTGF5ZXJEYXRhQWZmZWN0aW5nUHJvcHMoKSB7XG4gICAgcmV0dXJuIFsuLi5zdXBlci5ub25lTGF5ZXJEYXRhQWZmZWN0aW5nUHJvcHMsICdyYWRpdXMnXTtcbiAgfVxuXG4gIGdldCB2aXN1YWxDaGFubmVscygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sb3I6IHtcbiAgICAgICAgLi4uc3VwZXIudmlzdWFsQ2hhbm5lbHMuY29sb3IsXG4gICAgICAgIGNvbmRpdGlvbjogY29uZmlnID0+IGNvbmZpZy52aXNDb25maWcuZmlsbGVkXG4gICAgICB9LFxuICAgICAgc3Ryb2tlQ29sb3I6IHtcbiAgICAgICAgcHJvcGVydHk6ICdzdHJva2VDb2xvcicsXG4gICAgICAgIGZpZWxkOiAnc3Ryb2tlQ29sb3JGaWVsZCcsXG4gICAgICAgIHNjYWxlOiAnc3Ryb2tlQ29sb3JTY2FsZScsXG4gICAgICAgIGRvbWFpbjogJ3N0cm9rZUNvbG9yRG9tYWluJyxcbiAgICAgICAgcmFuZ2U6ICdzdHJva2VDb2xvclJhbmdlJyxcbiAgICAgICAga2V5OiAnc3Ryb2tlQ29sb3InLFxuICAgICAgICBjaGFubmVsU2NhbGVUeXBlOiBDSEFOTkVMX1NDQUxFUy5jb2xvcixcbiAgICAgICAgY29uZGl0aW9uOiBjb25maWcgPT4gY29uZmlnLnZpc0NvbmZpZy5vdXRsaW5lXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICAuLi5zdXBlci52aXN1YWxDaGFubmVscy5zaXplLFxuICAgICAgICByYW5nZTogJ3JhZGl1c1JhbmdlJyxcbiAgICAgICAgcHJvcGVydHk6ICdyYWRpdXMnLFxuICAgICAgICBjaGFubmVsU2NhbGVUeXBlOiAncmFkaXVzJ1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBnZXRQb3NpdGlvbkFjY2Vzc29yKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvc2l0aW9uKHRoaXMuY29uZmlnLmNvbHVtbnMpO1xuICB9XG5cbiAgc3RhdGljIGZpbmREZWZhdWx0TGF5ZXJQcm9wcyh7ZmllbGRQYWlycyA9IFtdfSkge1xuICAgIGNvbnN0IHByb3BzID0gW107XG5cbiAgICAvLyBNYWtlIGxheWVyIGZvciBlYWNoIHBhaXJcbiAgICBmaWVsZFBhaXJzLmZvckVhY2gocGFpciA9PiB7XG4gICAgICAvLyBmaW5kIGZpZWxkcyBmb3IgdGFibGVGaWVsZEluZGV4XG4gICAgICBjb25zdCBsYXRGaWVsZCA9IHBhaXIucGFpci5sYXQ7XG4gICAgICBjb25zdCBsbmdGaWVsZCA9IHBhaXIucGFpci5sbmc7XG4gICAgICBjb25zdCBsYXllck5hbWUgPSBwYWlyLmRlZmF1bHROYW1lO1xuXG4gICAgICBjb25zdCBwcm9wID0ge1xuICAgICAgICBsYWJlbDogbGF5ZXJOYW1lLmxlbmd0aCA/IGxheWVyTmFtZSA6ICdQb2ludCdcbiAgICAgIH07XG5cbiAgICAgIC8vIGRlZmF1bHQgbGF5ZXIgY29sb3IgZm9yIGJlZ2ludHJpcCBhbmQgZHJvcG9mZiBwb2ludFxuICAgICAgaWYgKGxhdEZpZWxkLnZhbHVlIGluIERFRkFVTFRfTEFZRVJfQ09MT1IpIHtcbiAgICAgICAgcHJvcC5jb2xvciA9IGhleFRvUmdiKERFRkFVTFRfTEFZRVJfQ09MT1JbbGF0RmllbGQudmFsdWVdKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHRoZSBmaXJzdCBsYXllciB0byBiZSB2aXNpYmxlXG4gICAgICBpZiAocHJvcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHByb3AuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcHJvcC5jb2x1bW5zID0ge1xuICAgICAgICBsYXQ6IGxhdEZpZWxkLFxuICAgICAgICBsbmc6IGxuZ0ZpZWxkLFxuICAgICAgICBhbHRpdHVkZToge3ZhbHVlOiBudWxsLCBmaWVsZElkeDogLTEsIG9wdGlvbmFsOiB0cnVlfVxuICAgICAgfTtcblxuICAgICAgcHJvcHMucHVzaChwcm9wKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7cHJvcHN9O1xuICB9XG5cbiAgZ2V0RGVmYXVsdExheWVyQ29uZmlnKHByb3BzID0ge30pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZ2V0RGVmYXVsdExheWVyQ29uZmlnKHByb3BzKSxcblxuICAgICAgLy8gYWRkIHN0cm9rZSBjb2xvciB2aXN1YWwgY2hhbm5lbFxuICAgICAgc3Ryb2tlQ29sb3JGaWVsZDogbnVsbCxcbiAgICAgIHN0cm9rZUNvbG9yRG9tYWluOiBbMCwgMV0sXG4gICAgICBzdHJva2VDb2xvclNjYWxlOiAncXVhbnRpbGUnXG4gICAgfTtcbiAgfVxuXG4gIC8vIFRPRE86IGZpeCBjb21wbGV4aXR5XG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHkgKi9cbiAgZm9ybWF0TGF5ZXJEYXRhKF8sIGFsbERhdGEsIGZpbHRlcmVkSW5kZXgsIG9sZExheWVyRGF0YSwgb3B0ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBjb2xvclNjYWxlLFxuICAgICAgY29sb3JEb21haW4sXG4gICAgICBjb2xvckZpZWxkLFxuICAgICAgc3Ryb2tlQ29sb3JGaWVsZCxcbiAgICAgIHN0cm9rZUNvbG9yU2NhbGUsXG4gICAgICBzdHJva2VDb2xvckRvbWFpbixcbiAgICAgIGNvbG9yLFxuICAgICAgc2l6ZUZpZWxkLFxuICAgICAgc2l6ZVNjYWxlLFxuICAgICAgc2l6ZURvbWFpbixcbiAgICAgIHRleHRMYWJlbCxcbiAgICAgIHZpc0NvbmZpZzoge1xuICAgICAgICByYWRpdXNSYW5nZSxcbiAgICAgICAgZml4ZWRSYWRpdXMsXG4gICAgICAgIGNvbG9yUmFuZ2UsXG4gICAgICAgIHN0cm9rZUNvbG9yUmFuZ2UsXG4gICAgICAgIHN0cm9rZUNvbG9yXG4gICAgICB9XG4gICAgfSA9IHRoaXMuY29uZmlnO1xuXG4gICAgLy8gZmlsbCBjb2xvclxuICAgIGNvbnN0IGNTY2FsZSA9XG4gICAgICBjb2xvckZpZWxkICYmXG4gICAgICB0aGlzLmdldFZpc0NoYW5uZWxTY2FsZShcbiAgICAgICAgY29sb3JTY2FsZSxcbiAgICAgICAgY29sb3JEb21haW4sXG4gICAgICAgIGNvbG9yUmFuZ2UuY29sb3JzLm1hcChoZXhUb1JnYilcbiAgICAgICk7XG5cbiAgICAvLyBzdHJva2UgY29sb3JcbiAgICBjb25zdCBzY1NjYWxlID1cbiAgICAgIHN0cm9rZUNvbG9yRmllbGQgJiZcbiAgICAgIHRoaXMuZ2V0VmlzQ2hhbm5lbFNjYWxlKFxuICAgICAgICBzdHJva2VDb2xvclNjYWxlLFxuICAgICAgICBzdHJva2VDb2xvckRvbWFpbixcbiAgICAgICAgc3Ryb2tlQ29sb3JSYW5nZS5jb2xvcnMubWFwKGhleFRvUmdiKVxuICAgICAgKTtcblxuICAgIC8vIHBvaW50IHJhZGl1c1xuICAgIGNvbnN0IHJTY2FsZSA9XG4gICAgICBzaXplRmllbGQgJiZcbiAgICAgIHRoaXMuZ2V0VmlzQ2hhbm5lbFNjYWxlKHNpemVTY2FsZSwgc2l6ZURvbWFpbiwgcmFkaXVzUmFuZ2UsIGZpeGVkUmFkaXVzKTtcblxuICAgIGNvbnN0IGdldFBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbkFjY2Vzc29yKCk7XG5cbiAgICBpZiAoIW9sZExheWVyRGF0YSB8fCBvbGRMYXllckRhdGEuZ2V0UG9zaXRpb24gIT09IGdldFBvc2l0aW9uKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxheWVyTWV0YShhbGxEYXRhLCBnZXRQb3NpdGlvbik7XG4gICAgfVxuXG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKFxuICAgICAgb2xkTGF5ZXJEYXRhICYmXG4gICAgICBvbGRMYXllckRhdGEuZGF0YSAmJlxuICAgICAgb3B0LnNhbWVEYXRhICYmXG4gICAgICBvbGRMYXllckRhdGEuZ2V0UG9zaXRpb24gPT09IGdldFBvc2l0aW9uXG4gICAgKSB7XG4gICAgICBkYXRhID0gb2xkTGF5ZXJEYXRhLmRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBmaWx0ZXJlZEluZGV4LnJlZHVjZSgoYWNjdSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gZ2V0UG9zaXRpb24oe2RhdGE6IGFsbERhdGFbaW5kZXhdfSk7XG5cbiAgICAgICAgLy8gaWYgZG9lc24ndCBoYXZlIHBvaW50IGxhdCBvciBsbmcsIGRvIG5vdCBhZGQgdGhlIHBvaW50XG4gICAgICAgIC8vIGRlY2suZ2wgY2FuJ3QgaGFuZGxlIHBvc2l0aW9uID0gbnVsbFxuICAgICAgICBpZiAoIXBvcy5ldmVyeShOdW1iZXIuaXNGaW5pdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGFjY3U7XG4gICAgICAgIH1cblxuICAgICAgICBhY2N1LnB1c2goe1xuICAgICAgICAgIGRhdGE6IGFsbERhdGFbaW5kZXhdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhY2N1O1xuICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIC8vIGdldCBhbGwgZGlzdGluY3QgY2hhcmFjdGVycyBpbiB0aGUgdGV4dCBsYWJlbHNcbiAgICBjb25zdCBnZXRSYWRpdXMgPSByU2NhbGVcbiAgICAgID8gZCA9PiB0aGlzLmdldEVuY29kZWRDaGFubmVsVmFsdWUoclNjYWxlLCBkLmRhdGEsIHNpemVGaWVsZCwgMClcbiAgICAgIDogMTtcblxuICAgIGNvbnN0IGdldEZpbGxDb2xvciA9IGNTY2FsZVxuICAgICAgPyBkID0+IHRoaXMuZ2V0RW5jb2RlZENoYW5uZWxWYWx1ZShjU2NhbGUsIGQuZGF0YSwgY29sb3JGaWVsZClcbiAgICAgIDogY29sb3I7XG5cbiAgICBjb25zdCBnZXRMaW5lQ29sb3IgPSBzY1NjYWxlXG4gICAgICA/IGQgPT4gdGhpcy5nZXRFbmNvZGVkQ2hhbm5lbFZhbHVlKHNjU2NhbGUsIGQuZGF0YSwgc3Ryb2tlQ29sb3JGaWVsZClcbiAgICAgIDogc3Ryb2tlQ29sb3IgfHwgY29sb3I7XG5cbiAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBiZSBjbGVhbmVkIHVwIGluIHRoZSBncHUtZGF0YS1maWx0ZXIgYnJhbmNoXG4gICAgY29uc3QgdGV4dExhYmVscyA9IHRleHRMYWJlbC5tYXAoKHRsLCBpKSA9PiB7XG4gICAgICBpZiAoIXRsLmZpZWxkKSB7XG4gICAgICAgIC8vIGlmIG5vIGZpZWxkIHNlbGVjdGVkLFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGdldFRleHQ6IG51bGwsXG4gICAgICAgICAgY2hhcmFjdGVyU2V0OiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmdldFRleHRbaV0pIHtcbiAgICAgICAgdGhpcy5nZXRUZXh0W2ldID0gbWVtb2l6ZShwb2ludExhYmVsQWNjZXNzb3IsIHBvaW50TGFiZWxSZXNvbHZlcik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGdldFRleHQgPSB0aGlzLmdldFRleHRbaV0odGwpO1xuICAgICAgbGV0IGNoYXJhY3RlclNldDtcblxuICAgICAgaWYgKFxuICAgICAgICBvbGRMYXllckRhdGEgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShvbGRMYXllckRhdGEudGV4dExhYmVscykgJiZcbiAgICAgICAgb2xkTGF5ZXJEYXRhLnRleHRMYWJlbHNbaV0gJiZcbiAgICAgICAgb3B0LnNhbWVEYXRhICYmXG4gICAgICAgIG9sZExheWVyRGF0YS50ZXh0TGFiZWxzW2ldLmdldFRleHQgPT09IGdldFRleHRcbiAgICAgICkge1xuICAgICAgICBjaGFyYWN0ZXJTZXQgPSBvbGRMYXllckRhdGEudGV4dExhYmVsc1tpXS5jaGFyYWN0ZXJTZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhbGxMYWJlbHMgPSB0bC5maWVsZCA/IGRhdGEubWFwKGdldFRleHQpIDogW107XG4gICAgICAgIGNoYXJhY3RlclNldCA9IHVuaXEoYWxsTGFiZWxzLmpvaW4oJycpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2hhcmFjdGVyU2V0LFxuICAgICAgICBnZXRUZXh0XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGEsXG4gICAgICBnZXRQb3NpdGlvbixcbiAgICAgIGdldEZpbGxDb2xvcixcbiAgICAgIGdldExpbmVDb2xvcixcbiAgICAgIGdldFJhZGl1cyxcbiAgICAgIHRleHRMYWJlbHNcbiAgICB9O1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuXG4gIHVwZGF0ZUxheWVyTWV0YShhbGxEYXRhKSB7XG4gICAgY29uc3QgZ2V0UG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uQWNjZXNzb3IoKTtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLmdldFBvaW50c0JvdW5kcyhhbGxEYXRhLCBkID0+IGdldFBvc2l0aW9uKHtkYXRhOiBkfSkpO1xuICAgIHRoaXMudXBkYXRlTWV0YSh7Ym91bmRzfSk7XG4gIH1cblxuICBnZXRUZXh0T2Zmc2V0KGNvbmZpZywgcmFkaXVzU2NhbGUsIGdldFJhZGl1cywgbWFwU3RhdGUpIHtcbiAgICBjb25zdCBkaXN0YW5jZVNjYWxlID0gZ2V0RGlzdGFuY2VTY2FsZXMobWFwU3RhdGUpO1xuICAgIGNvbnN0IHhNdWx0ID1cbiAgICAgIGNvbmZpZy5hbmNob3IgPT09ICdtaWRkbGUnID8gMCA6IGNvbmZpZy5hbmNob3IgPT09ICdzdGFydCcgPyAxIDogLTE7XG4gICAgY29uc3QgeU11bHQgPVxuICAgICAgY29uZmlnLmFsaWdubWVudCA9PT0gJ2NlbnRlcicgPyAwIDogY29uZmlnLmFsaWdubWVudCA9PT0gJ2JvdHRvbScgPyAxIDogLTE7XG5cbiAgICBjb25zdCBzaXplT2Zmc2V0ID1cbiAgICAgIGNvbmZpZy5hbGlnbm1lbnQgPT09ICdjZW50ZXInXG4gICAgICAgID8gMFxuICAgICAgICA6IGNvbmZpZy5hbGlnbm1lbnQgPT09ICdib3R0b20nXG4gICAgICAgID8gY29uZmlnLnNpemVcbiAgICAgICAgOiBjb25maWcuc2l6ZTtcblxuICAgIGNvbnN0IHBpeGVsUmFkaXVzID0gcmFkaXVzU2NhbGUgKiBkaXN0YW5jZVNjYWxlLnBpeGVsc1Blck1ldGVyWzBdO1xuICAgIGNvbnN0IHBhZGRpbmcgPSAyMDtcblxuICAgIHJldHVybiB0eXBlb2YgZ2V0UmFkaXVzID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGQgPT4gW1xuICAgICAgICAgIHhNdWx0ICogKGdldFJhZGl1cyhkKSAqIHBpeGVsUmFkaXVzICsgcGFkZGluZyksXG4gICAgICAgICAgeU11bHQgKiAoZ2V0UmFkaXVzKGQpICogcGl4ZWxSYWRpdXMgKyBwYWRkaW5nICsgc2l6ZU9mZnNldClcbiAgICAgICAgXVxuICAgICAgOiBbXG4gICAgICAgICAgeE11bHQgKiAoZ2V0UmFkaXVzICogcGl4ZWxSYWRpdXMgKyBwYWRkaW5nKSxcbiAgICAgICAgICB5TXVsdCAqIChnZXRSYWRpdXMgKiBwaXhlbFJhZGl1cyArIHBhZGRpbmcgKyBzaXplT2Zmc2V0KVxuICAgICAgICBdO1xuICB9XG5cbiAgcmVuZGVyTGF5ZXIoe1xuICAgIGRhdGEsXG4gICAgaWR4LFxuICAgIGxheWVySW50ZXJhY3Rpb24sXG4gICAgb2JqZWN0SG92ZXJlZCxcbiAgICBtYXBTdGF0ZSxcbiAgICBpbnRlcmFjdGlvbkNvbmZpZ1xuICB9KSB7XG4gICAgY29uc3QgZW5hYmxlQnJ1c2hpbmcgPSBpbnRlcmFjdGlvbkNvbmZpZy5icnVzaC5lbmFibGVkO1xuICAgIGNvbnN0IHJhZGl1c1NjYWxlID0gdGhpcy5nZXRSYWRpdXNTY2FsZUJ5Wm9vbShtYXBTdGF0ZSk7XG5cbiAgICBjb25zdCBsYXllclByb3BzID0ge1xuICAgICAgLy8gVE9ETzogc3VwcG9ydCBzZXR0aW5nIHN0cm9rZSBhbmQgZmlsbCBzaW11bHRhbmVvdXNseVxuICAgICAgc3Ryb2tlZDogdGhpcy5jb25maWcudmlzQ29uZmlnLm91dGxpbmUsXG4gICAgICBmaWxsZWQ6IHRoaXMuY29uZmlnLnZpc0NvbmZpZy5maWxsZWQsXG4gICAgICByYWRpdXNNaW5QaXhlbHM6IDAsXG4gICAgICBsaW5lV2lkdGhNaW5QaXhlbHM6IHRoaXMuY29uZmlnLnZpc0NvbmZpZy50aGlja25lc3MsXG4gICAgICByYWRpdXNTY2FsZSxcbiAgICAgIC4uLih0aGlzLmNvbmZpZy52aXNDb25maWcuZml4ZWRSYWRpdXMgPyB7fSA6IHtyYWRpdXNNYXhQaXhlbHM6IDUwMH0pXG4gICAgfTtcblxuICAgIGNvbnN0IGludGVyYWN0aW9uID0ge1xuICAgICAgYXV0b0hpZ2hsaWdodDogIWVuYWJsZUJydXNoaW5nLFxuICAgICAgZW5hYmxlQnJ1c2hpbmcsXG4gICAgICBicnVzaFJhZGl1czogaW50ZXJhY3Rpb25Db25maWcuYnJ1c2guY29uZmlnLnNpemUgKiAxMDAwLFxuICAgICAgaGlnaGxpZ2h0Q29sb3I6IHRoaXMuY29uZmlnLmhpZ2hsaWdodENvbG9yXG4gICAgfTtcblxuICAgIGNvbnN0IHt0ZXh0TGFiZWx9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgdXBkYXRlVHJpZ2dlcnMgPSB7XG4gICAgICBnZXRQb3NpdGlvbjoge1xuICAgICAgICBjb2x1bW5zOiB0aGlzLmNvbmZpZy5jb2x1bW5zXG4gICAgICB9LFxuICAgICAgZ2V0UmFkaXVzOiB7XG4gICAgICAgIHNpemVGaWVsZDogdGhpcy5jb25maWcuc2l6ZUZpZWxkLFxuICAgICAgICByYWRpdXNSYW5nZTogdGhpcy5jb25maWcudmlzQ29uZmlnLnJhZGl1c1JhbmdlLFxuICAgICAgICBmaXhlZFJhZGl1czogdGhpcy5jb25maWcudmlzQ29uZmlnLmZpeGVkUmFkaXVzLFxuICAgICAgICBzaXplU2NhbGU6IHRoaXMuY29uZmlnLnNpemVTY2FsZVxuICAgICAgfSxcbiAgICAgIGdldEZpbGxDb2xvcjoge1xuICAgICAgICBjb2xvcjogdGhpcy5jb25maWcuY29sb3IsXG4gICAgICAgIGNvbG9yRmllbGQ6IHRoaXMuY29uZmlnLmNvbG9yRmllbGQsXG4gICAgICAgIGNvbG9yUmFuZ2U6IHRoaXMuY29uZmlnLnZpc0NvbmZpZy5jb2xvclJhbmdlLFxuICAgICAgICBjb2xvclNjYWxlOiB0aGlzLmNvbmZpZy5jb2xvclNjYWxlXG4gICAgICB9LFxuICAgICAgZ2V0TGluZUNvbG9yOiB7XG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbmZpZy52aXNDb25maWcuc3Ryb2tlQ29sb3IsXG4gICAgICAgIGNvbG9yRmllbGQ6IHRoaXMuY29uZmlnLnN0cm9rZUNvbG9yRmllbGQsXG4gICAgICAgIGNvbG9yUmFuZ2U6IHRoaXMuY29uZmlnLnZpc0NvbmZpZy5zdHJva2VDb2xvclJhbmdlLFxuICAgICAgICBjb2xvclNjYWxlOiB0aGlzLmNvbmZpZy5zdHJva2VDb2xvclNjYWxlXG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBbXG4gICAgICBuZXcgU2NhdHRlcnBsb3RCcnVzaGluZ0xheWVyKHtcbiAgICAgICAgLi4ubGF5ZXJQcm9wcyxcbiAgICAgICAgLi4ubGF5ZXJJbnRlcmFjdGlvbixcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgLi4uaW50ZXJhY3Rpb24sXG4gICAgICAgIGlkeCxcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIG9wYWNpdHk6IHRoaXMuY29uZmlnLnZpc0NvbmZpZy5vcGFjaXR5LFxuICAgICAgICBwaWNrYWJsZTogdHJ1ZSxcbiAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgIC8vIGNpcmNsZXMgd2lsbCBiZSBmbGF0IG9uIHRoZSBtYXAgd2hlbiB0aGUgYWx0aXR1ZGUgY29sdW1uIGlzIG5vdCB1c2VkXG4gICAgICAgICAgZGVwdGhUZXN0OiB0aGlzLmNvbmZpZy5jb2x1bW5zLmFsdGl0dWRlLmZpZWxkSWR4ID4gLTFcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlVHJpZ2dlcnNcbiAgICAgIH0pLFxuICAgICAgLy8gaG92ZXIgbGF5ZXJcbiAgICAgIC4uLih0aGlzLmlzTGF5ZXJIb3ZlcmVkKG9iamVjdEhvdmVyZWQpXG4gICAgICAgID8gW1xuICAgICAgICAgICAgbmV3IFNjYXR0ZXJwbG90QnJ1c2hpbmdMYXllcih7XG4gICAgICAgICAgICAgIC4uLmxheWVyUHJvcHMsXG4gICAgICAgICAgICAgIGlkOiBgJHt0aGlzLmlkfS1ob3ZlcmVkYCxcbiAgICAgICAgICAgICAgZGF0YTogW29iamVjdEhvdmVyZWQub2JqZWN0XSxcbiAgICAgICAgICAgICAgZ2V0TGluZUNvbG9yOiB0aGlzLmNvbmZpZy5oaWdobGlnaHRDb2xvcixcbiAgICAgICAgICAgICAgZ2V0RmlsbENvbG9yOiB0aGlzLmNvbmZpZy5oaWdobGlnaHRDb2xvcixcbiAgICAgICAgICAgICAgZ2V0UmFkaXVzOiBkYXRhLmdldFJhZGl1cyxcbiAgICAgICAgICAgICAgZ2V0UG9zaXRpb246IGRhdGEuZ2V0UG9zaXRpb24sXG4gICAgICAgICAgICAgIHBpY2thYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdXG4gICAgICAgIDogW10pLFxuICAgICAgLy8gdGV4dCBsYWJlbCBsYXllclxuICAgICAgLi4uZGF0YS50ZXh0TGFiZWxzLnJlZHVjZSgoYWNjdSwgZCwgaSkgPT4ge1xuICAgICAgICBpZiAoZC5nZXRUZXh0KSB7XG4gICAgICAgICAgYWNjdS5wdXNoKFxuICAgICAgICAgICAgbmV3IFRleHRMYXllcih7XG4gICAgICAgICAgICAgIC4uLmxheWVySW50ZXJhY3Rpb24sXG4gICAgICAgICAgICAgIGlkOiBgJHt0aGlzLmlkfS1sYWJlbC0ke3RleHRMYWJlbFtpXS5maWVsZC5uYW1lfWAsXG4gICAgICAgICAgICAgIGRhdGE6IGRhdGEuZGF0YSxcbiAgICAgICAgICAgICAgZ2V0UG9zaXRpb246IGRhdGEuZ2V0UG9zaXRpb24sXG4gICAgICAgICAgICAgIGdldFRleHQ6IGQuZ2V0VGV4dCxcbiAgICAgICAgICAgICAgY2hhcmFjdGVyU2V0OiBkLmNoYXJhY3RlclNldCxcbiAgICAgICAgICAgICAgZ2V0UGl4ZWxPZmZzZXQ6IHRoaXMuZ2V0VGV4dE9mZnNldChcbiAgICAgICAgICAgICAgICB0ZXh0TGFiZWxbaV0sXG4gICAgICAgICAgICAgICAgcmFkaXVzU2NhbGUsXG4gICAgICAgICAgICAgICAgZGF0YS5nZXRSYWRpdXMsXG4gICAgICAgICAgICAgICAgbWFwU3RhdGVcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgZ2V0U2l6ZTogMSxcbiAgICAgICAgICAgICAgc2l6ZVNjYWxlOiB0ZXh0TGFiZWxbaV0uc2l6ZSxcbiAgICAgICAgICAgICAgZ2V0VGV4dEFuY2hvcjogdGV4dExhYmVsW2ldLmFuY2hvcixcbiAgICAgICAgICAgICAgZ2V0QWxpZ25tZW50QmFzZWxpbmU6IHRleHRMYWJlbFtpXS5hbGlnbm1lbnQsXG4gICAgICAgICAgICAgIGdldENvbG9yOiB0ZXh0TGFiZWxbaV0uY29sb3IsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICAvLyB0ZXh0IHdpbGwgYWx3YXlzIHNob3cgb24gdG9wIG9mIGFsbCBsYXllcnNcbiAgICAgICAgICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgICAgICAgICAgZ2V0UG9zaXRpb246IHRoaXMuY29uZmlnLmNvbHVtbnMsXG4gICAgICAgICAgICAgICAgZ2V0VGV4dDogdGV4dExhYmVsW2ldLmZpZWxkLm5hbWUsXG4gICAgICAgICAgICAgICAgZ2V0UGl4ZWxPZmZzZXQ6IHtcbiAgICAgICAgICAgICAgICAgIC4uLnVwZGF0ZVRyaWdnZXJzLmdldFJhZGl1cyxcbiAgICAgICAgICAgICAgICAgIG1hcFN0YXRlLFxuICAgICAgICAgICAgICAgICAgYW5jaG9yOiB0ZXh0TGFiZWxbaV0uYW5jaG9yLFxuICAgICAgICAgICAgICAgICAgYWxpZ25tZW50OiB0ZXh0TGFiZWxbaV0uYWxpZ25tZW50XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRUZXh0QW5jaG9yOiB0ZXh0TGFiZWxbaV0uYW5jaG9yLFxuICAgICAgICAgICAgICAgIGdldEFsaWdubWVudEJhc2VsaW5lOiB0ZXh0TGFiZWxbaV0uYWxpZ25tZW50LFxuICAgICAgICAgICAgICAgIGdldENvbG9yOiB0ZXh0TGFiZWxbaV0uY29sb3JcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1O1xuICAgICAgfSwgW10pXG4gICAgXTtcbiAgfVxufVxuIl19