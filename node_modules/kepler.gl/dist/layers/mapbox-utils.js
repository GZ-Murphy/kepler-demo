"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateMapboxLayers = generateMapboxLayers;
exports.updateMapboxLayers = updateMapboxLayers;
exports.geojsonFromPoints = geojsonFromPoints;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _baseLayer = require("./base-layer");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This function will convert layers to mapbox layers
 * @param {Array<Object>} layers the layers to be converted
 * @param {Array<Object>} layerData extra layer information
 * @param {Array<Number>} layerOrder the order by which we should convert layers
 * @param {Object} layersToRender {[id]: true | false} object whether each layer should be rendered
 * @returns {Object} {[id]: layer}
 */
function generateMapboxLayers() {
  var layers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var layerData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var layerOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var layersToRender = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (layerData.length > 0) {
    return layerOrder.slice().reverse().filter(function (idx) {
      return layers[idx].overlayType === _baseLayer.OVERLAY_TYPE.mapboxgl && layersToRender[layers[idx].id];
    }).reduce(function (accu, index) {
      var layer = layers[index];
      return _objectSpread({}, accu, (0, _defineProperty2["default"])({}, layer.id, {
        id: layer.id,
        data: layerData[index].data,
        isVisible: layer.config.isVisible,
        config: layerData[index].config,
        sourceId: layerData[index].config.source
      }));
    }, {});
  }

  return {};
}
/**
 * Update mapbox layers on the given map
 * @param {Object} map
 * @param {Object} newLayers Map of new mapbox layers to be displayed
 * @param {Object} oldLayers Map of the old layers to be compare with the current ones to detect deleted layers
 *                  {layerId: sourceId}
 */


function updateMapboxLayers(map) {
  var newLayers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var oldLayers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  // delete no longer existed old layers
  if (oldLayers) {
    checkAndRemoveOldLayers(map, oldLayers, newLayers);
  } // insert or update new layer


  Object.values(newLayers).forEach(function (overlay) {
    var layerId = overlay.id,
        config = overlay.config,
        data = overlay.data,
        sourceId = overlay.sourceId,
        isVisible = overlay.isVisible;

    if (!data && !config) {
      return;
    }

    var _ref = oldLayers && oldLayers[layerId] || {},
        oldData = _ref.data,
        oldConfig = _ref.config;

    if (data && data !== oldData) {
      updateSourceData(map, sourceId, data);
    } // compare with previous configs


    if (oldConfig !== config) {
      updateLayerConfig(map, layerId, config, isVisible);
    }
  });
}

function checkAndRemoveOldLayers(map, oldLayers, newLayers) {
  Object.keys(oldLayers).forEach(function (layerId) {
    if (!newLayers[layerId]) {
      map.removeLayer(layerId);
    }
  });
}

function updateLayerConfig(map, layerId, config, isVisible) {
  var mapboxLayer = map.getLayer(layerId);

  if (mapboxLayer) {
    // check if layer already is set
    // remove it if exists
    map.removeLayer(layerId);
  }

  map.addLayer(config);
  map.setLayoutProperty(layerId, 'visibility', isVisible ? 'visible' : 'none');
}

function updateSourceData(map, sourceId, data) {
  var source = map.getSource(sourceId);

  if (!source) {
    map.addSource(sourceId, {
      type: 'geojson',
      data: data
    });
  } else {
    source.setData(data);
  }
}
/**
 *
 * @param points
 * @param columns {
 * lat: {fieldIdx},
 * lng: {fieldIdx},
 * alt: {fieldIdx}
 * }
 * @param properties [{label: {fieldIdx}]
 * @returns {{type: string, properties: {}, features: {type: string, properties: {}, geometry: {type: string, coordinates: *[]}}[]}}
 */


function geojsonFromPoints() {
  var allData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var filteredIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var columns = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var properties = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var geojson = {
    type: 'FeatureCollection',
    features: []
  };

  var _loop = function _loop(i) {
    var point = allData[filteredIndex[i]];
    geojson.features.push({
      type: 'Feature',
      properties: properties.reduce(function (_final, property) {
        return _objectSpread({}, _final, (0, _defineProperty2["default"])({}, property.name, point[property.tableFieldIndex - 1]));
      }, {}),
      geometry: {
        type: 'Point',
        coordinates: [columns.lng ? point[columns.lng.fieldIdx] : null, // lng
        columns.lat ? point[columns.lat.fieldIdx] : null // lat
        ]
      }
    });
  };

  for (var i = 0; i < filteredIndex.length; i++) {
    _loop(i);
  }

  return geojson;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYXllcnMvbWFwYm94LXV0aWxzLmpzIl0sIm5hbWVzIjpbImdlbmVyYXRlTWFwYm94TGF5ZXJzIiwibGF5ZXJzIiwibGF5ZXJEYXRhIiwibGF5ZXJPcmRlciIsImxheWVyc1RvUmVuZGVyIiwibGVuZ3RoIiwic2xpY2UiLCJyZXZlcnNlIiwiZmlsdGVyIiwiaWR4Iiwib3ZlcmxheVR5cGUiLCJPVkVSTEFZX1RZUEUiLCJtYXBib3hnbCIsImlkIiwicmVkdWNlIiwiYWNjdSIsImluZGV4IiwibGF5ZXIiLCJkYXRhIiwiaXNWaXNpYmxlIiwiY29uZmlnIiwic291cmNlSWQiLCJzb3VyY2UiLCJ1cGRhdGVNYXBib3hMYXllcnMiLCJtYXAiLCJuZXdMYXllcnMiLCJvbGRMYXllcnMiLCJjaGVja0FuZFJlbW92ZU9sZExheWVycyIsIk9iamVjdCIsInZhbHVlcyIsImZvckVhY2giLCJvdmVybGF5IiwibGF5ZXJJZCIsIm9sZERhdGEiLCJvbGRDb25maWciLCJ1cGRhdGVTb3VyY2VEYXRhIiwidXBkYXRlTGF5ZXJDb25maWciLCJrZXlzIiwicmVtb3ZlTGF5ZXIiLCJtYXBib3hMYXllciIsImdldExheWVyIiwiYWRkTGF5ZXIiLCJzZXRMYXlvdXRQcm9wZXJ0eSIsImdldFNvdXJjZSIsImFkZFNvdXJjZSIsInR5cGUiLCJzZXREYXRhIiwiZ2VvanNvbkZyb21Qb2ludHMiLCJhbGxEYXRhIiwiZmlsdGVyZWRJbmRleCIsImNvbHVtbnMiLCJwcm9wZXJ0aWVzIiwiZ2VvanNvbiIsImZlYXR1cmVzIiwiaSIsInBvaW50IiwicHVzaCIsImZpbmFsIiwicHJvcGVydHkiLCJuYW1lIiwidGFibGVGaWVsZEluZGV4IiwiZ2VvbWV0cnkiLCJjb29yZGluYXRlcyIsImxuZyIsImZpZWxkSWR4IiwibGF0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBb0JBOzs7Ozs7QUFFQTs7Ozs7Ozs7QUFRTyxTQUFTQSxvQkFBVCxHQUtMO0FBQUEsTUFKQUMsTUFJ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QSxVQUF0Q0EsQ0FBc0M7QUFtQjlDOztBQUVELFNBQU9GLE9BQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxOSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7T1ZFUkxBWV9UWVBFfSBmcm9tICcuL2Jhc2UtbGF5ZXInO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGxheWVycyB0byBtYXBib3ggbGF5ZXJzXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGxheWVycyB0aGUgbGF5ZXJzIHRvIGJlIGNvbnZlcnRlZFxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBsYXllckRhdGEgZXh0cmEgbGF5ZXIgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSB7QXJyYXk8TnVtYmVyPn0gbGF5ZXJPcmRlciB0aGUgb3JkZXIgYnkgd2hpY2ggd2Ugc2hvdWxkIGNvbnZlcnQgbGF5ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXJzVG9SZW5kZXIge1tpZF06IHRydWUgfCBmYWxzZX0gb2JqZWN0IHdoZXRoZXIgZWFjaCBsYXllciBzaG91bGQgYmUgcmVuZGVyZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IHtbaWRdOiBsYXllcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlTWFwYm94TGF5ZXJzKFxuICBsYXllcnMgPSBbXSxcbiAgbGF5ZXJEYXRhID0gW10sXG4gIGxheWVyT3JkZXIgPSBbXSxcbiAgbGF5ZXJzVG9SZW5kZXIgPSB7fVxuKSB7XG4gIGlmIChsYXllckRhdGEubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBsYXllck9yZGVyXG4gICAgICAuc2xpY2UoKVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLmZpbHRlcihcbiAgICAgICAgaWR4ID0+XG4gICAgICAgICAgbGF5ZXJzW2lkeF0ub3ZlcmxheVR5cGUgPT09IE9WRVJMQVlfVFlQRS5tYXBib3hnbCAmJlxuICAgICAgICAgIGxheWVyc1RvUmVuZGVyW2xheWVyc1tpZHhdLmlkXVxuICAgICAgKVxuICAgICAgLnJlZHVjZSgoYWNjdSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSBsYXllcnNbaW5kZXhdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmFjY3UsXG4gICAgICAgICAgW2xheWVyLmlkXToge1xuICAgICAgICAgICAgaWQ6IGxheWVyLmlkLFxuICAgICAgICAgICAgZGF0YTogbGF5ZXJEYXRhW2luZGV4XS5kYXRhLFxuICAgICAgICAgICAgaXNWaXNpYmxlOiBsYXllci5jb25maWcuaXNWaXNpYmxlLFxuICAgICAgICAgICAgY29uZmlnOiBsYXllckRhdGFbaW5kZXhdLmNvbmZpZyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiBsYXllckRhdGFbaW5kZXhdLmNvbmZpZy5zb3VyY2VcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LCB7fSk7XG4gIH1cblxuICByZXR1cm4ge307XG59XG5cbi8qKlxuICogVXBkYXRlIG1hcGJveCBsYXllcnMgb24gdGhlIGdpdmVuIG1hcFxuICogQHBhcmFtIHtPYmplY3R9IG1hcFxuICogQHBhcmFtIHtPYmplY3R9IG5ld0xheWVycyBNYXAgb2YgbmV3IG1hcGJveCBsYXllcnMgdG8gYmUgZGlzcGxheWVkXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkTGF5ZXJzIE1hcCBvZiB0aGUgb2xkIGxheWVycyB0byBiZSBjb21wYXJlIHdpdGggdGhlIGN1cnJlbnQgb25lcyB0byBkZXRlY3QgZGVsZXRlZCBsYXllcnNcbiAqICAgICAgICAgICAgICAgICAge2xheWVySWQ6IHNvdXJjZUlkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTWFwYm94TGF5ZXJzKG1hcCwgbmV3TGF5ZXJzID0ge30sIG9sZExheWVycyA9IG51bGwpIHtcbiAgLy8gZGVsZXRlIG5vIGxvbmdlciBleGlzdGVkIG9sZCBsYXllcnNcbiAgaWYgKG9sZExheWVycykge1xuICAgIGNoZWNrQW5kUmVtb3ZlT2xkTGF5ZXJzKG1hcCwgb2xkTGF5ZXJzLCBuZXdMYXllcnMpO1xuICB9XG5cbiAgLy8gaW5zZXJ0IG9yIHVwZGF0ZSBuZXcgbGF5ZXJcbiAgT2JqZWN0LnZhbHVlcyhuZXdMYXllcnMpLmZvckVhY2gob3ZlcmxheSA9PiB7XG4gICAgY29uc3Qge2lkOiBsYXllcklkLCBjb25maWcsIGRhdGEsIHNvdXJjZUlkLCBpc1Zpc2libGV9ID0gb3ZlcmxheTtcbiAgICBpZiAoIWRhdGEgJiYgIWNvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtkYXRhOiBvbGREYXRhLCBjb25maWc6IG9sZENvbmZpZ30gPVxuICAgICAgKG9sZExheWVycyAmJiBvbGRMYXllcnNbbGF5ZXJJZF0pIHx8IHt9O1xuXG4gICAgaWYgKGRhdGEgJiYgZGF0YSAhPT0gb2xkRGF0YSkge1xuICAgICAgdXBkYXRlU291cmNlRGF0YShtYXAsIHNvdXJjZUlkLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHdpdGggcHJldmlvdXMgY29uZmlnc1xuICAgIGlmIChvbGRDb25maWcgIT09IGNvbmZpZykge1xuICAgICAgdXBkYXRlTGF5ZXJDb25maWcobWFwLCBsYXllcklkLCBjb25maWcsIGlzVmlzaWJsZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY2hlY2tBbmRSZW1vdmVPbGRMYXllcnMobWFwLCBvbGRMYXllcnMsIG5ld0xheWVycykge1xuICBPYmplY3Qua2V5cyhvbGRMYXllcnMpLmZvckVhY2gobGF5ZXJJZCA9PiB7XG4gICAgaWYgKCFuZXdMYXllcnNbbGF5ZXJJZF0pIHtcbiAgICAgIG1hcC5yZW1vdmVMYXllcihsYXllcklkKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMYXllckNvbmZpZyhtYXAsIGxheWVySWQsIGNvbmZpZywgaXNWaXNpYmxlKSB7XG4gIGNvbnN0IG1hcGJveExheWVyID0gbWFwLmdldExheWVyKGxheWVySWQpO1xuXG4gIGlmIChtYXBib3hMYXllcikge1xuICAgIC8vIGNoZWNrIGlmIGxheWVyIGFscmVhZHkgaXMgc2V0XG4gICAgLy8gcmVtb3ZlIGl0IGlmIGV4aXN0c1xuICAgIG1hcC5yZW1vdmVMYXllcihsYXllcklkKTtcbiAgfVxuXG4gIG1hcC5hZGRMYXllcihjb25maWcpO1xuICBtYXAuc2V0TGF5b3V0UHJvcGVydHkobGF5ZXJJZCwgJ3Zpc2liaWxpdHknLCBpc1Zpc2libGUgPyAndmlzaWJsZScgOiAnbm9uZScpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTb3VyY2VEYXRhKG1hcCwgc291cmNlSWQsIGRhdGEpIHtcbiAgY29uc3Qgc291cmNlID0gbWFwLmdldFNvdXJjZShzb3VyY2VJZCk7XG5cbiAgaWYgKCFzb3VyY2UpIHtcbiAgICBtYXAuYWRkU291cmNlKHNvdXJjZUlkLCB7XG4gICAgICB0eXBlOiAnZ2VvanNvbicsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc291cmNlLnNldERhdGEoZGF0YSk7XG4gIH1cbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBwb2ludHNcbiAqIEBwYXJhbSBjb2x1bW5zIHtcbiAqIGxhdDoge2ZpZWxkSWR4fSxcbiAqIGxuZzoge2ZpZWxkSWR4fSxcbiAqIGFsdDoge2ZpZWxkSWR4fVxuICogfVxuICogQHBhcmFtIHByb3BlcnRpZXMgW3tsYWJlbDoge2ZpZWxkSWR4fV1cbiAqIEByZXR1cm5zIHt7dHlwZTogc3RyaW5nLCBwcm9wZXJ0aWVzOiB7fSwgZmVhdHVyZXM6IHt0eXBlOiBzdHJpbmcsIHByb3BlcnRpZXM6IHt9LCBnZW9tZXRyeToge3R5cGU6IHN0cmluZywgY29vcmRpbmF0ZXM6ICpbXX19W119fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VvanNvbkZyb21Qb2ludHMoXG4gIGFsbERhdGEgPSBbXSxcbiAgZmlsdGVyZWRJbmRleCA9IFtdLFxuICBjb2x1bW5zID0ge30sXG4gIHByb3BlcnRpZXMgPSBbXVxuKSB7XG4gIGNvbnN0IGdlb2pzb24gPSB7XG4gICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICBmZWF0dXJlczogW11cbiAgfTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmVkSW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwb2ludCA9IGFsbERhdGFbZmlsdGVyZWRJbmRleFtpXV07XG4gICAgZ2VvanNvbi5mZWF0dXJlcy5wdXNoKHtcbiAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMucmVkdWNlKFxuICAgICAgICAoZmluYWwsIHByb3BlcnR5KSA9PiAoe1xuICAgICAgICAgIC4uLmZpbmFsLFxuICAgICAgICAgIFtwcm9wZXJ0eS5uYW1lXTogcG9pbnRbcHJvcGVydHkudGFibGVGaWVsZEluZGV4IC0gMV1cbiAgICAgICAgfSksXG4gICAgICAgIHt9XG4gICAgICApLFxuICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgdHlwZTogJ1BvaW50JyxcbiAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICBjb2x1bW5zLmxuZyA/IHBvaW50W2NvbHVtbnMubG5nLmZpZWxkSWR4XSA6IG51bGwsIC8vIGxuZ1xuICAgICAgICAgIGNvbHVtbnMubGF0ID8gcG9pbnRbY29sdW1ucy5sYXQuZmllbGRJZHhdIDogbnVsbCAvLyBsYXRcbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGdlb2pzb247XG59XG4iXX0=