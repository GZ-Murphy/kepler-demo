"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMapStyles = getMapStyles;
exports.getInitialInputStyle = getInitialInputStyle;
exports.set3dBuildingColorUpdater = exports.addCustomMapStyleUpdater = exports.inputMapStyleUpdater = exports.loadCustomMapStyleUpdater = exports.resetMapConfigMapStyleUpdater = exports.receiveMapConfigUpdater = exports.requestMapStylesUpdater = exports.loadMapStyleErrUpdater = exports.loadMapStylesUpdater = exports.mapStyleChangeUpdater = exports.mapConfigChangeUpdater = exports.initMapStyleUpdater = exports.INITIAL_MAP_STYLE = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _tasks = _interopRequireWildcard(require("react-palm/tasks"));

var _lodash = _interopRequireDefault(require("lodash.clonedeep"));

var _mapboxGlStyleEditor = require("../utils/map-style-utils/mapbox-gl-style-editor");

var _defaultSettings = require("../constants/default-settings");

var _utils = require("../utils/utils");

var _tasks2 = require("../tasks/tasks");

var _mapStyleActions = require("../actions/map-style-actions");

var _d3Color = require("d3-color");

var _colorUtils = require("../utils/color-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var DEFAULT_BLDG_COLOR = '#D1CEC7';

var getDefaultState = function getDefaultState() {
  var visibleLayerGroups = {};
  var styleType = 'dark';
  var topLayerGroups = {};
  return {
    styleType: styleType,
    visibleLayerGroups: visibleLayerGroups,
    topLayerGroups: topLayerGroups,
    mapStyles: _defaultSettings.DEFAULT_MAP_STYLES.reduce(function (accu, curr) {
      return _objectSpread({}, accu, (0, _defineProperty2["default"])({}, curr.id, curr));
    }, {}),
    // save mapbox access token
    mapboxApiAccessToken: null,
    mapboxApiUrl: _defaultSettings.DEFAULT_MAPBOX_API_URL,
    mapStylesReplaceDefault: false,
    inputStyle: getInitialInputStyle(),
    threeDBuildingColor: (0, _colorUtils.hexToRgb)(DEFAULT_BLDG_COLOR),
    custom3DBuildingColor: false
  };
};
/**
 * Updaters for `mapStyle`. Can be used in your root reducer to directly modify kepler.gl's state.
 * Read more about [Using updaters](../advanced-usage/using-updaters.md)
 * @public
 * @example
 *
 * import keplerGlReducer, {mapStyleUpdaters} from 'kepler.gl/reducers';
 * // Root Reducer
 * const reducers = combineReducers({
 *  keplerGl: keplerGlReducer,
 *  app: appReducer
 * });
 *
 * const composedReducer = (state, action) => {
 *  switch (action.type) {
 *    // click button to hide label from background map
 *    case 'CLICK_BUTTON':
 *      return {
 *        ...state,
 *        keplerGl: {
 *          ...state.keplerGl,
 *          foo: {
 *             ...state.keplerGl.foo,
 *             mapStyle: mapStyleUpdaters.mapConfigChangeUpdater(
 *               mapStyle,
 *               {payload: {visibleLayerGroups: {label: false, road: true, background: true}}}
 *             )
 *          }
 *        }
 *      };
 *  }
 *  return reducers(state, action);
 * };
 *
 * export default composedReducer;
 */

/* eslint-disable no-unused-vars */


var mapStyleUpdaters = null;
/* eslint-enable no-unused-vars */

/**
 * Default initial `mapStyle`
 * @memberof mapStyleUpdaters
 * @constant
 * @property {string} styleType - Default: `'dark'`
 * @property {Object} visibleLayerGroups - Default: `{}`
 * @property {Object} topLayerGroups - Default: `{}`
 * @property {Object} mapStyles - mapping from style key to style object
 * @property {string} mapboxApiAccessToken - Default: `null`
 * @Property {string} mapboxApiUrl - Default null
 * @Property {Boolean} mapStylesReplaceDefault - Default: `false`
 * @property {Object} inputStyle - Default: `{}`
 * @property {Array} threeDBuildingColor - Default: `[r, g, b]`
 * @public
 */

var INITIAL_MAP_STYLE = getDefaultState();
/**
 * Create two map styles from preset map style, one for top map one for bottom
 *
 * @param {string} styleType - current map style
 * @param {Object} visibleLayerGroups - visible layers of bottom map
 * @param {Object} topLayerGroups - visible layers of top map
 * @param {Object} mapStyles - a dictionary of all map styles
 * @returns {Object} bottomMapStyle | topMapStyle | isRaster
 */

exports.INITIAL_MAP_STYLE = INITIAL_MAP_STYLE;

function getMapStyles(_ref) {
  var styleType = _ref.styleType,
      visibleLayerGroups = _ref.visibleLayerGroups,
      topLayerGroups = _ref.topLayerGroups,
      mapStyles = _ref.mapStyles;
  var mapStyle = mapStyles[styleType]; // style might not be loaded yet

  if (!mapStyle || !mapStyle.style) {
    return {};
  }

  var editable = Object.keys(visibleLayerGroups).length;
  var bottomMapStyle = !editable ? mapStyle.style : (0, _mapboxGlStyleEditor.editBottomMapStyle)({
    id: styleType,
    mapStyle: mapStyle,
    visibleLayerGroups: visibleLayerGroups
  });
  var hasTopLayer = editable && Object.values(topLayerGroups).some(function (v) {
    return v;
  }); // mute top layer if not visible in bottom layer

  var topLayers = hasTopLayer && Object.keys(topLayerGroups).reduce(function (accu, key) {
    return _objectSpread({}, accu, (0, _defineProperty2["default"])({}, key, topLayerGroups[key] && visibleLayerGroups[key]));
  }, {});
  var topMapStyle = hasTopLayer ? (0, _mapboxGlStyleEditor.editTopMapStyle)({
    id: styleType,
    mapStyle: mapStyle,
    visibleLayerGroups: topLayers
  }) : null;
  return {
    bottomMapStyle: bottomMapStyle,
    topMapStyle: topMapStyle,
    editable: editable
  };
}

function findLayerFillColor(layer) {
  return layer && layer.paint && layer.paint['background-color'];
}

function get3DBuildingColor(style) {
  // set building color to be the same as the background color.
  if (!style.style) {
    return DEFAULT_BLDG_COLOR;
  }

  var backgroundLayer = (style.style.layers || []).find(function (_ref2) {
    var id = _ref2.id;
    return id === 'background';
  });
  var buildingLayer = (style.style.layers || []).find(function (_ref3) {
    var id = _ref3.id;
    return id.match(/building/);
  });
  var buildingColor = findLayerFillColor(buildingLayer) || findLayerFillColor(backgroundLayer) || DEFAULT_BLDG_COLOR; // brighten or darken building based on style

  var operation = style.id.match(/(?=(dark|night))/) ? 'brighter' : 'darker';
  var alpha = 0.2;
  var rgbObj = (0, _d3Color.rgb)(buildingColor)[operation]([alpha]);
  return [rgbObj.r, rgbObj.g, rgbObj.b];
}

function getLayerGroupsFromStyle(style) {
  return Array.isArray(style.layers) ? _defaultSettings.DEFAULT_LAYER_GROUPS.filter(function (lg) {
    return style.layers.filter(lg.filter).length;
  }) : [];
} // Updaters

/**
 * Propagate `mapStyle` reducer with `mapboxApiAccessToken` and `mapStylesReplaceDefault`.
 * if mapStylesReplaceDefault is true mapStyles is emptied; loadMapStylesUpdater() will
 * populate mapStyles.
 *
 * @memberof mapStyleUpdaters
 * @param {Object} state
 * @param {Object} action
 * @param {Object} action.payload
 * @param {string} action.payload.mapboxApiAccessToken
 * @returns {Object} nextState
 * @public
 */


var initMapStyleUpdater = function initMapStyleUpdater(state, action) {
  return _objectSpread({}, state, {
    // save mapbox access token to map style state
    mapboxApiAccessToken: (action.payload || {}).mapboxApiAccessToken,
    mapboxApiUrl: (action.payload || {}).mapboxApiUrl || state.mapboxApiUrl,
    mapStyles: action.payload && !action.payload.mapStylesReplaceDefault ? state.mapStyles : {},
    mapStylesReplaceDefault: action.payload.mapStylesReplaceDefault || false
  });
}; // });

/**
 * Update `visibleLayerGroups`to change layer group visibility
 * @memberof mapStyleUpdaters
 * @param {Object} state `mapStyle`
 * @param {Object} action
 * @param {Object} action.payload new config `{visibleLayerGroups: {label: false, road: true, background: true}}`
 * @returns {Object} nextState
 * @public
 */


exports.initMapStyleUpdater = initMapStyleUpdater;

var mapConfigChangeUpdater = function mapConfigChangeUpdater(state, action) {
  return _objectSpread({}, state, {}, action.payload, {}, getMapStyles(_objectSpread({}, state, {}, action.payload)));
};
/**
 * Change to another map style. The selected style should already been loaded into `mapStyle.mapStyles`
 * @memberof mapStyleUpdaters
 * @param {Object} state `mapStyle`
 * @param {Object} action
 * @param {string} action.payload
 * @returns {Object} nextState
 * @public
 */


exports.mapConfigChangeUpdater = mapConfigChangeUpdater;

var mapStyleChangeUpdater = function mapStyleChangeUpdater(state, _ref4) {
  var styleType = _ref4.payload;

  if (!state.mapStyles[styleType]) {
    // we might not have received the style yet
    return state;
  }

  var defaultLGVisibility = (0, _mapboxGlStyleEditor.getDefaultLayerGroupVisibility)(state.mapStyles[styleType]);
  var visibleLayerGroups = (0, _mapboxGlStyleEditor.mergeLayerGroupVisibility)(defaultLGVisibility, state.visibleLayerGroups);
  var threeDBuildingColor = state.custom3DBuildingColor ? state.threeDBuildingColor : get3DBuildingColor(state.mapStyles[styleType]);
  return _objectSpread({}, state, {
    styleType: styleType,
    visibleLayerGroups: visibleLayerGroups,
    threeDBuildingColor: threeDBuildingColor
  }, getMapStyles(_objectSpread({}, state, {
    visibleLayerGroups: visibleLayerGroups,
    styleType: styleType
  })));
};
/**
 * Callback when load map style success
 * @memberof mapStyleUpdaters
 * @param {Object} state `mapStyle`
 * @param {Object} action
 * @param {Object} action.payload a `{[id]: style}` mapping
 * @return {Object} nextState
 * @public
 */


exports.mapStyleChangeUpdater = mapStyleChangeUpdater;

var loadMapStylesUpdater = function loadMapStylesUpdater(state, action) {
  var newStyles = action.payload || {};
  var addLayerGroups = Object.keys(newStyles).reduce(function (accu, id) {
    return _objectSpread({}, accu, (0, _defineProperty2["default"])({}, id, _objectSpread({}, newStyles[id], {
      layerGroups: newStyles[id].layerGroups || getLayerGroupsFromStyle(newStyles[id].style)
    })));
  }, {}); // add new styles to state

  var newState = _objectSpread({}, state, {
    mapStyles: _objectSpread({}, state.mapStyles, {}, addLayerGroups)
  });

  return newStyles[state.styleType] ? mapStyleChangeUpdater(newState, {
    payload: state.styleType
  }) : newState;
};
/**
 * Callback when load map style error
 * @memberof mapStyleUpdaters
 * @param {Object} state `mapStyle`
 * @param {Object} action
 * @param {*} action.payload error
 * @returns {Object} nextState
 * @public
 */
// do nothing for now, if didn't load, skip it


exports.loadMapStylesUpdater = loadMapStylesUpdater;

var loadMapStyleErrUpdater = function loadMapStyleErrUpdater(state) {
  return state;
};

exports.loadMapStyleErrUpdater = loadMapStyleErrUpdater;

var requestMapStylesUpdater = function requestMapStylesUpdater(state, _ref5) {
  var mapStyles = _ref5.payload;
  var loadMapStyleTasks = getLoadMapStyleTasks(mapStyles, state.mapboxApiAccessToken, state.mapboxApiUrl);
  return (0, _tasks.withTask)(state, loadMapStyleTasks);
};
/**
 * Load map style object when pass in saved map config
 * @memberof mapStyleUpdaters
 * @param {Object} state `mapStyle`
 * @param {Object} action
 * @param {Object} action.payload saved map config `{mapStyle, visState, mapState}`
 * @returns {Object} nextState or `react-pam` tasks to load map style object
 */


exports.requestMapStylesUpdater = requestMapStylesUpdater;

var receiveMapConfigUpdater = function receiveMapConfigUpdater(state, _ref6) {
  var _ref6$payload$config = _ref6.payload.config,
      config = _ref6$payload$config === void 0 ? {} : _ref6$payload$config;
  var mapStyle = config.mapStyle;

  if (!mapStyle) {
    return state;
  } // if saved custom mapStyles load the style object


  var loadMapStyleTasks = mapStyle.mapStyles ? getLoadMapStyleTasks(mapStyle.mapStyles, state.mapboxApiAccessToken, state.mapboxApiUrl) : null; // merge default mapStyles

  var merged = mapStyle.mapStyles ? _objectSpread({}, mapStyle, {
    mapStyles: _objectSpread({}, mapStyle.mapStyles, {}, state.mapStyles)
  }) : mapStyle; // set custom3DBuildingColor: true if mapStyle contains threeDBuildingColor

  merged.custom3DBuildingColor = Boolean(mapStyle.threeDBuildingColor) || merged.custom3DBuildingColor;
  var newState = mapConfigChangeUpdater(state, {
    payload: merged
  });
  return loadMapStyleTasks ? (0, _tasks.withTask)(newState, loadMapStyleTasks) : newState;
};

exports.receiveMapConfigUpdater = receiveMapConfigUpdater;

function getLoadMapStyleTasks(mapStyles, mapboxApiAccessToken, mapboxApiUrl) {
  return [_tasks["default"].all(Object.values(mapStyles).map(function (_ref7) {
    var id = _ref7.id,
        url = _ref7.url,
        accessToken = _ref7.accessToken;
    return {
      id: id,
      url: (0, _mapboxGlStyleEditor.isValidStyleUrl)(url) ? (0, _mapboxGlStyleEditor.getStyleDownloadUrl)(url, accessToken || mapboxApiAccessToken, mapboxApiUrl) : url
    };
  }).map(_tasks2.LOAD_MAP_STYLE_TASK)).bimap( // success
  function (results) {
    return (0, _mapStyleActions.loadMapStyles)(results.reduce(function (accu, _ref8) {
      var id = _ref8.id,
          style = _ref8.style;
      return _objectSpread({}, accu, (0, _defineProperty2["default"])({}, id, _objectSpread({}, mapStyles[id], {
        style: style
      })));
    }, {}));
  }, // error
  _mapStyleActions.loadMapStyleErr)];
}
/**
 * Reset map style config to initial state
 * @memberof mapStyleUpdaters
 * @param {Object} state `mapStyle`
 * @returns {Object} nextState
 * @public
 */


var resetMapConfigMapStyleUpdater = function resetMapConfigMapStyleUpdater(state) {
  var emptyConfig = _objectSpread({}, INITIAL_MAP_STYLE, {
    mapboxApiAccessToken: state.mapboxApiAccessToken,
    mapboxApiUrl: state.mapboxApiUrl,
    mapStylesReplaceDefault: state.mapStylesReplaceDefault
  }, state.initialState, {
    mapStyles: state.mapStyles,
    initialState: state.initialState
  });

  return mapStyleChangeUpdater(emptyConfig, {
    payload: emptyConfig.styleType
  });
};
/**
 * Callback when a custom map style object is received
 * @memberof mapStyleUpdaters
 * @param {Object} state `mapStyle`
 * @param {Object} action
 * @param {Object} action.payload
 * @param {string} action.payload.icon
 * @param {Object} action.payload.style
 * @param {*} action.payload.error
 * @returns {Object} nextState
 * @public
 */


exports.resetMapConfigMapStyleUpdater = resetMapConfigMapStyleUpdater;

var loadCustomMapStyleUpdater = function loadCustomMapStyleUpdater(state, _ref9) {
  var _ref9$payload = _ref9.payload,
      icon = _ref9$payload.icon,
      style = _ref9$payload.style,
      error = _ref9$payload.error;
  return _objectSpread({}, state, {
    inputStyle: _objectSpread({}, state.inputStyle, {}, style ? {
      id: style.id || (0, _utils.generateHashId)(),
      // make a copy of the style object
      style: (0, _lodash["default"])(style),
      label: style.name,
      // gathering layer group info from style json
      layerGroups: getLayerGroupsFromStyle(style)
    } : {}, {}, icon ? {
      icon: icon
    } : {}, {}, error !== undefined ? {
      error: error
    } : {})
  });
};
/**
 * Input a custom map style object
 * @memberof mapStyleUpdaters
 * @param {Object} state `mapStyle`
 * @param {Object} action action object
 * @param {Object} action.payload inputStyle
 * @param {string} action.payload.url style url e.g. `'mapbox://styles/heshan/xxxxxyyyyzzz'`
 * @param {string} action.payload.id style url e.g. `'custom_style_1'`
 * @param {Object} action.payload.style actual mapbox style json
 * @param {string} action.payload.name style name
 * @param {Object} action.payload.layerGroups layer groups that can be used to set map layer visibility
 * @param {Object} action.payload.icon icon image data url
 * @returns {Object} nextState
 * @public
 */


exports.loadCustomMapStyleUpdater = loadCustomMapStyleUpdater;

var inputMapStyleUpdater = function inputMapStyleUpdater(state, _ref10) {
  var _ref10$payload = _ref10.payload,
      inputStyle = _ref10$payload.inputStyle,
      mapState = _ref10$payload.mapState;

  var updated = _objectSpread({}, state.inputStyle, {}, inputStyle);

  var isValid = (0, _mapboxGlStyleEditor.isValidStyleUrl)(updated.url);
  var icon = isValid ? (0, _mapboxGlStyleEditor.getStyleImageIcon)({
    mapState: mapState,
    styleUrl: updated.url,
    mapboxApiAccessToken: updated.accessToken || state.mapboxApiAccessToken,
    mapboxApiUrl: state.mapboxApiUrl || _defaultSettings.DEFAULT_MAPBOX_API_URL
  }) : state.inputStyle.icon;
  return _objectSpread({}, state, {
    inputStyle: _objectSpread({}, updated, {
      isValid: isValid,
      icon: icon
    })
  });
};
/**
 * Add map style from user input to reducer and set it to current style
 * This action is called when user click confirm after putting in a valid style url in the custom map style dialog.
 * It should not be called from outside kepler.gl without a valid `inputStyle` in the `mapStyle` reducer.
 * @memberof mapStyleUpdaters
 * @param {Object} state `mapStyle`
 * @returns {Object} nextState
 */


exports.inputMapStyleUpdater = inputMapStyleUpdater;

var addCustomMapStyleUpdater = function addCustomMapStyleUpdater(state) {
  var styleId = state.inputStyle.id;

  var newState = _objectSpread({}, state, {
    mapStyles: _objectSpread({}, state.mapStyles, (0, _defineProperty2["default"])({}, styleId, state.inputStyle)),
    // set to default
    inputStyle: getInitialInputStyle()
  }); // set new style


  return mapStyleChangeUpdater(newState, {
    payload: styleId
  });
};

exports.addCustomMapStyleUpdater = addCustomMapStyleUpdater;

var set3dBuildingColorUpdater = function set3dBuildingColorUpdater(state, _ref11) {
  var color = _ref11.payload;
  return _objectSpread({}, state, {
    threeDBuildingColor: color,
    custom3DBuildingColor: true
  });
};

exports.set3dBuildingColorUpdater = set3dBuildingColorUpdater;

function getInitialInputStyle() {
  return {
    accessToken: null,
    error: false,
    isValid: false,
    label: null,
    style: null,
    url: null,
    icon: null,
    custom: true
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWR1Y2Vycy9tYXAtc3R5bGUtdXBkYXRlcnMuanMiXSwibmFtZXMiOlsiREVGQVVMVF9CTERHX0NPTE9SIiwiZ2V0RGVmYXVsdFN0YXRlIiwidmlzaWJsZUxheWVyR3JvdXBzIiwic3R5bGVUeXBlIiwidG9wTGF5ZXJHcm91cHMiLCJtYXBTdHlsZXMiLCJERUZBVUxUX01BUF9TVFlMRVMiLCJyZWR1Y2UiLCJhY2N1IiwiY3VyciIsImlkIiwibWFwYm94QXBpQWNjZXNzVG9rZW4iLCJtYXBib3hBcGlVcmwiLCJERUZBVUxUX01BUEJPWF9BUElfVVJMIiwibWFwU3R5bGVzUmVwbGFjZURlZmF1bHQiLCJpbnB1dFN0eWxlIiwiZ2V0SW5pdGlhbElucHV0U3R5bGUiLCJ0aHJlZURCdWlsZGluZ0NvbG9yIiwiY3VzdG9tM0RCdWlsZGluZ0NvbG9yIiwibWFwU3R5bGVVcGRhdGVycyIsIklOSVRJQUxfTUFQX1NUWUxFIiwiZ2V0TWFwU3R5bGVzIiwibWFwU3R5bGUiLCJzdHlsZSIsImVkaXRhYmxlIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImJvdHRvbU1hcFN0eWxlIiwiaGFzVG9wTGF5ZXIiLCJ2YWx1ZXMiLCJzb21lIiwidiIsInRvcExheWVycyIsImtleSIsInRvcE1hcFN0eWxlIiwiZmluZExheWVyRmlsbENvbG9yIiwibGF5ZXIiLCJwYWludCIsImdldDNEQnVpbGRpbmdDb2xvciIsImJhY2tncm91bmRMYXllciIsImxheWVycyIsImZpbmQiLCJidWlsZGluZ0xheWVyIiwibWF0Y2giLCJidWlsZGluZ0NvbG9yIiwib3BlcmF0aW9uIiwiYWxwaGEiLCJyZ2JPYmoiLCJyIiwiZyIsImIiLCJnZXRMYXllckdyb3Vwc0Zyb21TdHlsZSIsIkFycmF5IiwiaXNBcnJheSIsIkRFRkFVTFRfTEFZRVJfR1JPVVBTIiwiZmlsdGVyIiwibGciLCJpbml0TWFwU3R5bGVVcGRhdGVyIiwic3RhdGUiLCJhY3Rpb24iLCJwYXlsb2FkIiwibWFwQ29uZmlnQ2hhbmdlVXBkYXRlciIsIm1hcFN0eWxlQ2hhbmdlVXBkYXRlciIsImRlZmF1bHRMR1Zpc2liaWxpdHkiLCJsb2FkTWFwU3R5bGVzVXBkYXRlciIsIm5ld1N0eWxlcyIsImFkZExheWVyR3JvdXBzIiwibGF5ZXJHcm91cHMiLCJuZXdTdGF0ZSIsImxvYWRNYXBTdHlsZUVyclVwZGF0ZXIiLCJyZXF1ZXN0TWFwU3R5bGVzVXBkYXRlciIsImxvYWRNYXBTdHlsZVRhc2tzIiwiZ2V0TG9hZE1hcFN0eWxlVGFza3MiLCJyZWNlaXZlTWFwQ29uZmlnVXBkYXRlciIsImNvbmZpZyIsIm1lcmdlZCIsIkJvb2xlYW4iLCJUYXNrIiwiYWxsIiwibWFwIiwidXJsIiwiYWNjZXNzVG9rZW4iLCJMT0FEX01BUF9TVFlMRV9UQVNLIiwiYmltYXAiLCJyZXN1bHRzIiwibG9hZE1hcFN0eWxlRXJyIiwicmVzZXRNYXBDb25maWdNYXBTdHlsZVVwZGF0ZXIiLCJlbXB0eUNvbmZpZyIsImluaXRpYWxTdGF0ZSIsImxvYWRDdXN0b21NYXBTdHlsZVVwZGF0ZXIiLCJpY29uIiwiZXJyb3IiLCJsYWJlbCIsIm5hbWUiLCJ1bmRlZmluZWQiLCJpbnB1dE1hcFN0eWxlVXBkYXRlciIsIm1hcFN0YXRlIiwidXBkYXRlZCIsImlzVmFsaWQiLCJzdHlsZVVybCIsImFkZEN1c3RvbU1hcFN0eWxlVXBkYXRlciIsInN0eWxlSWQiLCJzZXQzZEJ1aWxkaW5nQ29sb3JVcGRhdGVyIiwiY29sb3IiLCJjdXN0b20iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7QUFDQTs7QUFHQTs7QUFTQTs7QUFLQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsSUFBTUEsa0JBQWtCLEdBQUcsU0FBM0I7O0FBRUEsSUFBTUMsZUFBZSxHQUFHLFNBQWxCQSxlQUFrQixHQUFNO0FBQzVCLE1BQU1DLGtCQUFrQixHQUFHLEVBQTNCO0FBQ0EsTUFBTUMsU0FBUyxHQUFHLE1BQWxCO0FBQ0EsTUFBTUMsY0FBYyxHQUFHLEVB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TTs7OztBQWVBLElBQU1DLHlCQUF5QixHQUFHLFNBQTVCQSx5QkFBNEIsQ0FBQzVDLEtBQUQ7QUFBQSxNQUFrQjZDLEtBQWxCLFVBQVMzQyxPQUFUO0FBQUEsMkJBQ3BDRixLQURvQztBQUV2QzFDLElBQUFBLG1CQUFtQixFQUFFdUYsS0FGa0I7QUFHdkN0RixJQUFBQSxxQkFBcUIsRUFBRTtBQUhnQjtBQUFBLENBQWxDOzs7O0FBTUEsU0FBU0Ysb0JBQVQsR0FBZ0M7QUFDckMsU0FBTztBQUNMa0UsSUFBQUEsV0FBVyxFQUFFLElBRFI7QUFFTFUsSUFBQUEsS0FBSyxFQUFFLEtBRkY7QUFHTE8sSUFBQUEsT0FBTyxFQUFFLEtBSEo7QUFJTE4sSUFBQUEsS0FBSyxFQUFFLElBSkY7QUFLTHRFLElBQUFBLEtBQUssRUFBRSxJQUxGO0FBTUwwRCxJQUFBQSxHQUFHLEVBQUUsSUFOQTtBQU9MVSxJQUFBQSxJQUFJLEVBQUUsSUFQRDtBQVFMYyxJQUFBQSxNQUFNLEVBQUU7QUFSSCxHQUFQO0FBVUQiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTkgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgVGFzaywge3dpdGhUYXNrfSBmcm9tICdyZWFjdC1wYWxtL3Rhc2tzJztcbmltcG9ydCBjbG9uZURlZXAgZnJvbSAnbG9kYXNoLmNsb25lZGVlcCc7XG5cbi8vIFV0aWxzXG5pbXBvcnQge1xuICBnZXREZWZhdWx0TGF5ZXJHcm91cFZpc2liaWxpdHksXG4gIGlzVmFsaWRTdHlsZVVybCxcbiAgZ2V0U3R5bGVEb3dubG9hZFVybCxcbiAgbWVyZ2VMYXllckdyb3VwVmlzaWJpbGl0eSxcbiAgZWRpdFRvcE1hcFN0eWxlLFxuICBlZGl0Qm90dG9tTWFwU3R5bGUsXG4gIGdldFN0eWxlSW1hZ2VJY29uXG59IGZyb20gJ3V0aWxzL21hcC1zdHlsZS11dGlscy9tYXBib3gtZ2wtc3R5bGUtZWRpdG9yJztcbmltcG9ydCB7XG4gIERFRkFVTFRfTUFQX1NUWUxFUyxcbiAgREVGQVVMVF9MQVlFUl9HUk9VUFMsXG4gIERFRkFVTFRfTUFQQk9YX0FQSV9VUkxcbn0gZnJvbSAnY29uc3RhbnRzL2RlZmF1bHQtc2V0dGluZ3MnO1xuaW1wb3J0IHtnZW5lcmF0ZUhhc2hJZH0gZnJvbSAndXRpbHMvdXRpbHMnO1xuaW1wb3J0IHtMT0FEX01BUF9TVFlMRV9UQVNLfSBmcm9tICd0YXNrcy90YXNrcyc7XG5pbXBvcnQge2xvYWRNYXBTdHlsZXMsIGxvYWRNYXBTdHlsZUVycn0gZnJvbSAnYWN0aW9ucy9tYXAtc3R5bGUtYWN0aW9ucyc7XG5pbXBvcnQge3JnYn0gZnJvbSAnZDMtY29sb3InO1xuaW1wb3J0IHtoZXhUb1JnYn0gZnJvbSAndXRpbHMvY29sb3ItdXRpbHMnO1xuXG5jb25zdCBERUZBVUxUX0JMREdfQ09MT1IgPSAnI0QxQ0VDNyc7XG5cbmNvbnN0IGdldERlZmF1bHRTdGF0ZSA9ICgpID0+IHtcbiAgY29uc3QgdmlzaWJsZUxheWVyR3JvdXBzID0ge307XG4gIGNvbnN0IHN0eWxlVHlwZSA9ICdkYXJrJztcbiAgY29uc3QgdG9wTGF5ZXJHcm91cHMgPSB7fTtcblxuICByZXR1cm4ge1xuICAgIHN0eWxlVHlwZSxcbiAgICB2aXNpYmxlTGF5ZXJHcm91cHMsXG4gICAgdG9wTGF5ZXJHcm91cHMsXG4gICAgbWFwU3R5bGVzOiBERUZBVUxUX01BUF9TVFlMRVMucmVkdWNlKFxuICAgICAgKGFjY3UsIGN1cnIpID0+ICh7XG4gICAgICAgIC4uLmFjY3UsXG4gICAgICAgIFtjdXJyLmlkXTogY3VyclxuICAgICAgfSksXG4gICAgICB7fVxuICAgICksXG4gICAgLy8gc2F2ZSBtYXBib3ggYWNjZXNzIHRva2VuXG4gICAgbWFwYm94QXBpQWNjZXNzVG9rZW46IG51bGwsXG4gICAgbWFwYm94QXBpVXJsOiBERUZBVUxUX01BUEJPWF9BUElfVVJMLFxuICAgIG1hcFN0eWxlc1JlcGxhY2VEZWZhdWx0OiBmYWxzZSxcbiAgICBpbnB1dFN0eWxlOiBnZXRJbml0aWFsSW5wdXRTdHlsZSgpLFxuICAgIHRocmVlREJ1aWxkaW5nQ29sb3I6IGhleFRvUmdiKERFRkFVTFRfQkxER19DT0xPUiksXG4gICAgY3VzdG9tM0RCdWlsZGluZ0NvbG9yOiBmYWxzZVxuICB9O1xufTtcblxuLyoqXG4gKiBVcGRhdGVycyBmb3IgYG1hcFN0eWxlYC4gQ2FuIGJlIHVzZWQgaW4geW91ciByb290IHJlZHVjZXIgdG8gZGlyZWN0bHkgbW9kaWZ5IGtlcGxlci5nbCdzIHN0YXRlLlxuICogUmVhZCBtb3JlIGFib3V0IFtVc2luZyB1cGRhdGVyc10oLi4vYWR2YW5jZWQtdXNhZ2UvdXNpbmctdXBkYXRlcnMubWQpXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCBrZXBsZXJHbFJlZHVjZXIsIHttYXBTdHlsZVVwZGF0ZXJzfSBmcm9tICdrZXBsZXIuZ2wvcmVkdWNlcnMnO1xuICogLy8gUm9vdCBSZWR1Y2VyXG4gKiBjb25zdCByZWR1Y2VycyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gKiAga2VwbGVyR2w6IGtlcGxlckdsUmVkdWNlcixcbiAqICBhcHA6IGFwcFJlZHVjZXJcbiAqIH0pO1xuICpcbiAqIGNvbnN0IGNvbXBvc2VkUmVkdWNlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gKiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICogICAgLy8gY2xpY2sgYnV0dG9uIHRvIGhpZGUgbGFiZWwgZnJvbSBiYWNrZ3JvdW5kIG1hcFxuICogICAgY2FzZSAnQ0xJQ0tfQlVUVE9OJzpcbiAqICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAuLi5zdGF0ZSxcbiAqICAgICAgICBrZXBsZXJHbDoge1xuICogICAgICAgICAgLi4uc3RhdGUua2VwbGVyR2wsXG4gKiAgICAgICAgICBmb286IHtcbiAqICAgICAgICAgICAgIC4uLnN0YXRlLmtlcGxlckdsLmZvbyxcbiAqICAgICAgICAgICAgIG1hcFN0eWxlOiBtYXBTdHlsZVVwZGF0ZXJzLm1hcENvbmZpZ0NoYW5nZVVwZGF0ZXIoXG4gKiAgICAgICAgICAgICAgIG1hcFN0eWxlLFxuICogICAgICAgICAgICAgICB7cGF5bG9hZDoge3Zpc2libGVMYXllckdyb3Vwczoge2xhYmVsOiBmYWxzZSwgcm9hZDogdHJ1ZSwgYmFja2dyb3VuZDogdHJ1ZX19fVxuICogICAgICAgICAgICAgKVxuICogICAgICAgICAgfVxuICogICAgICAgIH1cbiAqICAgICAgfTtcbiAqICB9XG4gKiAgcmV0dXJuIHJlZHVjZXJzKHN0YXRlLCBhY3Rpb24pO1xuICogfTtcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBjb21wb3NlZFJlZHVjZXI7XG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5jb25zdCBtYXBTdHlsZVVwZGF0ZXJzID0gbnVsbDtcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qKlxuICogRGVmYXVsdCBpbml0aWFsIGBtYXBTdHlsZWBcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAY29uc3RhbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdHlsZVR5cGUgLSBEZWZhdWx0OiBgJ2RhcmsnYFxuICogQHByb3BlcnR5IHtPYmplY3R9IHZpc2libGVMYXllckdyb3VwcyAtIERlZmF1bHQ6IGB7fWBcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSB0b3BMYXllckdyb3VwcyAtIERlZmF1bHQ6IGB7fWBcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBtYXBTdHlsZXMgLSBtYXBwaW5nIGZyb20gc3R5bGUga2V5IHRvIHN0eWxlIG9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1hcGJveEFwaUFjY2Vzc1Rva2VuIC0gRGVmYXVsdDogYG51bGxgXG4gKiBAUHJvcGVydHkge3N0cmluZ30gbWFwYm94QXBpVXJsIC0gRGVmYXVsdCBudWxsXG4gKiBAUHJvcGVydHkge0Jvb2xlYW59IG1hcFN0eWxlc1JlcGxhY2VEZWZhdWx0IC0gRGVmYXVsdDogYGZhbHNlYFxuICogQHByb3BlcnR5IHtPYmplY3R9IGlucHV0U3R5bGUgLSBEZWZhdWx0OiBge31gXG4gKiBAcHJvcGVydHkge0FycmF5fSB0aHJlZURCdWlsZGluZ0NvbG9yIC0gRGVmYXVsdDogYFtyLCBnLCBiXWBcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IElOSVRJQUxfTUFQX1NUWUxFID0gZ2V0RGVmYXVsdFN0YXRlKCk7XG5cbi8qKlxuICogQ3JlYXRlIHR3byBtYXAgc3R5bGVzIGZyb20gcHJlc2V0IG1hcCBzdHlsZSwgb25lIGZvciB0b3AgbWFwIG9uZSBmb3IgYm90dG9tXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlVHlwZSAtIGN1cnJlbnQgbWFwIHN0eWxlXG4gKiBAcGFyYW0ge09iamVjdH0gdmlzaWJsZUxheWVyR3JvdXBzIC0gdmlzaWJsZSBsYXllcnMgb2YgYm90dG9tIG1hcFxuICogQHBhcmFtIHtPYmplY3R9IHRvcExheWVyR3JvdXBzIC0gdmlzaWJsZSBsYXllcnMgb2YgdG9wIG1hcFxuICogQHBhcmFtIHtPYmplY3R9IG1hcFN0eWxlcyAtIGEgZGljdGlvbmFyeSBvZiBhbGwgbWFwIHN0eWxlc1xuICogQHJldHVybnMge09iamVjdH0gYm90dG9tTWFwU3R5bGUgfCB0b3BNYXBTdHlsZSB8IGlzUmFzdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXBTdHlsZXMoe1xuICBzdHlsZVR5cGUsXG4gIHZpc2libGVMYXllckdyb3VwcyxcbiAgdG9wTGF5ZXJHcm91cHMsXG4gIG1hcFN0eWxlc1xufSkge1xuICBjb25zdCBtYXBTdHlsZSA9IG1hcFN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIC8vIHN0eWxlIG1pZ2h0IG5vdCBiZSBsb2FkZWQgeWV0XG4gIGlmICghbWFwU3R5bGUgfHwgIW1hcFN0eWxlLnN0eWxlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgY29uc3QgZWRpdGFibGUgPSBPYmplY3Qua2V5cyh2aXNpYmxlTGF5ZXJHcm91cHMpLmxlbmd0aDtcblxuICBjb25zdCBib3R0b21NYXBTdHlsZSA9ICFlZGl0YWJsZVxuICAgID8gbWFwU3R5bGUuc3R5bGVcbiAgICA6IGVkaXRCb3R0b21NYXBTdHlsZSh7XG4gICAgICAgIGlkOiBzdHlsZVR5cGUsXG4gICAgICAgIG1hcFN0eWxlLFxuICAgICAgICB2aXNpYmxlTGF5ZXJHcm91cHNcbiAgICAgIH0pO1xuXG4gIGNvbnN0IGhhc1RvcExheWVyID0gZWRpdGFibGUgJiYgT2JqZWN0LnZhbHVlcyh0b3BMYXllckdyb3Vwcykuc29tZSh2ID0+IHYpO1xuXG4gIC8vIG11dGUgdG9wIGxheWVyIGlmIG5vdCB2aXNpYmxlIGluIGJvdHRvbSBsYXllclxuICBjb25zdCB0b3BMYXllcnMgPVxuICAgIGhhc1RvcExheWVyICYmXG4gICAgT2JqZWN0LmtleXModG9wTGF5ZXJHcm91cHMpLnJlZHVjZShcbiAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgIC4uLmFjY3UsXG4gICAgICAgIFtrZXldOiB0b3BMYXllckdyb3Vwc1trZXldICYmIHZpc2libGVMYXllckdyb3Vwc1trZXldXG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcblxuICBjb25zdCB0b3BNYXBTdHlsZSA9IGhhc1RvcExheWVyXG4gICAgPyBlZGl0VG9wTWFwU3R5bGUoe1xuICAgICAgICBpZDogc3R5bGVUeXBlLFxuICAgICAgICBtYXBTdHlsZSxcbiAgICAgICAgdmlzaWJsZUxheWVyR3JvdXBzOiB0b3BMYXllcnNcbiAgICAgIH0pXG4gICAgOiBudWxsO1xuXG4gIHJldHVybiB7Ym90dG9tTWFwU3R5bGUsIHRvcE1hcFN0eWxlLCBlZGl0YWJsZX07XG59XG5cbmZ1bmN0aW9uIGZpbmRMYXllckZpbGxDb2xvcihsYXllcikge1xuICByZXR1cm4gbGF5ZXIgJiYgbGF5ZXIucGFpbnQgJiYgbGF5ZXIucGFpbnRbJ2JhY2tncm91bmQtY29sb3InXTtcbn1cblxuZnVuY3Rpb24gZ2V0M0RCdWlsZGluZ0NvbG9yKHN0eWxlKSB7XG4gIC8vIHNldCBidWlsZGluZyBjb2xvciB0byBiZSB0aGUgc2FtZSBhcyB0aGUgYmFja2dyb3VuZCBjb2xvci5cbiAgaWYgKCFzdHlsZS5zdHlsZSkge1xuICAgIHJldHVybiBERUZBVUxUX0JMREdfQ09MT1I7XG4gIH1cblxuICBjb25zdCBiYWNrZ3JvdW5kTGF5ZXIgPSAoc3R5bGUuc3R5bGUubGF5ZXJzIHx8IFtdKS5maW5kKFxuICAgICh7aWR9KSA9PiBpZCA9PT0gJ2JhY2tncm91bmQnXG4gICk7XG5cbiAgY29uc3QgYnVpbGRpbmdMYXllciA9IChzdHlsZS5zdHlsZS5sYXllcnMgfHwgW10pLmZpbmQoKHtpZH0pID0+XG4gICAgaWQubWF0Y2goL2J1aWxkaW5nLylcbiAgKTtcblxuICBjb25zdCBidWlsZGluZ0NvbG9yID1cbiAgICBmaW5kTGF5ZXJGaWxsQ29sb3IoYnVpbGRpbmdMYXllcikgfHxcbiAgICBmaW5kTGF5ZXJGaWxsQ29sb3IoYmFja2dyb3VuZExheWVyKSB8fFxuICAgIERFRkFVTFRfQkxER19DT0xPUjtcblxuICAvLyBicmlnaHRlbiBvciBkYXJrZW4gYnVpbGRpbmcgYmFzZWQgb24gc3R5bGVcbiAgY29uc3Qgb3BlcmF0aW9uID0gc3R5bGUuaWQubWF0Y2goLyg/PShkYXJrfG5pZ2h0KSkvKSA/ICdicmlnaHRlcicgOiAnZGFya2VyJztcblxuICBjb25zdCBhbHBoYSA9IDAuMjtcbiAgY29uc3QgcmdiT2JqID0gcmdiKGJ1aWxkaW5nQ29sb3IpW29wZXJhdGlvbl0oW2FscGhhXSk7XG4gIHJldHVybiBbcmdiT2JqLnIsIHJnYk9iai5nLCByZ2JPYmouYl07XG59XG5cbmZ1bmN0aW9uIGdldExheWVyR3JvdXBzRnJvbVN0eWxlKHN0eWxlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHN0eWxlLmxheWVycylcbiAgICA/IERFRkFVTFRfTEFZRVJfR1JPVVBTLmZpbHRlcihsZyA9PiBzdHlsZS5sYXllcnMuZmlsdGVyKGxnLmZpbHRlcikubGVuZ3RoKVxuICAgIDogW107XG59XG5cbi8vIFVwZGF0ZXJzXG4vKipcbiAqIFByb3BhZ2F0ZSBgbWFwU3R5bGVgIHJlZHVjZXIgd2l0aCBgbWFwYm94QXBpQWNjZXNzVG9rZW5gIGFuZCBgbWFwU3R5bGVzUmVwbGFjZURlZmF1bHRgLlxuICogaWYgbWFwU3R5bGVzUmVwbGFjZURlZmF1bHQgaXMgdHJ1ZSBtYXBTdHlsZXMgaXMgZW1wdGllZDsgbG9hZE1hcFN0eWxlc1VwZGF0ZXIoKSB3aWxsXG4gKiBwb3B1bGF0ZSBtYXBTdHlsZXMuXG4gKlxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5wYXlsb2FkXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uLnBheWxvYWQubWFwYm94QXBpQWNjZXNzVG9rZW5cbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgaW5pdE1hcFN0eWxlVXBkYXRlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgLy8gc2F2ZSBtYXBib3ggYWNjZXNzIHRva2VuIHRvIG1hcCBzdHlsZSBzdGF0ZVxuICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogKGFjdGlvbi5wYXlsb2FkIHx8IHt9KS5tYXBib3hBcGlBY2Nlc3NUb2tlbixcbiAgbWFwYm94QXBpVXJsOiAoYWN0aW9uLnBheWxvYWQgfHwge30pLm1hcGJveEFwaVVybCB8fCBzdGF0ZS5tYXBib3hBcGlVcmwsXG4gIG1hcFN0eWxlczpcbiAgICBhY3Rpb24ucGF5bG9hZCAmJiAhYWN0aW9uLnBheWxvYWQubWFwU3R5bGVzUmVwbGFjZURlZmF1bHRcbiAgICAgID8gc3RhdGUubWFwU3R5bGVzXG4gICAgICA6IHt9LFxuICBtYXBTdHlsZXNSZXBsYWNlRGVmYXVsdDogYWN0aW9uLnBheWxvYWQubWFwU3R5bGVzUmVwbGFjZURlZmF1bHQgfHwgZmFsc2Vcbn0pO1xuLy8gfSk7XG5cbi8qKlxuICogVXBkYXRlIGB2aXNpYmxlTGF5ZXJHcm91cHNgdG8gY2hhbmdlIGxheWVyIGdyb3VwIHZpc2liaWxpdHlcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYG1hcFN0eWxlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5wYXlsb2FkIG5ldyBjb25maWcgYHt2aXNpYmxlTGF5ZXJHcm91cHM6IHtsYWJlbDogZmFsc2UsIHJvYWQ6IHRydWUsIGJhY2tncm91bmQ6IHRydWV9fWBcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgbWFwQ29uZmlnQ2hhbmdlVXBkYXRlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgLi4uYWN0aW9uLnBheWxvYWQsXG4gIC4uLmdldE1hcFN0eWxlcyh7XG4gICAgLi4uc3RhdGUsXG4gICAgLi4uYWN0aW9uLnBheWxvYWRcbiAgfSlcbn0pO1xuXG4vKipcbiAqIENoYW5nZSB0byBhbm90aGVyIG1hcCBzdHlsZS4gVGhlIHNlbGVjdGVkIHN0eWxlIHNob3VsZCBhbHJlYWR5IGJlZW4gbG9hZGVkIGludG8gYG1hcFN0eWxlLm1hcFN0eWxlc2BcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYG1hcFN0eWxlYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbi5wYXlsb2FkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcFN0eWxlQ2hhbmdlVXBkYXRlciA9IChzdGF0ZSwge3BheWxvYWQ6IHN0eWxlVHlwZX0pID0+IHtcbiAgaWYgKCFzdGF0ZS5tYXBTdHlsZXNbc3R5bGVUeXBlXSkge1xuICAgIC8vIHdlIG1pZ2h0IG5vdCBoYXZlIHJlY2VpdmVkIHRoZSBzdHlsZSB5ZXRcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgY29uc3QgZGVmYXVsdExHVmlzaWJpbGl0eSA9IGdldERlZmF1bHRMYXllckdyb3VwVmlzaWJpbGl0eShcbiAgICBzdGF0ZS5tYXBTdHlsZXNbc3R5bGVUeXBlXVxuICApO1xuXG4gIGNvbnN0IHZpc2libGVMYXllckdyb3VwcyA9IG1lcmdlTGF5ZXJHcm91cFZpc2liaWxpdHkoXG4gICAgZGVmYXVsdExHVmlzaWJpbGl0eSxcbiAgICBzdGF0ZS52aXNpYmxlTGF5ZXJHcm91cHNcbiAgKTtcblxuICBjb25zdCB0aHJlZURCdWlsZGluZ0NvbG9yID0gc3RhdGUuY3VzdG9tM0RCdWlsZGluZ0NvbG9yID8gc3RhdGUudGhyZWVEQnVpbGRpbmdDb2xvciA6XG4gIGdldDNEQnVpbGRpbmdDb2xvcihzdGF0ZS5tYXBTdHlsZXNbc3R5bGVUeXBlXSk7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgc3R5bGVUeXBlLFxuICAgIHZpc2libGVMYXllckdyb3VwcyxcbiAgICB0aHJlZURCdWlsZGluZ0NvbG9yLFxuICAgIC4uLmdldE1hcFN0eWxlcyh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHZpc2libGVMYXllckdyb3VwcyxcbiAgICAgIHN0eWxlVHlwZVxuICAgIH0pXG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxiYWNrIHdoZW4gbG9hZCBtYXAgc3R5bGUgc3VjY2Vzc1xuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgbWFwU3R5bGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLnBheWxvYWQgYSBge1tpZF06IHN0eWxlfWAgbWFwcGluZ1xuICogQHJldHVybiB7T2JqZWN0fSBuZXh0U3RhdGVcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRNYXBTdHlsZXNVcGRhdGVyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgY29uc3QgbmV3U3R5bGVzID0gYWN0aW9uLnBheWxvYWQgfHwge307XG4gIGNvbnN0IGFkZExheWVyR3JvdXBzID0gT2JqZWN0LmtleXMobmV3U3R5bGVzKS5yZWR1Y2UoXG4gICAgKGFjY3UsIGlkKSA9PiAoe1xuICAgICAgLi4uYWNjdSxcbiAgICAgIFtpZF06IHtcbiAgICAgICAgLi4ubmV3U3R5bGVzW2lkXSxcbiAgICAgICAgbGF5ZXJHcm91cHM6XG4gICAgICAgICAgbmV3U3R5bGVzW2lkXS5sYXllckdyb3VwcyB8fFxuICAgICAgICAgIGdldExheWVyR3JvdXBzRnJvbVN0eWxlKG5ld1N0eWxlc1tpZF0uc3R5bGUpXG4gICAgICB9XG4gICAgfSksXG4gICAge31cbiAgKTtcblxuICAvLyBhZGQgbmV3IHN0eWxlcyB0byBzdGF0ZVxuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBtYXBTdHlsZXM6IHtcbiAgICAgIC4uLnN0YXRlLm1hcFN0eWxlcyxcbiAgICAgIC4uLmFkZExheWVyR3JvdXBzXG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBuZXdTdHlsZXNbc3RhdGUuc3R5bGVUeXBlXVxuICAgID8gbWFwU3R5bGVDaGFuZ2VVcGRhdGVyKG5ld1N0YXRlLCB7cGF5bG9hZDogc3RhdGUuc3R5bGVUeXBlfSlcbiAgICA6IG5ld1N0YXRlO1xufTtcblxuLyoqXG4gKiBDYWxsYmFjayB3aGVuIGxvYWQgbWFwIHN0eWxlIGVycm9yXG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGBtYXBTdHlsZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb25cbiAqIEBwYXJhbSB7Kn0gYWN0aW9uLnBheWxvYWQgZXJyb3JcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG4vLyBkbyBub3RoaW5nIGZvciBub3csIGlmIGRpZG4ndCBsb2FkLCBza2lwIGl0XG5leHBvcnQgY29uc3QgbG9hZE1hcFN0eWxlRXJyVXBkYXRlciA9IHN0YXRlID0+IHN0YXRlO1xuXG5leHBvcnQgY29uc3QgcmVxdWVzdE1hcFN0eWxlc1VwZGF0ZXIgPSAoc3RhdGUsIHtwYXlsb2FkOiBtYXBTdHlsZXN9KSA9PiB7XG4gIGNvbnN0IGxvYWRNYXBTdHlsZVRhc2tzID0gZ2V0TG9hZE1hcFN0eWxlVGFza3MoXG4gICAgbWFwU3R5bGVzLFxuICAgIHN0YXRlLm1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICAgIHN0YXRlLm1hcGJveEFwaVVybFxuICApO1xuICByZXR1cm4gd2l0aFRhc2soc3RhdGUsIGxvYWRNYXBTdHlsZVRhc2tzKTtcbn07XG5cbi8qKlxuICogTG9hZCBtYXAgc3R5bGUgb2JqZWN0IHdoZW4gcGFzcyBpbiBzYXZlZCBtYXAgY29uZmlnXG4gKiBAbWVtYmVyb2YgbWFwU3R5bGVVcGRhdGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGBtYXBTdHlsZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24ucGF5bG9hZCBzYXZlZCBtYXAgY29uZmlnIGB7bWFwU3R5bGUsIHZpc1N0YXRlLCBtYXBTdGF0ZX1gXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBuZXh0U3RhdGUgb3IgYHJlYWN0LXBhbWAgdGFza3MgdG8gbG9hZCBtYXAgc3R5bGUgb2JqZWN0XG4gKi9cbmV4cG9ydCBjb25zdCByZWNlaXZlTWFwQ29uZmlnVXBkYXRlciA9IChzdGF0ZSwge3BheWxvYWQ6IHtjb25maWcgPSB7fX19KSA9PiB7XG4gIGNvbnN0IHttYXBTdHlsZX0gPSBjb25maWc7XG5cbiAgaWYgKCFtYXBTdHlsZSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8vIGlmIHNhdmVkIGN1c3RvbSBtYXBTdHlsZXMgbG9hZCB0aGUgc3R5bGUgb2JqZWN0XG4gIGNvbnN0IGxvYWRNYXBTdHlsZVRhc2tzID0gbWFwU3R5bGUubWFwU3R5bGVzXG4gICAgPyBnZXRMb2FkTWFwU3R5bGVUYXNrcyhcbiAgICAgICAgbWFwU3R5bGUubWFwU3R5bGVzLFxuICAgICAgICBzdGF0ZS5tYXBib3hBcGlBY2Nlc3NUb2tlbixcbiAgICAgICAgc3RhdGUubWFwYm94QXBpVXJsXG4gICAgICApXG4gICAgOiBudWxsO1xuXG4gIC8vIG1lcmdlIGRlZmF1bHQgbWFwU3R5bGVzXG4gIGNvbnN0IG1lcmdlZCA9IG1hcFN0eWxlLm1hcFN0eWxlc1xuICAgID8ge1xuICAgICAgICAuLi5tYXBTdHlsZSxcbiAgICAgICAgbWFwU3R5bGVzOiB7XG4gICAgICAgICAgLi4ubWFwU3R5bGUubWFwU3R5bGVzLFxuICAgICAgICAgIC4uLnN0YXRlLm1hcFN0eWxlc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgOiBtYXBTdHlsZTtcblxuICAvLyBzZXQgY3VzdG9tM0RCdWlsZGluZ0NvbG9yOiB0cnVlIGlmIG1hcFN0eWxlIGNvbnRhaW5zIHRocmVlREJ1aWxkaW5nQ29sb3JcbiAgbWVyZ2VkLmN1c3RvbTNEQnVpbGRpbmdDb2xvciA9IEJvb2xlYW4obWFwU3R5bGUudGhyZWVEQnVpbGRpbmdDb2xvcikgfHwgbWVyZ2VkLmN1c3RvbTNEQnVpbGRpbmdDb2xvcjtcbiAgY29uc3QgbmV3U3RhdGUgPSBtYXBDb25maWdDaGFuZ2VVcGRhdGVyKHN0YXRlLCB7cGF5bG9hZDogbWVyZ2VkfSk7XG5cbiAgcmV0dXJuIGxvYWRNYXBTdHlsZVRhc2tzID8gd2l0aFRhc2sobmV3U3RhdGUsIGxvYWRNYXBTdHlsZVRhc2tzKSA6IG5ld1N0YXRlO1xufTtcblxuZnVuY3Rpb24gZ2V0TG9hZE1hcFN0eWxlVGFza3MobWFwU3R5bGVzLCBtYXBib3hBcGlBY2Nlc3NUb2tlbiwgbWFwYm94QXBpVXJsKSB7XG4gIHJldHVybiBbXG4gICAgVGFzay5hbGwoXG4gICAgICBPYmplY3QudmFsdWVzKG1hcFN0eWxlcylcbiAgICAgICAgLm1hcCgoe2lkLCB1cmwsIGFjY2Vzc1Rva2VufSkgPT4gKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB1cmw6IGlzVmFsaWRTdHlsZVVybCh1cmwpXG4gICAgICAgICAgICA/IGdldFN0eWxlRG93bmxvYWRVcmwoXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuIHx8IG1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgICAgIG1hcGJveEFwaVVybFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IHVybFxuICAgICAgICB9KSlcbiAgICAgICAgLm1hcChMT0FEX01BUF9TVFlMRV9UQVNLKVxuICAgICkuYmltYXAoXG4gICAgICAvLyBzdWNjZXNzXG4gICAgICByZXN1bHRzID0+XG4gICAgICAgIGxvYWRNYXBTdHlsZXMoXG4gICAgICAgICAgcmVzdWx0cy5yZWR1Y2UoXG4gICAgICAgICAgICAoYWNjdSwge2lkLCBzdHlsZX0pID0+ICh7XG4gICAgICAgICAgICAgIC4uLmFjY3UsXG4gICAgICAgICAgICAgIFtpZF06IHtcbiAgICAgICAgICAgICAgICAuLi5tYXBTdHlsZXNbaWRdLFxuICAgICAgICAgICAgICAgIHN0eWxlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAge31cbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAvLyBlcnJvclxuICAgICAgbG9hZE1hcFN0eWxlRXJyXG4gICAgKVxuICBdO1xufVxuLyoqXG4gKiBSZXNldCBtYXAgc3R5bGUgY29uZmlnIHRvIGluaXRpYWwgc3RhdGVcbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYG1hcFN0eWxlYFxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCByZXNldE1hcENvbmZpZ01hcFN0eWxlVXBkYXRlciA9IHN0YXRlID0+IHtcbiAgY29uc3QgZW1wdHlDb25maWcgPSB7XG4gICAgLi4uSU5JVElBTF9NQVBfU1RZTEUsXG4gICAgbWFwYm94QXBpQWNjZXNzVG9rZW46IHN0YXRlLm1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICAgIG1hcGJveEFwaVVybDogc3RhdGUubWFwYm94QXBpVXJsLFxuICAgIG1hcFN0eWxlc1JlcGxhY2VEZWZhdWx0OiBzdGF0ZS5tYXBTdHlsZXNSZXBsYWNlRGVmYXVsdCxcbiAgICAuLi5zdGF0ZS5pbml0aWFsU3RhdGUsXG4gICAgbWFwU3R5bGVzOiBzdGF0ZS5tYXBTdHlsZXMsXG4gICAgaW5pdGlhbFN0YXRlOiBzdGF0ZS5pbml0aWFsU3RhdGVcbiAgfTtcblxuICByZXR1cm4gbWFwU3R5bGVDaGFuZ2VVcGRhdGVyKGVtcHR5Q29uZmlnLCB7cGF5bG9hZDogZW1wdHlDb25maWcuc3R5bGVUeXBlfSk7XG59O1xuXG4vKipcbiAqIENhbGxiYWNrIHdoZW4gYSBjdXN0b20gbWFwIHN0eWxlIG9iamVjdCBpcyByZWNlaXZlZFxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgbWFwU3R5bGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLnBheWxvYWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24ucGF5bG9hZC5pY29uXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uLnBheWxvYWQuc3R5bGVcbiAqIEBwYXJhbSB7Kn0gYWN0aW9uLnBheWxvYWQuZXJyb3JcbiAqIEByZXR1cm5zIHtPYmplY3R9IG5leHRTdGF0ZVxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgbG9hZEN1c3RvbU1hcFN0eWxlVXBkYXRlciA9IChcbiAgc3RhdGUsXG4gIHtwYXlsb2FkOiB7aWNvbiwgc3R5bGUsIGVycm9yfX1cbikgPT4gKHtcbiAgLi4uc3RhdGUsXG4gIGlucHV0U3R5bGU6IHtcbiAgICAuLi5zdGF0ZS5pbnB1dFN0eWxlLFxuICAgIC8vIHN0eWxlIGpzb24gYW5kIGljb24gd2lsbCBsb2FkIGFzeW5jaHJvbm91c2x5XG4gICAgLi4uKHN0eWxlXG4gICAgICA/IHtcbiAgICAgICAgICBpZDogc3R5bGUuaWQgfHwgZ2VuZXJhdGVIYXNoSWQoKSxcbiAgICAgICAgICAvLyBtYWtlIGEgY29weSBvZiB0aGUgc3R5bGUgb2JqZWN0XG4gICAgICAgICAgc3R5bGU6IGNsb25lRGVlcChzdHlsZSksXG4gICAgICAgICAgbGFiZWw6IHN0eWxlLm5hbWUsXG4gICAgICAgICAgLy8gZ2F0aGVyaW5nIGxheWVyIGdyb3VwIGluZm8gZnJvbSBzdHlsZSBqc29uXG4gICAgICAgICAgbGF5ZXJHcm91cHM6IGdldExheWVyR3JvdXBzRnJvbVN0eWxlKHN0eWxlKVxuICAgICAgICB9XG4gICAgICA6IHt9KSxcbiAgICAuLi4oaWNvbiA/IHtpY29ufSA6IHt9KSxcbiAgICAuLi4oZXJyb3IgIT09IHVuZGVmaW5lZCA/IHtlcnJvcn0gOiB7fSlcbiAgfVxufSk7XG5cbi8qKlxuICogSW5wdXQgYSBjdXN0b20gbWFwIHN0eWxlIG9iamVjdFxuICogQG1lbWJlcm9mIG1hcFN0eWxlVXBkYXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBgbWFwU3R5bGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIGFjdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24ucGF5bG9hZCBpbnB1dFN0eWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uLnBheWxvYWQudXJsIHN0eWxlIHVybCBlLmcuIGAnbWFwYm94Oi8vc3R5bGVzL2hlc2hhbi94eHh4eHl5eXl6enonYFxuICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbi5wYXlsb2FkLmlkIHN0eWxlIHVybCBlLmcuIGAnY3VzdG9tX3N0eWxlXzEnYFxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5wYXlsb2FkLnN0eWxlIGFjdHVhbCBtYXBib3ggc3R5bGUganNvblxuICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbi5wYXlsb2FkLm5hbWUgc3R5bGUgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5wYXlsb2FkLmxheWVyR3JvdXBzIGxheWVyIGdyb3VwcyB0aGF0IGNhbiBiZSB1c2VkIHRvIHNldCBtYXAgbGF5ZXIgdmlzaWJpbGl0eVxuICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbi5wYXlsb2FkLmljb24gaWNvbiBpbWFnZSBkYXRhIHVybFxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBpbnB1dE1hcFN0eWxlVXBkYXRlciA9IChzdGF0ZSwge3BheWxvYWQ6IHtpbnB1dFN0eWxlLCBtYXBTdGF0ZX19KSA9PiB7XG4gIGNvbnN0IHVwZGF0ZWQgPSB7XG4gICAgLi4uc3RhdGUuaW5wdXRTdHlsZSxcbiAgICAuLi5pbnB1dFN0eWxlXG4gIH07XG5cbiAgY29uc3QgaXNWYWxpZCA9IGlzVmFsaWRTdHlsZVVybCh1cGRhdGVkLnVybCk7XG4gIGNvbnN0IGljb24gPSBpc1ZhbGlkID8gZ2V0U3R5bGVJbWFnZUljb24oe1xuICAgIG1hcFN0YXRlLFxuICAgIHN0eWxlVXJsOiB1cGRhdGVkLnVybCxcbiAgICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogdXBkYXRlZC5hY2Nlc3NUb2tlbiB8fCBzdGF0ZS5tYXBib3hBcGlBY2Nlc3NUb2tlbixcbiAgICBtYXBib3hBcGlVcmw6IHN0YXRlLm1hcGJveEFwaVVybCB8fCBERUZBVUxUX01BUEJPWF9BUElfVVJMXG4gIH0pIDogc3RhdGUuaW5wdXRTdHlsZS5pY29uO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgaW5wdXRTdHlsZToge1xuICAgICAgLi4udXBkYXRlZCxcbiAgICAgIGlzVmFsaWQsXG4gICAgICBpY29uXG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEFkZCBtYXAgc3R5bGUgZnJvbSB1c2VyIGlucHV0IHRvIHJlZHVjZXIgYW5kIHNldCBpdCB0byBjdXJyZW50IHN0eWxlXG4gKiBUaGlzIGFjdGlvbiBpcyBjYWxsZWQgd2hlbiB1c2VyIGNsaWNrIGNvbmZpcm0gYWZ0ZXIgcHV0dGluZyBpbiBhIHZhbGlkIHN0eWxlIHVybCBpbiB0aGUgY3VzdG9tIG1hcCBzdHlsZSBkaWFsb2cuXG4gKiBJdCBzaG91bGQgbm90IGJlIGNhbGxlZCBmcm9tIG91dHNpZGUga2VwbGVyLmdsIHdpdGhvdXQgYSB2YWxpZCBgaW5wdXRTdHlsZWAgaW4gdGhlIGBtYXBTdHlsZWAgcmVkdWNlci5cbiAqIEBtZW1iZXJvZiBtYXBTdHlsZVVwZGF0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgYG1hcFN0eWxlYFxuICogQHJldHVybnMge09iamVjdH0gbmV4dFN0YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRDdXN0b21NYXBTdHlsZVVwZGF0ZXIgPSBzdGF0ZSA9PiB7XG4gIGNvbnN0IHN0eWxlSWQgPSBzdGF0ZS5pbnB1dFN0eWxlLmlkO1xuICBjb25zdCBuZXdTdGF0ZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBtYXBTdHlsZXM6IHtcbiAgICAgIC4uLnN0YXRlLm1hcFN0eWxlcyxcbiAgICAgIFtzdHlsZUlkXTogc3RhdGUuaW5wdXRTdHlsZVxuICAgIH0sXG4gICAgLy8gc2V0IHRvIGRlZmF1bHRcbiAgICBpbnB1dFN0eWxlOiBnZXRJbml0aWFsSW5wdXRTdHlsZSgpXG4gIH07XG4gIC8vIHNldCBuZXcgc3R5bGVcbiAgcmV0dXJuIG1hcFN0eWxlQ2hhbmdlVXBkYXRlcihuZXdTdGF0ZSwge3BheWxvYWQ6IHN0eWxlSWR9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBzZXQzZEJ1aWxkaW5nQ29sb3JVcGRhdGVyID0gKHN0YXRlLCB7cGF5bG9hZDogY29sb3J9KSA9PiAoe1xuICAuLi5zdGF0ZSxcbiAgdGhyZWVEQnVpbGRpbmdDb2xvcjogY29sb3IsXG4gIGN1c3RvbTNEQnVpbGRpbmdDb2xvcjogdHJ1ZVxufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbml0aWFsSW5wdXRTdHlsZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBhY2Nlc3NUb2tlbjogbnVsbCxcbiAgICBlcnJvcjogZmFsc2UsXG4gICAgaXNWYWxpZDogZmFsc2UsXG4gICAgbGFiZWw6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgdXJsOiBudWxsLFxuICAgIGljb246IG51bGwsXG4gICAgY3VzdG9tOiB0cnVlXG4gIH07XG59XG4iXX0=