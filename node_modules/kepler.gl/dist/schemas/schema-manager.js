"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _window = require("global/window");

var _visStateSchema = _interopRequireDefault(require("./vis-state-schema"));

var _datasetSchema = _interopRequireDefault(require("./dataset-schema"));

var _mapStyleSchema = _interopRequireDefault(require("./map-style-schema"));

var _mapStateSchema = _interopRequireDefault(require("./map-state-schema"));

var _versions = require("./versions");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var REDUCER_SCHEMAS = {
  visState: _visStateSchema["default"],
  mapState: _mapStateSchema["default"],
  mapStyle: _mapStyleSchema["default"]
};

var KeplerGLSchema =
/*#__PURE__*/
function () {
  function KeplerGLSchema() {
    (0, _classCallCheck2["default"])(this, KeplerGLSchema);
    this._validVersions = _versions.VERSIONS;
    this._version = _versions.CURRENT_VERSION;
    this._reducerSchemas = REDUCER_SCHEMAS;
    this._datasetSchema = _datasetSchema["default"];
    this._datasetLastSaved = null;
    this._savedDataset = null;
  }
  /**
   * stateToSave = {
   *   datasets: [
   *     {
   *       version: 'v0',
   *       data: {id, label, color, allData, fields}
   *     },
   *     {
   *       version: 'v0',
   *       data: {id, label, color, allData, fields}
   *     }
   *   ],
   *   config: {
   *     version: 'v0',
   *     config: {}
   *   },
   *   info: {
   *     app: 'kepler.gl',
   *     create_at: 'Mon May 28 2018 21:04:46 GMT-0700 (PDT)'
   *   }
   * }
   *
   * Get config and data of current map to save
   * @param {Object} state
   * @returns {{datasets: Object[], config: Object, info: Object}} app state to save
   */


  (0, _createClass2["default"])(KeplerGLSchema, [{
    key: "save",
    value: function save(state) {
      return {
        datasets: this.getDatasetToSave(state),
        config: this.getConfigToSave(state),
        info: {
          app: 'kepler.gl',
          created_at: new Date().toString()
        }
      };
    }
  }, {
    key: "load",
    value: function load(savedDatasets, savedConfig) {
      return {
        datasets: this.parseSavedData(savedDatasets),
        config: savedConfig ? this.parseSavedConfig(savedConfig) : undefined
      };
    }
    /**
     * Get data to save
     * @param {Object} state - app state
     * @returns {{version: String, data: Object}} - dataset to save
     */

  }, {
    key: "getDatasetToSave",
    value: function getDatasetToSave(state) {
      var _this = this;

      var dataChangedSinceLastSave = this.hasDataChanged(state);

      if (!dataChangedSinceLastSave) {
        return this._savedDataset;
      }

      var visState = state.visState;
      var datasets = Object.values(visState.datasets).map(function (ds) {
        return {
          version: _this._version,
          data: _this._datasetSchema[_this._version].save(ds)
        };
      }); // keep a copy of formatted datasets to save

      this._datasetLastSaved = visState.datasets;
      this._savedDataset = datasets;
      return datasets;
    }
    /**
     * Get App config to save
     * @param {Object} state - app state
     * @returns {{version: String, config: Object}} - config to save
     */

  }, {
    key: "getConfigToSave",
    value: function getConfigToSave(state) {
      var _this2 = this;

      var config = Object.keys(this._reducerSchemas).reduce(function (accu, key) {
        return _objectSpread({}, accu, {}, _this2._reducerSchemas[key][_this2._version].save(state[key]));
      }, {});
      return {
        version: this._version,
        config: config
      };
    }
    /**
     * Parse saved data
     * @param {Array} datasets
     * @returns {Object | null} - data to save
     */

  }, {
    key: "parseSavedData",
    value: function parseSavedData(datasets) {
      var _this3 = this;

      return datasets.reduce(function (accu, ds) {
        var validVersion = _this3.validateVersion(ds.version);

        if (!validVersion) {
          return accu;
        }

        accu.push(_this3._datasetSchema[validVersion].load(ds.data));
        return accu;
      }, []);
    }
    /**
     * Parse saved App config
     * @param {String} opt.version - config version
     * @param {Object} opt.config - saved config
     * @param {Object} state - current App State
     * @returns {Object | null} - parsed config
     */

  }, {
    key: "parseSavedConfig",
    value: function parseSavedConfig(_ref) {
      var _this4 = this;

      var version = _ref.version,
          config = _ref.config;
      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var validVersion = this.validateVersion(version);

      if (!validVersion) {
        return null;
      }

      return Object.keys(config).reduce(function (accu, key) {
        return _objectSpread({}, accu, {}, key in _this4._reducerSchemas ? _this4._reducerSchemas[key][validVersion].load(config[key]) : {});
      }, {});
    }
    /**
     * Validate version
     * @param {String} version
     * @returns {String | null} validVersion
     */

  }, {
    key: "validateVersion",
    value: function validateVersion(version) {
      if (!version) {
        _window.console.error('There is no version number associated with this saved map');

        return null;
      }

      if (!this._validVersions[version]) {
        _window.console.error("".concat(version, " is not a valid version"));

        return null;
      }

      return version;
    }
    /**
     * Check if data has changed since last save
     * @param {Object} state
     * @returns {boolean} - whether data has changed or not
     */

  }, {
    key: "hasDataChanged",
    value: function hasDataChanged(state) {
      return this._datasetLastSaved !== state.visState.datasets;
    }
  }]);
  return KeplerGLSchema;
}();

var KeplerGLSchemaManager = new KeplerGLSchema();
var _default = KeplerGLSchemaManager;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY2hlbWFzL3NjaGVtYS1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbIlJFRFVDRVJfU0NIRU1BUyIsInZpc1N0YXRlIiwidmlzU3RhdGVTY2hlbWEiLCJtYXBTdGF0ZSIsIm1hcFN0YXRlU2NoZW1hIiwibWFwU3R5bGUiLCJtYXBTdHlsZVNjaGVtYSIsIktlcGxlckdMU2NoZW1hIiwiX3ZhbGlkVmVyc2lvbnMiLCJWRVJTSU9OUyIsIl92ZXJzaW9uIiwiQ1VSUkVOVF9WRVJTSU9OIiwiX3JlZHVjZXJTY2hlbWFzIiwiX2RhdGFzZXRTY2hlbWEiLCJkYXRhc2V0U2NoZW1hIiwiX2RhdGFzZXRMYXN0U2F2ZWQiLCJfc2F2ZWREYXRhc2V0Iiwic3RhdGUiLCJkYXRhc2V0cyIsImdldERhdGFzZXRUb1NhdmUiLCJjb25maWciLCJnZXRDb25maWdUb1NhdmUiLCJpbmZvIiwiYXBwIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b1N0cmluZyIsInNhdmVkRGF0YXNldHMiLCJzYXZlZENvbmZpZyIsInBhcnNlU2F2ZWREYXRhIiwicGFyc2VTYXZlZENvbmZpZyIsInVuZGVmaW5lZCIsImRhdGFDaGFuZ2VkU2luY2VMYXN0U2F2ZSIsImhhc0RhdGFDaGFuZ2VkIiwiT2JqZWN0IiwidmFsdWVzIiwibWFwIiwiZHMiLCJ2ZXJzaW9uIiwiZGF0YSIsInNhdmUiLCJrZXlzIiwicmVkdWNlIiwiYWNjdSIsImtleSIsInZhbGlkVmVyc2lvbiIsInZhbGlkYXRlVmVyc2lvbiIsInB1c2giLCJsb2FkIiwiQ29uc29sZSIsImVycm9yIiwiS2VwbGVyR0xTY2hlbWFNYW5hZ2VyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7OztBQUVBLElBQU1BLGVBQWUsR0FBRztBQUN0QkMsRUFBQUEsUUFBUSxFQUFFQywwQkFEWTtBQUV0QkMsRUFBQUEsUUFBUSxFQUFFQywwQkFGWTtBQUd0QkMsRUFBQUEs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S2VyQixLLEVBQU87QUFDcEIsYUFBTyxLQUFLRixpQkFBTCxLQUEyQkUsS0FBSyxDQUFDaEIsUUFBTixDQUFlaUIsUUFBakQ7QUFDRDs7Ozs7QUFHSCxJQUFNaUMscUJBQXFCLEdBQUcsSUFBSTVDLGNBQUosRUFBOUI7ZUFFZTRDLHFCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE5IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtjb25zb2xlIGFzIENvbnNvbGV9IGZyb20gJ2dsb2JhbC93aW5kb3cnO1xuXG5pbXBvcnQgdmlzU3RhdGVTY2hlbWEgZnJvbSAnLi92aXMtc3RhdGUtc2NoZW1hJztcbmltcG9ydCBkYXRhc2V0U2NoZW1hIGZyb20gJy4vZGF0YXNldC1zY2hlbWEnO1xuaW1wb3J0IG1hcFN0eWxlU2NoZW1hIGZyb20gJy4vbWFwLXN0eWxlLXNjaGVtYSc7XG5pbXBvcnQgbWFwU3RhdGVTY2hlbWEgZnJvbSAnLi9tYXAtc3RhdGUtc2NoZW1hJztcblxuaW1wb3J0IHtDVVJSRU5UX1ZFUlNJT04sIFZFUlNJT05TfSBmcm9tICcuL3ZlcnNpb25zJztcblxuY29uc3QgUkVEVUNFUl9TQ0hFTUFTID0ge1xuICB2aXNTdGF0ZTogdmlzU3RhdGVTY2hlbWEsXG4gIG1hcFN0YXRlOiBtYXBTdGF0ZVNjaGVtYSxcbiAgbWFwU3R5bGU6IG1hcFN0eWxlU2NoZW1hXG59O1xuXG5jbGFzcyBLZXBsZXJHTFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3ZhbGlkVmVyc2lvbnMgPSBWRVJTSU9OUztcbiAgICB0aGlzLl92ZXJzaW9uID0gQ1VSUkVOVF9WRVJTSU9OO1xuICAgIHRoaXMuX3JlZHVjZXJTY2hlbWFzID0gUkVEVUNFUl9TQ0hFTUFTO1xuICAgIHRoaXMuX2RhdGFzZXRTY2hlbWEgPSBkYXRhc2V0U2NoZW1hO1xuXG4gICAgdGhpcy5fZGF0YXNldExhc3RTYXZlZCA9IG51bGw7XG4gICAgdGhpcy5fc2F2ZWREYXRhc2V0ID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBzdGF0ZVRvU2F2ZSA9IHtcbiAgICogICBkYXRhc2V0czogW1xuICAgKiAgICAge1xuICAgKiAgICAgICB2ZXJzaW9uOiAndjAnLFxuICAgKiAgICAgICBkYXRhOiB7aWQsIGxhYmVsLCBjb2xvciwgYWxsRGF0YSwgZmllbGRzfVxuICAgKiAgICAgfSxcbiAgICogICAgIHtcbiAgICogICAgICAgdmVyc2lvbjogJ3YwJyxcbiAgICogICAgICAgZGF0YToge2lkLCBsYWJlbCwgY29sb3IsIGFsbERhdGEsIGZpZWxkc31cbiAgICogICAgIH1cbiAgICogICBdLFxuICAgKiAgIGNvbmZpZzoge1xuICAgKiAgICAgdmVyc2lvbjogJ3YwJyxcbiAgICogICAgIGNvbmZpZzoge31cbiAgICogICB9LFxuICAgKiAgIGluZm86IHtcbiAgICogICAgIGFwcDogJ2tlcGxlci5nbCcsXG4gICAqICAgICBjcmVhdGVfYXQ6ICdNb24gTWF5IDI4IDIwMTggMjE6MDQ6NDYgR01ULTA3MDAgKFBEVCknXG4gICAqICAgfVxuICAgKiB9XG4gICAqXG4gICAqIEdldCBjb25maWcgYW5kIGRhdGEgb2YgY3VycmVudCBtYXAgdG8gc2F2ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICogQHJldHVybnMge3tkYXRhc2V0czogT2JqZWN0W10sIGNvbmZpZzogT2JqZWN0LCBpbmZvOiBPYmplY3R9fSBhcHAgc3RhdGUgdG8gc2F2ZVxuICAgKi9cbiAgc2F2ZShzdGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhc2V0czogdGhpcy5nZXREYXRhc2V0VG9TYXZlKHN0YXRlKSxcbiAgICAgIGNvbmZpZzogdGhpcy5nZXRDb25maWdUb1NhdmUoc3RhdGUpLFxuICAgICAgaW5mbzoge1xuICAgICAgICBhcHA6ICdrZXBsZXIuZ2wnLFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvU3RyaW5nKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgbG9hZChzYXZlZERhdGFzZXRzLCBzYXZlZENvbmZpZykge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhc2V0czogdGhpcy5wYXJzZVNhdmVkRGF0YShzYXZlZERhdGFzZXRzKSxcbiAgICAgIGNvbmZpZzogc2F2ZWRDb25maWcgPyB0aGlzLnBhcnNlU2F2ZWRDb25maWcoc2F2ZWRDb25maWcpIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGF0YSB0byBzYXZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSAtIGFwcCBzdGF0ZVxuICAgKiBAcmV0dXJucyB7e3ZlcnNpb246IFN0cmluZywgZGF0YTogT2JqZWN0fX0gLSBkYXRhc2V0IHRvIHNhdmVcbiAgICovXG4gIGdldERhdGFzZXRUb1NhdmUoc3RhdGUpIHtcbiAgICBjb25zdCBkYXRhQ2hhbmdlZFNpbmNlTGFzdFNhdmUgPSB0aGlzLmhhc0RhdGFDaGFuZ2VkKHN0YXRlKTtcbiAgICBpZiAoIWRhdGFDaGFuZ2VkU2luY2VMYXN0U2F2ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkRGF0YXNldDtcbiAgICB9XG5cbiAgICBjb25zdCB7dmlzU3RhdGV9ID0gc3RhdGU7XG5cbiAgICBjb25zdCBkYXRhc2V0cyA9IE9iamVjdC52YWx1ZXModmlzU3RhdGUuZGF0YXNldHMpLm1hcChkcyA9PiAoe1xuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIGRhdGE6IHRoaXMuX2RhdGFzZXRTY2hlbWFbdGhpcy5fdmVyc2lvbl0uc2F2ZShkcylcbiAgICB9KSk7XG5cbiAgICAvLyBrZWVwIGEgY29weSBvZiBmb3JtYXR0ZWQgZGF0YXNldHMgdG8gc2F2ZVxuICAgIHRoaXMuX2RhdGFzZXRMYXN0U2F2ZWQgPSB2aXNTdGF0ZS5kYXRhc2V0cztcbiAgICB0aGlzLl9zYXZlZERhdGFzZXQgPSBkYXRhc2V0cztcblxuICAgIHJldHVybiBkYXRhc2V0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgQXBwIGNvbmZpZyB0byBzYXZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSAtIGFwcCBzdGF0ZVxuICAgKiBAcmV0dXJucyB7e3ZlcnNpb246IFN0cmluZywgY29uZmlnOiBPYmplY3R9fSAtIGNvbmZpZyB0byBzYXZlXG4gICAqL1xuICBnZXRDb25maWdUb1NhdmUoc3RhdGUpIHtcbiAgICBjb25zdCBjb25maWcgPSBPYmplY3Qua2V5cyh0aGlzLl9yZWR1Y2VyU2NoZW1hcykucmVkdWNlKFxuICAgICAgKGFjY3UsIGtleSkgPT4gKHtcbiAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgLi4udGhpcy5fcmVkdWNlclNjaGVtYXNba2V5XVt0aGlzLl92ZXJzaW9uXS5zYXZlKHN0YXRlW2tleV0pXG4gICAgICB9KSxcbiAgICAgIHt9XG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgY29uZmlnXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBzYXZlZCBkYXRhXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhdGFzZXRzXG4gICAqIEByZXR1cm5zIHtPYmplY3QgfCBudWxsfSAtIGRhdGEgdG8gc2F2ZVxuICAgKi9cbiAgcGFyc2VTYXZlZERhdGEoZGF0YXNldHMpIHtcbiAgICByZXR1cm4gZGF0YXNldHMucmVkdWNlKChhY2N1LCBkcykgPT4ge1xuICAgICAgY29uc3QgdmFsaWRWZXJzaW9uID0gdGhpcy52YWxpZGF0ZVZlcnNpb24oZHMudmVyc2lvbik7XG4gICAgICBpZiAoIXZhbGlkVmVyc2lvbikge1xuICAgICAgICByZXR1cm4gYWNjdTtcbiAgICAgIH1cbiAgICAgIGFjY3UucHVzaCh0aGlzLl9kYXRhc2V0U2NoZW1hW3ZhbGlkVmVyc2lvbl0ubG9hZChkcy5kYXRhKSk7XG4gICAgICByZXR1cm4gYWNjdTtcbiAgICB9LCBbXSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2Ugc2F2ZWQgQXBwIGNvbmZpZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0LnZlcnNpb24gLSBjb25maWcgdmVyc2lvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0LmNvbmZpZyAtIHNhdmVkIGNvbmZpZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgLSBjdXJyZW50IEFwcCBTdGF0ZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0IHwgbnVsbH0gLSBwYXJzZWQgY29uZmlnXG4gICAqL1xuICBwYXJzZVNhdmVkQ29uZmlnKHt2ZXJzaW9uLCBjb25maWd9LCBzdGF0ZSA9IHt9KSB7XG4gICAgY29uc3QgdmFsaWRWZXJzaW9uID0gdGhpcy52YWxpZGF0ZVZlcnNpb24odmVyc2lvbik7XG4gICAgaWYgKCF2YWxpZFZlcnNpb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhjb25maWcpLnJlZHVjZShcbiAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgICAuLi4oa2V5IGluIHRoaXMuX3JlZHVjZXJTY2hlbWFzXG4gICAgICAgICAgICA/IHRoaXMuX3JlZHVjZXJTY2hlbWFzW2tleV1bdmFsaWRWZXJzaW9uXS5sb2FkKFxuICAgICAgICAgICAgICAgIGNvbmZpZ1trZXldXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDoge30pXG4gICAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHZlcnNpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZlcnNpb25cbiAgICogQHJldHVybnMge1N0cmluZyB8IG51bGx9IHZhbGlkVmVyc2lvblxuICAgKi9cbiAgdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24pIHtcbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgIENvbnNvbGUuZXJyb3IoXG4gICAgICAgICdUaGVyZSBpcyBubyB2ZXJzaW9uIG51bWJlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBzYXZlZCBtYXAnXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl92YWxpZFZlcnNpb25zW3ZlcnNpb25dKSB7XG4gICAgICBDb25zb2xlLmVycm9yKGAke3ZlcnNpb259IGlzIG5vdCBhIHZhbGlkIHZlcnNpb25gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB2ZXJzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGRhdGEgaGFzIGNoYW5nZWQgc2luY2UgbGFzdCBzYXZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB3aGV0aGVyIGRhdGEgaGFzIGNoYW5nZWQgb3Igbm90XG4gICAqL1xuICBoYXNEYXRhQ2hhbmdlZChzdGF0ZSkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhc2V0TGFzdFNhdmVkICE9PSBzdGF0ZS52aXNTdGF0ZS5kYXRhc2V0cztcbiAgfVxufVxuXG5jb25zdCBLZXBsZXJHTFNjaGVtYU1hbmFnZXIgPSBuZXcgS2VwbGVyR0xTY2hlbWEoKTtcblxuZXhwb3J0IGRlZmF1bHQgS2VwbGVyR0xTY2hlbWFNYW5hZ2VyO1xuIl19