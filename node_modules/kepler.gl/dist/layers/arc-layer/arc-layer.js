"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.arcVisConfigs = exports.arcRequiredColumns = exports.arcPosResolver = exports.arcPosAccessor = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _lodash = _interopRequireDefault(require("lodash.memoize"));

var _baseLayer = _interopRequireDefault(require("../base-layer"));

var _arcBrushingLayer = _interopRequireDefault(require("../../deckgl-layers/arc-brushing-layer/arc-brushing-layer"));

var _colorUtils = require("../../utils/color-utils");

var _arcLayerIcon = _interopRequireDefault(require("./arc-layer-icon"));

var _defaultSettings = require("../../constants/default-settings");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var arcPosAccessor = function arcPosAccessor(_ref) {
  var lat0 = _ref.lat0,
      lng0 = _ref.lng0,
      lat1 = _ref.lat1,
      lng1 = _ref.lng1;
  return function (d) {
    return [d.data[lng0.fieldIdx], d.data[lat0.fieldIdx], 0, d.data[lng1.fieldIdx], d.data[lat1.fieldIdx], 0];
  };
};

exports.arcPosAccessor = arcPosAccessor;

var arcPosResolver = function arcPosResolver(_ref2) {
  var lat0 = _ref2.lat0,
      lng0 = _ref2.lng0,
      lat1 = _ref2.lat1,
      lng1 = _ref2.lng1;
  return "".concat(lat0.fieldIdx, "-").concat(lng0.fieldIdx, "-").concat(lat1.fieldIdx, "-").concat(lat1.fieldIdx, "}");
};

exports.arcPosResolver = arcPosResolver;
var arcRequiredColumns = ['lat0', 'lng0', 'lat1', 'lng1'];
exports.arcRequiredColumns = arcRequiredColumns;
var arcVisConfigs = {
  opacity: 'opacity',
  thickness: 'thickness',
  colorRange: 'colorRange',
  sizeRange: 'strokeWidthRange',
  targetColor: 'targetColor'
};
exports.arcVisConfigs = arcVisConfigs;

var ArcLayer =
/*#__PURE__*/
function (_Layer) {
  (0, _inherits2["default"])(ArcLayer, _Layer);

  function ArcLayer(props) {
    var _this;

    (0, _classCallCheck2["default"])(this, ArcLayer);
    _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(ArcLayer).call(this, props));

    _this.registerVisConfig(arcVisConfigs);

    _this.getPosition = (0, _lodash["default"])(arcPosAccessor, arcPosResolver);
    return _this;
  }

  (0, _createClass2["default"])(ArcLayer, [{
    key: "formatLayerData",
    // TODO: fix complexity

    /* eslint-disable complexity */
    value: function formatLayerData(_, allData, filteredIndex, oldLayerData) {
      var _this2 = this;

      var opt = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      var _this$config = this.config,
          colorScale = _this$config.colorScale,
          colorDomain = _this$config.colorDomain,
          colorField = _this$config.colorField,
          color = _this$config.color,
          columns = _this$config.columns,
          sizeField = _this$config.sizeField,
          sizeScale = _this$config.sizeScale,
          sizeDomain = _this$config.sizeDomain,
          _this$config$visConfi = _this$config.visConfig,
          sizeRange = _this$config$visConfi.sizeRange,
          colorRange = _this$config$visConfi.colorRange,
          targetColor = _this$config$visConfi.targetColor; // arc color

      var cScale = colorField && this.getVisChannelScale(colorScale, colorDomain, colorRange.colors.map(_colorUtils.hexToRgb)); // arc thickness

      var sScale = sizeField && this.getVisChannelScale(sizeScale, sizeDomain, sizeRange);
      var getPosition = this.getPosition(columns);

      if (!oldLayerData || oldLayerData.getPosition !== getPosition) {
        this.updateLayerMeta(allData, getPosition);
      }

      var data;

      if (oldLayerData && oldLayerData.data && opt.sameData && oldLayerData.getPosition === getPosition) {
        data = oldLayerData.data;
      } else {
        data = filteredIndex.reduce(function (accu, index) {
          var pos = getPosition({
            data: allData[index]
          }); // if doesn't have point lat or lng, do not add the arc
          // deck.gl can't handle position == null

          if (!pos.every(Number.isFinite)) {
            return accu;
          }

          accu.push({
            index: index,
            sourcePosition: [pos[0], pos[1], pos[2]],
            targetPosition: [pos[3], pos[4], pos[5]],
            data: allData[index]
          });
          return accu;
        }, []);
      }

      var getStrokeWidth = sScale ? function (d) {
        return _this2.getEncodedChannelValue(sScale, d.data, sizeField, 0);
      } : 1;
      var getColor = cScale ? function (d) {
        return _this2.getEncodedChannelValue(cScale, d.data, colorField);
      } : color;
      var getTargetColor = cScale ? function (d) {
        return _this2.getEncodedChannelValue(cScale, d.data, colorField);
      } : targetColor || color;
      return {
        data: data,
        getColor: getColor,
        getSourceColor: getColor,
        getTargetColor: getTargetColor,
        getWidth: getStrokeWidth
      };
    }
    /* eslint-enable complexity */

  }, {
    key: "updateLayerMeta",
    value: function updateLayerMeta(allData, getPosition) {
      // get bounds from arcs
      var sBounds = this.getPointsBounds(allData, function (d) {
        var pos = getPosition({
          data: d
        });
        return [pos[0], pos[1]];
      });
      var tBounds = this.getPointsBounds(allData, function (d) {
        var pos = getPosition({
          data: d
        });
        return [pos[3], pos[4]];
      });
      var bounds = tBounds && sBounds ? [Math.min(sBounds[0], tBounds[0]), Math.min(sBounds[1], tBounds[1]), Math.max(sBounds[2], tBounds[2]), Math.max(sBounds[3], tBounds[3])] : sBounds || tBounds;
      this.updateMeta({
        bounds: bounds
      });
    }
  }, {
    key: "renderLayer",
    value: function renderLayer(_ref3) {
      var data = _ref3.data,
          idx = _ref3.idx,
          objectHovered = _ref3.objectHovered,
          layerInteraction = _ref3.layerInteraction,
          mapState = _ref3.mapState,
          interactionConfig = _ref3.interactionConfig;
      var brush = interactionConfig.brush;
      var colorUpdateTriggers = {
        color: this.config.color,
        colorField: this.config.colorField,
        colorRange: this.config.visConfig.colorRange,
        colorScale: this.config.colorScale,
        targetColor: this.config.visConfig.targetColor
      };
      var interaction = {
        // auto highlighting
        pickable: true,
        autoHighlight: !brush.enabled,
        highlightColor: this.config.highlightColor,
        // brushing
        brushRadius: brush.config.size * 1000,
        brushSource: true,
        brushTarget: true,
        enableBrushing: brush.enabled
      };
      return [new _arcBrushingLayer["default"](_objectSpread({}, data, {}, interaction, {}, layerInteraction, {
        id: this.id,
        idx: idx,
        opacity: this.config.visConfig.opacity,
        pickedColor: this.config.highlightColor,
        strokeScale: this.config.visConfig.thickness,
        // parameters
        parameters: {
          depthTest: mapState.dragRotate
        },
        updateTriggers: {
          getWidth: {
            sizeField: this.config.sizeField,
            sizeRange: this.config.visConfig.sizeRange
          },
          getSourceColor: colorUpdateTriggers,
          getTargetColor: colorUpdateTriggers
        }
      }))].concat((0, _toConsumableArray2["default"])(this.isLayerHovered(objectHovered) ? [new _arcBrushingLayer["default"]({
        id: "".concat(this.id, "-hovered"),
        data: [objectHovered.object],
        strokeScale: this.config.visConfig.thickness,
        getSourceColor: this.config.highlightColor,
        getTargetColor: this.config.highlightColor,
        getWidth: data.getWidth,
        pickable: false
      })] : []));
    }
  }, {
    key: "type",
    get: function get() {
      return 'arc';
    }
  }, {
    key: "isAggregated",
    get: function get() {
      return false;
    }
  }, {
    key: "layerIcon",
    get: function get() {
      return _arcLayerIcon["default"];
    }
  }, {
    key: "requiredLayerColumns",
    get: function get() {
      return arcRequiredColumns;
    }
  }, {
    key: "columnPairs",
    get: function get() {
      return this.defaultLinkColumnPairs;
    }
  }, {
    key: "visualChannels",
    get: function get() {
      return _objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(ArcLayer.prototype), "visualChannels", this), {
        size: _objectSpread({}, (0, _get2["default"])((0, _getPrototypeOf2["default"])(ArcLayer.prototype), "visualChannels", this).size, {
          property: 'stroke'
        })
      });
    }
  }], [{
    key: "findDefaultLayerProps",
    value: function findDefaultLayerProps(_ref4) {
      var _ref4$fieldPairs = _ref4.fieldPairs,
          fieldPairs = _ref4$fieldPairs === void 0 ? [] : _ref4$fieldPairs;

      if (fieldPairs.length < 2) {
        return {
          props: []
        };
      }

      var props = {
        color: (0, _colorUtils.hexToRgb)(_defaultSettings.DEFAULT_LAYER_COLOR.tripArc)
      }; // connect the first two point layer with arc

      props.columns = {
        lat0: fieldPairs[0].pair.lat,
        lng0: fieldPairs[0].pair.lng,
        lat1: fieldPairs[1].pair.lat,
        lng1: fieldPairs[1].pair.lng
      };
      props.label = "".concat(fieldPairs[0].defaultName, " -> ").concat(fieldPairs[1].defaultName, " arc");
      return {
        props: [props]
      };
    }
  }]);
  return ArcLayer;
}(_baseLayer["default"]);

exports["default"] = ArcLayer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9sYXllcnMvYXJjLWxheWVyL2FyYy1sYXllci5qcyJdLCJuYW1lcyI6WyJhcmNQb3NBY2Nlc3NvciIsImxhdDAiLCJsbmcwIiwibGF0MSIsImxuZzEiLCJkIiwiZGF0YSIsImZpZWxkSWR4IiwiYXJjUG9zUmVzb2x2ZXIiLCJhcmNSZXF1aXJlZENvbHVtbnMiLCJhcmNWaXNDb25maWdzIiwib3BhY2l0eSIsInRoaWNrbmVzcyIsImNvbG9yUmFuZ2UiLCJzaXplUmFuZ2UiLCJ0YXJnZXRDb2xvciIsIkFyY0xheWVyIiwicHJvcHMiLCJyZWdpc3RlclZpc0NvbmZpZyIsImdldFBvc2l0aW9uIiwiXyIsImFsbERhdGEiLCJmaWx0ZXJlZEluZGV4Iiwib2xkTGF5ZXJEYXRhIiwib3B0IiwiY29uZmlnIiwiY29sb3JTY2FsZSIsImNvbG9yRG9tYWluIiwiY29sb3JGaWVsZCIsImNvbG9yIiwiY29sdW1ucyIsInNpemVGaWVsZCIsInNpemVTY2FsZSIsInNpemVEb21haW4iLCJ2aXNDb25maWciLCJjU2NhbGUiLCJnZXRWaXNDaGFubmVsU2NhbGUiLCJjb2xvcnMiLCJtYXAiLCJoZXhUb1JnYiIsInNTY2FsZSIsInVwZGF0ZUxheWVyTWV0YSIsInNhbWVEYXRhIiwicmVkdWNlIiwiYWNjdSIsImluZGV4IiwicG9zIiwiZXZlcnkiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInB1c2giLCJzb3VyY2VQb3NpdGlvbiIsInRhcmdldFBvc2l0aW9uIiwiZ2V0U3Ryb2tlV2lkdGgiLCJnZXRFbmNvZGVkQ2hhbm5lbFZhbHVlIiwiZ2V0Q29sb3IiLCJnZXRUYXJnZXRDb2xvciIsImdldFNvdXJjZUNvbG9yIiwiZ2V0V2lkdGgiLCJzQm91bmRzIiwiZ2V0UG9pbnRzQm91bmRzIiwidEJvdW5kcyIsImJvdW5kcyIsIk1hdGgiLCJtaW4iLCJtYXgiLCJ1cGRhdGVNZXRhIiwiaWR4Iiwib2JqZWN0SG92ZXJlZCIsImxheWVySW50ZXJhY3Rpb24iLCJtYXBTdGF0ZSIsImludGVyYWN0aW9uQ29uZmlnIiwiYnJ1c2giLCJjb2xvclVwZGF0ZVRyaWdnZXJzIiwiaW50ZXJhY3Rpb24iLCJwaWNrYWJsZSIsImF1dG9IaWdobGlnaHQiLCJlbmFibGVkIiwiaGlnaGxpZ2h0Q29sb3IiLCJicnVzaFJhZGl1cyIsInNpemUiLCJicnVzaFNvdXJjZSIsImJydXNoVGFyZ2V0IiwiZW5hYmxlQnJ1c2hpbmciLCJBcmNCcnVzaGluZ0xheWVyIiwiaWQiLCJwaWNrZWRDb2xvciIsInN0cm9rZVNjYWxlIiwicGFyYW1ldGVycyIsImRlcHRoVGVzdCIsImRyYWdSb3RhdGUiLCJ1cGRhdGVUcmlnZ2VycyIsImlzTGF5ZXJIb3ZlcmVkIiwib2JqZWN0IiwiQXJjTGF5ZXJJY29uIiwiZGVmYXVsdExpbmtDb2x1bW5QYWlycyIsInByb3BlcnR5IiwiZmllbGRQYWlycyIsImxlbmd0aCIsIkRFRkFVTFRfTEFZRVJfQ09MT1IiLCJ0cmlwQXJjIiwicGFpciIsImxhdCIsImxuZyIsImxhYmVsIiwiZGVmYXVsdE5hbWUiLCJMYXllciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRU8sSUFBTUEsY0FBYyxHQUFHLFNBQWpCQSxjQUFpQjtBQUFBLE1BQUVDLElBQUYsUUFBRUEsSUFBRjtBQUFBLE1BQVFDLElBQVIsUUFBUUEsSUFBUjtBQUFBLE1BQWNDLElBQWQsUUFBY0EsSUFBZDtBQUFBLE1BQW9CQyxJQUFwQixRQUFvQkEsSUFBcEI7QUFBQSxTQUE4QixVQUFBQyxDQUFDO0FBQUEsV0FBSSxDQUMvREEsQ0FBQyxDQUFDQyxJQUFGLENBQU9KLElBQUksQ0FBQ0ssUUFBWixDQUQrRCxFQUUvREYsQ0FBQyxDQUFDQyxJQUFGLENBQU9MLElBQUksQ0FBQ00sUUFBWixDQUYrRCxFQUcvRCxDQUgrRCxFQUkvREYsQ0FBQyxDQUFDQyxJQUFGLENBQU9GLElBQUksQ0FBQ0csUUFBWixDQUorRCxFQUsv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O0FBRUQsVUFBTUEsS0FBSyxHQUFHO0FBQ1pZLFFBQUFBLEtBQUssRUFBRSwwQkFBU3NFLHFDQUFvQkMsT0FBN0I7QUFESyxPQUFkLENBTDhDLENBUzlDOztBQUNBbkYsTUFBQUEsS0FBSyxDQUFDYSxPQUFOLEdBQWdCO0FBQ2Q3QixRQUFBQSxJQUFJLEVBQUVnRyxVQUFVLENBQUMsQ0FBRCxDQUFWLENBQWNJLElBQWQsQ0FBbUJDLEdBRFg7QUFFZHBHLFFBQUFBLElBQUksRUFBRStGLFVBQVUsQ0FBQyxDQUFELENBQVYsQ0FBY0ksSUFBZCxDQUFtQkUsR0FGWDtBQUdkcEcsUUFBQUEsSUFBSSxFQUFFOEYsVUFBVSxDQUFDLENBQUQsQ0FBVixDQUFjSSxJQUFkLENBQW1CQyxHQUhYO0FBSWRsRyxRQUFBQSxJQUFJLEVBQUU2RixVQUFVLENBQUMsQ0FBRCxDQUFWLENBQWNJLElBQWQsQ0FBbUJFO0FBSlgsT0FBaEI7QUFNQXRGLE1BQUFBLEtBQUssQ0FBQ3VGLEtBQU4sYUFBaUJQLFVBQVUsQ0FBQyxDQUFELENBQVYsQ0FBY1EsV0FBL0IsaUJBQWlEUixVQUFVLENBQUMsQ0FBRCxDQUFWLENBQWNRLFdBQS9EO0FBRUEsYUFBTztBQUFDeEYsUUFBQUEsS0FBSyxFQUFFLENBQUNBLEtBQUQ7QUFBUixPQUFQO0FBQ0Q7OztFQXhEbUN5RixxQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxOSBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBtZW1vaXplIGZyb20gJ2xvZGFzaC5tZW1vaXplJztcblxuaW1wb3J0IExheWVyIGZyb20gJy4uL2Jhc2UtbGF5ZXInO1xuaW1wb3J0IEFyY0JydXNoaW5nTGF5ZXIgZnJvbSAnZGVja2dsLWxheWVycy9hcmMtYnJ1c2hpbmctbGF5ZXIvYXJjLWJydXNoaW5nLWxheWVyJztcbmltcG9ydCB7aGV4VG9SZ2J9IGZyb20gJ3V0aWxzL2NvbG9yLXV0aWxzJztcbmltcG9ydCBBcmNMYXllckljb24gZnJvbSAnLi9hcmMtbGF5ZXItaWNvbic7XG5pbXBvcnQge0RFRkFVTFRfTEFZRVJfQ09MT1J9IGZyb20gJ2NvbnN0YW50cy9kZWZhdWx0LXNldHRpbmdzJztcblxuZXhwb3J0IGNvbnN0IGFyY1Bvc0FjY2Vzc29yID0gKHtsYXQwLCBsbmcwLCBsYXQxLCBsbmcxfSkgPT4gZCA9PiBbXG4gIGQuZGF0YVtsbmcwLmZpZWxkSWR4XSxcbiAgZC5kYXRhW2xhdDAuZmllbGRJZHhdLFxuICAwLFxuICBkLmRhdGFbbG5nMS5maWVsZElkeF0sXG4gIGQuZGF0YVtsYXQxLmZpZWxkSWR4XSxcbiAgMFxuXTtcblxuZXhwb3J0IGNvbnN0IGFyY1Bvc1Jlc29sdmVyID0gKHtsYXQwLCBsbmcwLCBsYXQxLCBsbmcxfSkgPT5cbiAgYCR7bGF0MC5maWVsZElkeH0tJHtsbmcwLmZpZWxkSWR4fS0ke2xhdDEuZmllbGRJZHh9LSR7bGF0MS5maWVsZElkeH19YDtcblxuZXhwb3J0IGNvbnN0IGFyY1JlcXVpcmVkQ29sdW1ucyA9IFsnbGF0MCcsICdsbmcwJywgJ2xhdDEnLCAnbG5nMSddO1xuXG5leHBvcnQgY29uc3QgYXJjVmlzQ29uZmlncyA9IHtcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICB0aGlja25lc3M6ICd0aGlja25lc3MnLFxuICBjb2xvclJhbmdlOiAnY29sb3JSYW5nZScsXG4gIHNpemVSYW5nZTogJ3N0cm9rZVdpZHRoUmFuZ2UnLFxuICB0YXJnZXRDb2xvcjogJ3RhcmdldENvbG9yJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJjTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMucmVnaXN0ZXJWaXNDb25maWcoYXJjVmlzQ29uZmlncyk7XG4gICAgdGhpcy5nZXRQb3NpdGlvbiA9IG1lbW9pemUoYXJjUG9zQWNjZXNzb3IsIGFyY1Bvc1Jlc29sdmVyKTtcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnYXJjJztcbiAgfVxuXG4gIGdldCBpc0FnZ3JlZ2F0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0IGxheWVySWNvbigpIHtcbiAgICByZXR1cm4gQXJjTGF5ZXJJY29uO1xuICB9XG5cbiAgZ2V0IHJlcXVpcmVkTGF5ZXJDb2x1bW5zKCkge1xuICAgIHJldHVybiBhcmNSZXF1aXJlZENvbHVtbnM7XG4gIH1cblxuICBnZXQgY29sdW1uUGFpcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdExpbmtDb2x1bW5QYWlycztcbiAgfVxuXG4gIGdldCB2aXN1YWxDaGFubmVscygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIudmlzdWFsQ2hhbm5lbHMsXG4gICAgICBzaXplOiB7XG4gICAgICAgIC4uLnN1cGVyLnZpc3VhbENoYW5uZWxzLnNpemUsXG4gICAgICAgIHByb3BlcnR5OiAnc3Ryb2tlJ1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZmluZERlZmF1bHRMYXllclByb3BzKHtmaWVsZFBhaXJzID0gW119KSB7XG4gICAgaWYgKGZpZWxkUGFpcnMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHtwcm9wczogW119O1xuICAgIH1cblxuICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgY29sb3I6IGhleFRvUmdiKERFRkFVTFRfTEFZRVJfQ09MT1IudHJpcEFyYylcbiAgICB9O1xuXG4gICAgLy8gY29ubmVjdCB0aGUgZmlyc3QgdHdvIHBvaW50IGxheWVyIHdpdGggYXJjXG4gICAgcHJvcHMuY29sdW1ucyA9IHtcbiAgICAgIGxhdDA6IGZpZWxkUGFpcnNbMF0ucGFpci5sYXQsXG4gICAgICBsbmcwOiBmaWVsZFBhaXJzWzBdLnBhaXIubG5nLFxuICAgICAgbGF0MTogZmllbGRQYWlyc1sxXS5wYWlyLmxhdCxcbiAgICAgIGxuZzE6IGZpZWxkUGFpcnNbMV0ucGFpci5sbmdcbiAgICB9O1xuICAgIHByb3BzLmxhYmVsID0gYCR7ZmllbGRQYWlyc1swXS5kZWZhdWx0TmFtZX0gLT4gJHtmaWVsZFBhaXJzWzFdLmRlZmF1bHROYW1lfSBhcmNgO1xuXG4gICAgcmV0dXJuIHtwcm9wczogW3Byb3BzXX07XG4gIH1cblxuICAvLyBUT0RPOiBmaXggY29tcGxleGl0eVxuICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG4gIGZvcm1hdExheWVyRGF0YShfLCBhbGxEYXRhLCBmaWx0ZXJlZEluZGV4LCBvbGRMYXllckRhdGEsIG9wdCA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgY29sb3JTY2FsZSxcbiAgICAgIGNvbG9yRG9tYWluLFxuICAgICAgY29sb3JGaWVsZCxcbiAgICAgIGNvbG9yLFxuICAgICAgY29sdW1ucyxcbiAgICAgIHNpemVGaWVsZCxcbiAgICAgIHNpemVTY2FsZSxcbiAgICAgIHNpemVEb21haW4sXG4gICAgICB2aXNDb25maWc6IHtzaXplUmFuZ2UsIGNvbG9yUmFuZ2UsIHRhcmdldENvbG9yfVxuICAgIH0gPSB0aGlzLmNvbmZpZztcblxuICAgIC8vIGFyYyBjb2xvclxuICAgIGNvbnN0IGNTY2FsZSA9XG4gICAgICBjb2xvckZpZWxkICYmXG4gICAgICB0aGlzLmdldFZpc0NoYW5uZWxTY2FsZShcbiAgICAgICAgY29sb3JTY2FsZSxcbiAgICAgICAgY29sb3JEb21haW4sXG4gICAgICAgIGNvbG9yUmFuZ2UuY29sb3JzLm1hcChoZXhUb1JnYilcbiAgICAgICk7XG5cbiAgICAvLyBhcmMgdGhpY2tuZXNzXG4gICAgY29uc3Qgc1NjYWxlID1cbiAgICAgIHNpemVGaWVsZCAmJiB0aGlzLmdldFZpc0NoYW5uZWxTY2FsZShzaXplU2NhbGUsIHNpemVEb21haW4sIHNpemVSYW5nZSk7XG5cbiAgICBjb25zdCBnZXRQb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb24oY29sdW1ucyk7XG5cbiAgICBpZiAoIW9sZExheWVyRGF0YSB8fCBvbGRMYXllckRhdGEuZ2V0UG9zaXRpb24gIT09IGdldFBvc2l0aW9uKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxheWVyTWV0YShhbGxEYXRhLCBnZXRQb3NpdGlvbik7XG4gICAgfVxuXG4gICAgbGV0IGRhdGE7XG4gICAgaWYgKFxuICAgICAgb2xkTGF5ZXJEYXRhICYmXG4gICAgICBvbGRMYXllckRhdGEuZGF0YSAmJlxuICAgICAgb3B0LnNhbWVEYXRhICYmXG4gICAgICBvbGRMYXllckRhdGEuZ2V0UG9zaXRpb24gPT09IGdldFBvc2l0aW9uXG4gICAgKSB7XG4gICAgICBkYXRhID0gb2xkTGF5ZXJEYXRhLmRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSBmaWx0ZXJlZEluZGV4LnJlZHVjZSgoYWNjdSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gZ2V0UG9zaXRpb24oe2RhdGE6IGFsbERhdGFbaW5kZXhdfSk7XG5cbiAgICAgICAgLy8gaWYgZG9lc24ndCBoYXZlIHBvaW50IGxhdCBvciBsbmcsIGRvIG5vdCBhZGQgdGhlIGFyY1xuICAgICAgICAvLyBkZWNrLmdsIGNhbid0IGhhbmRsZSBwb3NpdGlvbiA9PSBudWxsXG4gICAgICAgIGlmICghcG9zLmV2ZXJ5KE51bWJlci5pc0Zpbml0ZSkpIHtcbiAgICAgICAgICByZXR1cm4gYWNjdTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFjY3UucHVzaCh7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgc291cmNlUG9zaXRpb246IFtwb3NbMF0sIHBvc1sxXSwgcG9zWzJdXSxcbiAgICAgICAgICB0YXJnZXRQb3NpdGlvbjogW3Bvc1szXSwgcG9zWzRdLCBwb3NbNV1dLFxuICAgICAgICAgIGRhdGE6IGFsbERhdGFbaW5kZXhdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBhY2N1O1xuICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIGNvbnN0IGdldFN0cm9rZVdpZHRoID0gc1NjYWxlXG4gICAgICA/IGQgPT4gdGhpcy5nZXRFbmNvZGVkQ2hhbm5lbFZhbHVlKHNTY2FsZSwgZC5kYXRhLCBzaXplRmllbGQsIDApXG4gICAgICA6IDE7XG5cbiAgICBjb25zdCBnZXRDb2xvciA9IGNTY2FsZVxuICAgICAgPyBkID0+IHRoaXMuZ2V0RW5jb2RlZENoYW5uZWxWYWx1ZShjU2NhbGUsIGQuZGF0YSwgY29sb3JGaWVsZClcbiAgICAgIDogY29sb3I7XG5cbiAgICBjb25zdCBnZXRUYXJnZXRDb2xvciA9IGNTY2FsZVxuICAgICAgPyBkID0+IHRoaXMuZ2V0RW5jb2RlZENoYW5uZWxWYWx1ZShjU2NhbGUsIGQuZGF0YSwgY29sb3JGaWVsZClcbiAgICAgIDogdGFyZ2V0Q29sb3IgfHwgY29sb3I7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSxcbiAgICAgIGdldENvbG9yLFxuICAgICAgZ2V0U291cmNlQ29sb3I6IGdldENvbG9yLFxuICAgICAgZ2V0VGFyZ2V0Q29sb3IsXG4gICAgICBnZXRXaWR0aDogZ2V0U3Ryb2tlV2lkdGhcbiAgICB9O1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuXG4gIHVwZGF0ZUxheWVyTWV0YShhbGxEYXRhLCBnZXRQb3NpdGlvbikge1xuICAgIC8vIGdldCBib3VuZHMgZnJvbSBhcmNzXG4gICAgY29uc3Qgc0JvdW5kcyA9IHRoaXMuZ2V0UG9pbnRzQm91bmRzKGFsbERhdGEsIGQgPT4ge1xuICAgICAgY29uc3QgcG9zID0gZ2V0UG9zaXRpb24oe2RhdGE6IGR9KTtcbiAgICAgIHJldHVybiBbcG9zWzBdLCBwb3NbMV1dO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdEJvdW5kcyA9IHRoaXMuZ2V0UG9pbnRzQm91bmRzKGFsbERhdGEsIGQgPT4ge1xuICAgICAgY29uc3QgcG9zID0gZ2V0UG9zaXRpb24oe2RhdGE6IGR9KTtcbiAgICAgIHJldHVybiBbcG9zWzNdLCBwb3NbNF1dO1xuICAgIH0pO1xuXG4gICAgY29uc3QgYm91bmRzID1cbiAgICAgIHRCb3VuZHMgJiYgc0JvdW5kc1xuICAgICAgICA/IFtcbiAgICAgICAgICAgIE1hdGgubWluKHNCb3VuZHNbMF0sIHRCb3VuZHNbMF0pLFxuICAgICAgICAgICAgTWF0aC5taW4oc0JvdW5kc1sxXSwgdEJvdW5kc1sxXSksXG4gICAgICAgICAgICBNYXRoLm1heChzQm91bmRzWzJdLCB0Qm91bmRzWzJdKSxcbiAgICAgICAgICAgIE1hdGgubWF4KHNCb3VuZHNbM10sIHRCb3VuZHNbM10pXG4gICAgICAgICAgXVxuICAgICAgICA6IHNCb3VuZHMgfHwgdEJvdW5kcztcblxuICAgIHRoaXMudXBkYXRlTWV0YSh7Ym91bmRzfSk7XG4gIH1cblxuICByZW5kZXJMYXllcih7XG4gICAgZGF0YSxcbiAgICBpZHgsXG4gICAgb2JqZWN0SG92ZXJlZCxcbiAgICBsYXllckludGVyYWN0aW9uLFxuICAgIG1hcFN0YXRlLFxuICAgIGludGVyYWN0aW9uQ29uZmlnXG4gIH0pIHtcbiAgICBjb25zdCB7YnJ1c2h9ID0gaW50ZXJhY3Rpb25Db25maWc7XG5cbiAgICBjb25zdCBjb2xvclVwZGF0ZVRyaWdnZXJzID0ge1xuICAgICAgY29sb3I6IHRoaXMuY29uZmlnLmNvbG9yLFxuICAgICAgY29sb3JGaWVsZDogdGhpcy5jb25maWcuY29sb3JGaWVsZCxcbiAgICAgIGNvbG9yUmFuZ2U6IHRoaXMuY29uZmlnLnZpc0NvbmZpZy5jb2xvclJhbmdlLFxuICAgICAgY29sb3JTY2FsZTogdGhpcy5jb25maWcuY29sb3JTY2FsZSxcbiAgICAgIHRhcmdldENvbG9yOiB0aGlzLmNvbmZpZy52aXNDb25maWcudGFyZ2V0Q29sb3JcbiAgICB9O1xuXG4gICAgY29uc3QgaW50ZXJhY3Rpb24gPSB7XG4gICAgICAvLyBhdXRvIGhpZ2hsaWdodGluZ1xuICAgICAgcGlja2FibGU6IHRydWUsXG4gICAgICBhdXRvSGlnaGxpZ2h0OiAhYnJ1c2guZW5hYmxlZCxcbiAgICAgIGhpZ2hsaWdodENvbG9yOiB0aGlzLmNvbmZpZy5oaWdobGlnaHRDb2xvcixcblxuICAgICAgLy8gYnJ1c2hpbmdcbiAgICAgIGJydXNoUmFkaXVzOiBicnVzaC5jb25maWcuc2l6ZSAqIDEwMDAsXG4gICAgICBicnVzaFNvdXJjZTogdHJ1ZSxcbiAgICAgIGJydXNoVGFyZ2V0OiB0cnVlLFxuICAgICAgZW5hYmxlQnJ1c2hpbmc6IGJydXNoLmVuYWJsZWRcbiAgICB9O1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBBcmNCcnVzaGluZ0xheWVyKHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgLi4uaW50ZXJhY3Rpb24sXG4gICAgICAgIC4uLmxheWVySW50ZXJhY3Rpb24sXG4gICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICBpZHgsXG4gICAgICAgIG9wYWNpdHk6IHRoaXMuY29uZmlnLnZpc0NvbmZpZy5vcGFjaXR5LFxuICAgICAgICBwaWNrZWRDb2xvcjogdGhpcy5jb25maWcuaGlnaGxpZ2h0Q29sb3IsXG4gICAgICAgIHN0cm9rZVNjYWxlOiB0aGlzLmNvbmZpZy52aXNDb25maWcudGhpY2tuZXNzLFxuXG4gICAgICAgIC8vIHBhcmFtZXRlcnNcbiAgICAgICAgcGFyYW1ldGVyczoge2RlcHRoVGVzdDogbWFwU3RhdGUuZHJhZ1JvdGF0ZX0sXG5cbiAgICAgICAgdXBkYXRlVHJpZ2dlcnM6IHtcbiAgICAgICAgICBnZXRXaWR0aDoge1xuICAgICAgICAgICAgc2l6ZUZpZWxkOiB0aGlzLmNvbmZpZy5zaXplRmllbGQsXG4gICAgICAgICAgICBzaXplUmFuZ2U6IHRoaXMuY29uZmlnLnZpc0NvbmZpZy5zaXplUmFuZ2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldFNvdXJjZUNvbG9yOiBjb2xvclVwZGF0ZVRyaWdnZXJzLFxuICAgICAgICAgIGdldFRhcmdldENvbG9yOiBjb2xvclVwZGF0ZVRyaWdnZXJzXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgLy8gaG92ZXIgbGF5ZXJcbiAgICAgIC4uLih0aGlzLmlzTGF5ZXJIb3ZlcmVkKG9iamVjdEhvdmVyZWQpXG4gICAgICAgID8gW1xuICAgICAgICAgICAgbmV3IEFyY0JydXNoaW5nTGF5ZXIoe1xuICAgICAgICAgICAgICBpZDogYCR7dGhpcy5pZH0taG92ZXJlZGAsXG4gICAgICAgICAgICAgIGRhdGE6IFtvYmplY3RIb3ZlcmVkLm9iamVjdF0sXG4gICAgICAgICAgICAgIHN0cm9rZVNjYWxlOiB0aGlzLmNvbmZpZy52aXNDb25maWcudGhpY2tuZXNzLFxuICAgICAgICAgICAgICBnZXRTb3VyY2VDb2xvcjogdGhpcy5jb25maWcuaGlnaGxpZ2h0Q29sb3IsXG4gICAgICAgICAgICAgIGdldFRhcmdldENvbG9yOiB0aGlzLmNvbmZpZy5oaWdobGlnaHRDb2xvcixcbiAgICAgICAgICAgICAgZ2V0V2lkdGg6IGRhdGEuZ2V0V2lkdGgsXG4gICAgICAgICAgICAgIHBpY2thYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdXG4gICAgICAgIDogW10pXG4gICAgXTtcbiAgfVxufVxuIl19