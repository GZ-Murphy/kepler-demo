"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.injector = injector;
exports.withState = withState;
exports.errorMsg = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _react = _interopRequireDefault(require("react"));

var _reactRedux = require("react-redux");

var _redux = require("redux");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _window = require("global/window");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var MissingComp = function MissingComp() {
  return _react["default"].createElement("div", null);
};

var errorMsg = {
  noDep: function noDep(fac, parent) {
    return "".concat(fac.name, " is required as a dependency of ").concat(parent.name, ", ") + "but is not provided to injectComponents. It will not be rendered";
  },
  notFunc: '`factory and its replacement should be a function`'
};
exports.errorMsg = errorMsg;

function injector() {
  var map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Map();
  var cache = new Map(); // map<factory, factory -> ?>

  var get = function get(fac, parent) {
    var factory = map.get(fac); // factory is not injected

    if (!factory) {
      _window.console.error(errorMsg.noDep(fac, parent));

      return MissingComp;
    }

    var instances = cache.get(factory) || factory.apply(void 0, (0, _toConsumableArray2["default"])(factory.deps ? factory.deps.map(function (dep) {
      return get(dep, factory);
    }) : []));
    cache.set(fac, instances);
    return instances;
  }; // if you have two functions that happen to have the exactly same text
  // it will be override: 2018-02-05


  return {
    provide: function provide(factory, replacement) {
      if (typeof factory !== 'function') {
        _window.console.error('Error injecting factory: ', factory);

        _window.console.error(errorMsg.notFunc);

        return injector(map);
      } else if (typeof replacement !== 'function') {
        _window.console.error('Error injecting replacement for: ', factory);

        _window.console.error(errorMsg.notFunc);

        return injector(map);
      }

      return injector(new Map(map).set(factory, replacement));
    },
    get: get
  };
}

var identity = function identity(state) {
  return state;
}; // Helper to add reducer state to custom component


function withState(lenses) {
  var mapStateToProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  var actions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return function (Component) {
    var WrappedComponent = function WrappedComponent(_ref, _ref2) {
      var state = _ref.state,
          props = (0, _objectWithoutProperties2["default"])(_ref, ["state"]);
      var selector = _ref2.selector,
          id = _ref2.id;
      return _react["default"].createElement(Component, lenses.reduce(function (totalState, lens) {
        return _objectSpread({}, totalState, {}, lens(selector(state)));
      }, props));
    };

    WrappedComponent.contextTypes = {
      selector: _propTypes["default"].func,
      id: _propTypes["default"].string
    };
    return (0, _reactRedux.connect)(function (state) {
      return _objectSpread({}, mapStateToProps(state), {
        state: state
      });
    }, function (dispatch) {
      return Object.keys(actions).reduce(function (accu, key) {
        return _objectSpread({}, accu, (0, _defineProperty2["default"])({}, key, (0, _redux.bindActionCreators)(actions[key], dispatch)));
      }, {});
    })(WrappedComponent);
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL2luamVjdG9yLmpzIl0sIm5hbWVzIjpbIk1pc3NpbmdDb21wIiwiZXJyb3JNc2ciLCJub0RlcCIsImZhYyIsInBhcmVudCIsIm5hbWUiLCJub3RGdW5jIiwiaW5qZWN0b3IiLCJtYXAiLCJNYXAiLCJjYWNoZSIsImdldCIsImZhY3RvcnkiLCJDb25zb2xlIiwiZXJyb3IiLCJpbnN0YW5jZXMiLCJkZXBzIiwiZGVwIiwic2V0IiwicHJvdmlkZSIsInJlcGxhY2VtZW50IiwiaWRlbnRpdHkiLCJzdGF0ZSIsIndpdGhTdGF0ZSIsImxlbnNlcyIsIm1hcFN0YXRlVG9Qcm9wcyIsImFjdGlvbnMiLCJDb21wb25lbnQiLCJXcmFwcGVkQ29tcG9uZW50IiwicHJvcHMiLCJzZWxlY3RvciIsImlkIiwicmVkdWNlIiwidG90YWxTdGF0ZSIsImxlbnMiLCJjb250ZXh0VHlwZXMiLCJQcm9wVHlwZXMiLCJmdW5jIiwic3RyaW5nIiwiZGlzcGF0Y2giLCJPYmplY3QiLCJrZXlzIiwiYWNjdSIsImtleSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQUVBLElBQU1BLFdBQVcsR0FBRyxTQUFkQSxXQUFjO0FBQUEsU0FBTSw0Q0FBTjtBQUFBLENBQXBCOztBQUNPLElBQU1DLFFBQVEsR0FBRztBQUN0QkMsRUFBQUEsS0FBSyxFQUFFLGVBQUNDLEdBQUQsRUFBTUMsTUFBTjtBQUFBLFdBQ0wsVUFBR0QsR0FBRyxDQUFDRSxJQUFQLDZDQUE4Q0QsTUFBTSxDQUFDQyxJQUFyRCw0RUFESztBQUFBLEdBRGU7QUFJdEJDLEVBQUFBLE9BQU8sRUFBRTtBQUphLENBQWpCOzs7QUFPQSxTQUFTQyxRQUFULEdBQW1DO0FBQUEsTUFBakJDLEdBQWlCLHVFQUFYLElBQUlDLEdBQUosRUFBVztBQUN4QyxNQUFNQyxLQUFLLEdBQUcsSUFBSUQsR0FBSixFQUFkLENBRHdDLENBQ2Y7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UUFBQUEsS0FBSyxFQUFMQTtBQUFqQztBQUFBLEtBREEsRUFFTCxVQUFBaUIsUUFBUTtBQUFBLGFBQUlDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZZixPQUFaLEVBQXFCTSxNQUFyQixDQUE0QixVQUFDVSxJQUFELEVBQU9DLEdBQVA7QUFBQSxpQ0FDbkNELElBRG1DLHVDQUVyQ0MsR0FGcUMsRUFFL0IsK0JBQW1CakIsT0FBTyxDQUFDaUIsR0FBRCxDQUExQixFQUFpQ0osUUFBakMsQ0FGK0I7QUFBQSxPQUE1QixFQUdSLEVBSFEsQ0FBSjtBQUFBLEtBRkgsRUFNTFgsZ0JBTkssQ0FBUDtBQU9ELEdBdkJEO0FBd0JEIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE5IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7Y29ubmVjdH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHtiaW5kQWN0aW9uQ3JlYXRvcnN9IGZyb20gJ3JlZHV4JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQge2NvbnNvbGUgYXMgQ29uc29sZX0gZnJvbSAnZ2xvYmFsL3dpbmRvdyc7XG5cbmNvbnN0IE1pc3NpbmdDb21wID0gKCkgPT4gPGRpdiAvPjtcbmV4cG9ydCBjb25zdCBlcnJvck1zZyA9IHtcbiAgbm9EZXA6IChmYWMsIHBhcmVudCkgPT5cbiAgICBgJHtmYWMubmFtZX0gaXMgcmVxdWlyZWQgYXMgYSBkZXBlbmRlbmN5IG9mICR7cGFyZW50Lm5hbWV9LCBgICtcbiAgICBgYnV0IGlzIG5vdCBwcm92aWRlZCB0byBpbmplY3RDb21wb25lbnRzLiBJdCB3aWxsIG5vdCBiZSByZW5kZXJlZGAsXG4gIG5vdEZ1bmM6ICdgZmFjdG9yeSBhbmQgaXRzIHJlcGxhY2VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uYCdcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RvcihtYXAgPSBuZXcgTWFwKCkpIHtcbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7IC8vIG1hcDxmYWN0b3J5LCBmYWN0b3J5IC0+ID8+XG4gIGNvbnN0IGdldCA9IChmYWMsIHBhcmVudCkgPT4ge1xuICAgIGNvbnN0IGZhY3RvcnkgPSBtYXAuZ2V0KGZhYyk7XG5cbiAgICAvLyBmYWN0b3J5IGlzIG5vdCBpbmplY3RlZFxuICAgIGlmICghZmFjdG9yeSkge1xuICAgICAgQ29uc29sZS5lcnJvcihlcnJvck1zZy5ub0RlcChmYWMsIHBhcmVudCkpO1xuICAgICAgcmV0dXJuIE1pc3NpbmdDb21wO1xuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlcyA9XG4gICAgICBjYWNoZS5nZXQoZmFjdG9yeSkgfHxcbiAgICAgIGZhY3RvcnkoXG4gICAgICAgIC4uLihmYWN0b3J5LmRlcHMgPyBmYWN0b3J5LmRlcHMubWFwKGRlcCA9PiBnZXQoZGVwLCBmYWN0b3J5KSkgOiBbXSlcbiAgICAgICk7XG5cbiAgICBjYWNoZS5zZXQoZmFjLCBpbnN0YW5jZXMpO1xuICAgIHJldHVybiBpbnN0YW5jZXM7XG4gIH07XG5cbiAgLy8gaWYgeW91IGhhdmUgdHdvIGZ1bmN0aW9ucyB0aGF0IGhhcHBlbiB0byBoYXZlIHRoZSBleGFjdGx5IHNhbWUgdGV4dFxuICAvLyBpdCB3aWxsIGJlIG92ZXJyaWRlOiAyMDE4LTAyLTA1XG4gIHJldHVybiB7XG4gICAgcHJvdmlkZTogKGZhY3RvcnksIHJlcGxhY2VtZW50KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgQ29uc29sZS5lcnJvcignRXJyb3IgaW5qZWN0aW5nIGZhY3Rvcnk6ICcsIGZhY3RvcnkpO1xuICAgICAgICBDb25zb2xlLmVycm9yKGVycm9yTXNnLm5vdEZ1bmMpO1xuICAgICAgICByZXR1cm4gaW5qZWN0b3IobWFwKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlcGxhY2VtZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIENvbnNvbGUuZXJyb3IoJ0Vycm9yIGluamVjdGluZyByZXBsYWNlbWVudCBmb3I6ICcsIGZhY3RvcnkpO1xuICAgICAgICBDb25zb2xlLmVycm9yKGVycm9yTXNnLm5vdEZ1bmMpO1xuICAgICAgICByZXR1cm4gaW5qZWN0b3IobWFwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluamVjdG9yKChuZXcgTWFwKG1hcCkpLnNldChmYWN0b3J5LCByZXBsYWNlbWVudCkpO1xuICAgIH0sXG4gICAgZ2V0XG4gIH07XG59XG5cbmNvbnN0IGlkZW50aXR5ID0gc3RhdGUgPT4gKHN0YXRlKTtcbi8vIEhlbHBlciB0byBhZGQgcmVkdWNlciBzdGF0ZSB0byBjdXN0b20gY29tcG9uZW50XG5leHBvcnQgZnVuY3Rpb24gd2l0aFN0YXRlKGxlbnNlcywgbWFwU3RhdGVUb1Byb3BzID0gaWRlbnRpdHksIGFjdGlvbnMgPSB7fSkge1xuICByZXR1cm4gKENvbXBvbmVudCkgPT4ge1xuICAgIGNvbnN0IFdyYXBwZWRDb21wb25lbnQgPSAoe3N0YXRlLCAuLi5wcm9wc30sIHtzZWxlY3RvciwgaWR9KSA9PiAoXG4gICAgICA8Q29tcG9uZW50XG4gICAgICAgIHsuLi5sZW5zZXMucmVkdWNlKFxuICAgICAgICAgICh0b3RhbFN0YXRlLCBsZW5zKSA9PiAoe1xuICAgICAgICAgICAgLi4udG90YWxTdGF0ZSxcbiAgICAgICAgICAgIC4uLmxlbnMoc2VsZWN0b3Ioc3RhdGUpKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHByb3BzXG4gICAgICAgICl9XG4gICAgICAvPlxuICAgICk7XG4gICAgV3JhcHBlZENvbXBvbmVudC5jb250ZXh0VHlwZXMgPSB7XG4gICAgICBzZWxlY3RvcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICBpZDogUHJvcFR5cGVzLnN0cmluZ1xuICAgIH07XG4gICAgcmV0dXJuIGNvbm5lY3QoXG4gICAgICBzdGF0ZSA9PiAoey4uLm1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSksIHN0YXRlfSksXG4gICAgICBkaXNwYXRjaCA9PiBPYmplY3Qua2V5cyhhY3Rpb25zKS5yZWR1Y2UoKGFjY3UsIGtleSkgPT4gKHtcbiAgICAgICAgLi4uYWNjdSxcbiAgICAgICAgW2tleV06IGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25zW2tleV0sIGRpc3BhdGNoKVxuICAgICAgfSksIHt9KVxuICAgICkoV3JhcHBlZENvbXBvbmVudCk7XG4gIH1cbn1cbiJdfQ==