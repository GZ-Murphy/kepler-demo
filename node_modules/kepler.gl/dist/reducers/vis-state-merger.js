"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeFilters = mergeFilters;
exports.mergeLayers = mergeLayers;
exports.mergeInteractions = mergeInteractions;
exports.mergeSplitMaps = mergeSplitMaps;
exports.mergeInteractionTooltipConfig = mergeInteractionTooltipConfig;
exports.mergeLayerBlending = mergeLayerBlending;
exports.mergeAnimationConfig = mergeAnimationConfig;
exports.validateSavedLayerColumns = validateSavedLayerColumns;
exports.validateSavedTextLabel = validateSavedTextLabel;
exports.validateSavedVisualChannels = validateSavedVisualChannels;
exports.validateLayerWithData = validateLayerWithData;
exports.validateFilterWithData = validateFilterWithData;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _lodash = _interopRequireDefault(require("lodash.uniq"));

var _lodash2 = _interopRequireDefault(require("lodash.pick"));

var _filterUtils = require("../utils/filter-utils");

var _splitMapUtils = require("../utils/split-map-utils");

var _defaultSettings = require("../constants/default-settings");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Merge loaded filters with current state, if no fields or data are loaded
 * save it for later
 *
 * @param {Object} state
 * @param {Array<Object>} filtersToMerge
 * @return {Object} updatedState
 */
function mergeFilters(state, filtersToMerge) {
  var merged = [];
  var unmerged = [];
  var datasets = state.datasets;

  if (!Array.isArray(filtersToMerge) || !filtersToMerge.length) {
    return state;
  } // merge filters


  filtersToMerge.forEach(function (filter) {
    // match filter.dataId with current datesets id
    // uploaded data need to have the same dataId with the filter
    if (datasets[filter.dataId]) {
      // datasets is already loaded
      var validateFilter = validateFilterWithData(datasets[filter.dataId], filter);

      if (validateFilter) {
        merged.push(validateFilter);
      }
    } else {
      // datasets not yet loaded
      unmerged.push(filter);
    }
  }); // filter data

  var updatedFilters = [].concat((0, _toConsumableArray2["default"])(state.filters || []), merged);
  var datasetToFilter = (0, _lodash["default"])(merged.map(function (d) {
    return d.dataId;
  }));
  var updatedDataset = datasetToFilter.reduce(function (accu, dataId) {
    return _objectSpread({}, accu, (0, _defineProperty2["default"])({}, dataId, _objectSpread({}, datasets[dataId], {}, (0, _filterUtils.filterData)(datasets[dataId].allData, dataId, updatedFilters))));
  }, datasets);
  return _objectSpread({}, state, {
    filters: updatedFilters,
    datasets: updatedDataset,
    filterToBeMerged: unmerged
  });
}
/**
 * Merge layers from de-serialized state, if no fields or data are loaded
 * save it for later
 *
 * @param {Object} state
 * @param {Array<Object>} layersToMerge
 * @return {Object} state
 */


function mergeLayers(state, layersToMerge) {
  var mergedLayer = [];
  var unmerged = [];
  var datasets = state.datasets;

  if (!Array.isArray(layersToMerge) || !layersToMerge.length) {
    return state;
  }

  layersToMerge.forEach(function (layer) {
    if (datasets[layer.config.dataId]) {
      // datasets are already loaded
      var validateLayer = validateLayerWithData(datasets[layer.config.dataId], layer, state.layerClasses);

      if (validateLayer) {
        mergedLayer.push(validateLayer);
      }
    } else {
      // datasets not yet loaded
      unmerged.push(layer);
    }
  });
  var layers = [].concat((0, _toConsumableArray2["default"])(state.layers), mergedLayer);
  var newLayerOrder = mergedLayer.map(function (_, i) {
    return state.layers.length + i;
  }); // put new layers in front of current layers

  var layerOrder = [].concat((0, _toConsumableArray2["default"])(newLayerOrder), (0, _toConsumableArray2["default"])(state.layerOrder));
  return _objectSpread({}, state, {
    layers: layers,
    layerOrder: layerOrder,
    layerToBeMerged: unmerged
  });
}
/**
 * Merge interactions with saved config
 *
 * @param {Object} state
 * @param {Object} interactionToBeMerged
 * @return {Object} mergedState
 */


function mergeInteractions(state, interactionToBeMerged) {
  var merged = {};
  var unmerged = {};

  if (interactionToBeMerged) {
    Object.keys(interactionToBeMerged).forEach(function (key) {
      if (!state.interactionConfig[key]) {
        return;
      }

      var _ref = interactionToBeMerged[key] || {},
          enabled = _ref.enabled,
          configSaved = (0, _objectWithoutProperties2["default"])(_ref, ["enabled"]);

      var configToMerge = configSaved;

      if (key === 'tooltip') {
        var _mergeInteractionTool = mergeInteractionTooltipConfig(state, configSaved),
            mergedTooltip = _mergeInteractionTool.mergedTooltip,
            unmergedTooltip = _mergeInteractionTool.unmergedTooltip; // merge new dataset tooltips with original dataset tooltips


        configToMerge = {
          fieldsToShow: _objectSpread({}, state.interactionConfig[key].config.fieldsToShow, {}, mergedTooltip)
        };

        if (Object.keys(unmergedTooltip).length) {
          unmerged.tooltip = {
            fieldsToShow: unmergedTooltip,
            enabled: enabled
          };
        }
      }

      merged[key] = _objectSpread({}, state.interactionConfig[key], {
        enabled: enabled,
        config: (0, _lodash2["default"])(_objectSpread({}, state.interactionConfig[key].config, {}, configToMerge), Object.keys(state.interactionConfig[key].config))
      });
    });
  }

  return _objectSpread({}, state, {
    interactionConfig: _objectSpread({}, state.interactionConfig, {}, merged),
    interactionToBeMerged: unmerged
  });
}
/**
 * Merge splitMaps config with current visStete.
 * 1. if current map is split, but splitMap DOESNOT contain maps
 *    : don't merge anything
 * 2. if current map is NOT split, but splitMaps contain maps
 *    : add to splitMaps, and add current layers to splitMaps
 */


function mergeSplitMaps(state) {
  var splitMaps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var merged = (0, _toConsumableArray2["default"])(state.splitMaps);
  var unmerged = [];
  splitMaps.forEach(function (sm, i) {
    Object.entries(sm.layers).forEach(function (_ref2) {
      var _ref3 = (0, _slicedToArray2["default"])(_ref2, 2),
          id = _ref3[0],
          value = _ref3[1];

      // check if layer exists
      var pushTo = state.layers.find(function (l) {
        return l.id === id;
      }) ? merged : unmerged; // create map panel if current map is not split

      pushTo[i] = pushTo[i] || {
        layers: pushTo === merged ? (0, _splitMapUtils.getInitialMapLayersForSplitMap)(state.layers) : []
      };
      pushTo[i].layers = _objectSpread({}, pushTo[i].layers, (0, _defineProperty2["default"])({}, id, value));
    });
  });
  return _objectSpread({}, state, {
    splitMaps: merged,
    splitMapsToBeMerged: unmerged
  });
}
/**
 * Merge interactionConfig.tooltip with saved config,
 * validate fieldsToShow
 *
 * @param {string} state
 * @param {Object} tooltipConfig
 * @return {Object} - {mergedTooltip: {}, unmergedTooltip: {}}
 */


function mergeInteractionTooltipConfig(state) {
  var tooltipConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var unmergedTooltip = {};
  var mergedTooltip = {};

  if (!tooltipConfig.fieldsToShow || !Object.keys(tooltipConfig.fieldsToShow).length) {
    return {
      mergedTooltip: mergedTooltip,
      unmergedTooltip: unmergedTooltip
    };
  }

  for (var dataId in tooltipConfig.fieldsToShow) {
    if (!state.datasets[dataId]) {
      // is not yet loaded
      unmergedTooltip[dataId] = tooltipConfig.fieldsToShow[dataId];
    } else {
      (function () {
        // if dataset is loaded
        var allFields = state.datasets[dataId].fields.map(function (d) {
          return d.name;
        });
        var foundFieldsToShow = tooltipConfig.fieldsToShow[dataId].filter(function (name) {
          return allFields.includes(name);
        });
        mergedTooltip[dataId] = foundFieldsToShow;
      })();
    }
  }

  return {
    mergedTooltip: mergedTooltip,
    unmergedTooltip: unmergedTooltip
  };
}
/**
 * Merge layerBlending with saved
 *
 * @param {object} state
 * @param {string} layerBlending
 * @return {object} merged state
 */


function mergeLayerBlending(state, layerBlending) {
  if (layerBlending && _defaultSettings.LAYER_BLENDINGS[layerBlending]) {
    return _objectSpread({}, state, {
      layerBlending: layerBlending
    });
  }

  return state;
}
/**
 * Merge animation config
 * @param {Object} state
 * @param {Object} animation
 */


function mergeAnimationConfig(state, animation) {
  if (animation && animation.currentTime) {
    return _objectSpread({}, state, {
      animationConfig: _objectSpread({}, state.animationConfig, {}, animation, {
        domain: null
      })
    });
  }

  return state;
}
/**
 * Validate saved layer columns with new data,
 * update fieldIdx based on new fields
 *
 * @param {Array<Object>} fields
 * @param {Object} savedCols
 * @param {Object} emptyCols
 * @return {null | Object} - validated columns or null
 */


function validateSavedLayerColumns(fields, savedCols, emptyCols) {
  var colFound = {}; // find actual column fieldIdx, in case it has changed

  var allColFound = Object.keys(emptyCols).every(function (key) {
    var saved = savedCols[key];
    colFound[key] = _objectSpread({}, emptyCols[key]);
    var fieldIdx = fields.findIndex(function (_ref4) {
      var name = _ref4.name;
      return name === saved;
    });

    if (fieldIdx > -1) {
      // update found columns
      colFound[key].fieldIdx = fieldIdx;
      colFound[key].value = saved;
      return true;
    } // if col is optional, allow null value


    return emptyCols[key].optional || false;
  });
  return allColFound && colFound;
}
/**
 * Validate saved text label config with new data
 * refer to vis-state-schema.js TextLabelSchemaV1
 *
 * @param {Array<Object>} fields
 * @param {Object} savedTextLabel
 * @return {Object} - validated textlabel
 */


function validateSavedTextLabel(fields, _ref5, savedTextLabel) {
  var _ref6 = (0, _slicedToArray2["default"])(_ref5, 1),
      layerTextLabel = _ref6[0];

  var savedTextLabels = Array.isArray(savedTextLabel) ? savedTextLabel : [savedTextLabel]; // validate field

  return savedTextLabels.map(function (textLabel) {
    var field = textLabel.field ? fields.find(function (fd) {
      return Object.keys(textLabel.field).every(function (key) {
        return textLabel.field[key] === fd[key];
      });
    }) : null;
    return Object.keys(layerTextLabel).reduce(function (accu, key) {
      return _objectSpread({}, accu, (0, _defineProperty2["default"])({}, key, key === 'field' ? field : textLabel[key] || layerTextLabel[key]));
    }, {});
  });
}
/**
 * Validate saved visual channels config with new data,
 * refer to vis-state-schema.js VisualChannelSchemaV1
 *
 * @param {Array<Object>} fields
 * @param {Object} visualChannels
 * @param {Object} savedLayer
 * @return {Object} - validated visual channel in config or {}
 */


function validateSavedVisualChannels(fields, visualChannels, savedLayer) {
  return Object.values(visualChannels).reduce(function (found, _ref7) {
    var field = _ref7.field,
        scale = _ref7.scale;
    var foundField;

    if (savedLayer.config[field]) {
      foundField = fields.find(function (fd) {
        return Object.keys(savedLayer.config[field]).every(function (key) {
          return savedLayer.config[field][key] === fd[key];
        });
      });
    }

    return _objectSpread({}, found, {}, foundField ? (0, _defineProperty2["default"])({}, field, foundField) : {}, {}, savedLayer.config[scale] ? (0, _defineProperty2["default"])({}, scale, savedLayer.config[scale]) : {});
  }, {});
}
/**
 * Validate saved layer config with new data,
 * update fieldIdx based on new fields
 *
 * @param {Array<Object>} fields
 * @param {string} dataId
 * @param {Object} savedLayer
 * @param {Object} layerClasses
 * @return {null | Object} - validated layer or null
 */


function validateLayerWithData(_ref10, savedLayer, layerClasses) {
  var fields = _ref10.fields,
      dataId = _ref10.id;
  var type = savedLayer.type; // layer doesnt have a valid type

  if (!layerClasses.hasOwnProperty(type) || !savedLayer.config || !savedLayer.config.columns) {
    return null;
  }

  var newLayer = new layerClasses[type]({
    id: savedLayer.id,
    dataId: dataId,
    label: savedLayer.config.label,
    color: savedLayer.config.color,
    isVisible: savedLayer.config.isVisible
  }); // find column fieldIdx

  var columns = validateSavedLayerColumns(fields, savedLayer.config.columns, newLayer.getLayerColumns());

  if (!columns) {
    return null;
  } // visual channel field is saved to be {name, type}
  // find visual channel field by matching both name and type
  // refer to vis-state-schema.js VisualChannelSchemaV1


  var foundVisualChannelConfigs = validateSavedVisualChannels(fields, newLayer.visualChannels, savedLayer);
  var textLabel = savedLayer.config.textLabel && newLayer.config.textLabel ? validateSavedTextLabel(fields, newLayer.config.textLabel, savedLayer.config.textLabel) : newLayer.config.textLabel; // copy visConfig over to emptyLayer to make sure it has all the props

  var visConfig = newLayer.copyLayerConfig(newLayer.config.visConfig, savedLayer.config.visConfig || {}, {
    shallowCopy: ['colorRange', 'strokeColorRange']
  });
  newLayer.updateLayerConfig(_objectSpread({
    columns: columns,
    visConfig: visConfig,
    textLabel: textLabel
  }, foundVisualChannelConfigs));
  return newLayer;
}
/**
 * Validate saved filter config with new data,
 * calculate domain and fieldIdx based new fields and data
 *
 * @param {Array<Object>} dataset.fields
 * @param {Array<Object>} dataset.allData
 * @param {Object} filter - filter to be validate
 * @return {Object | null} - validated filter
 */


function validateFilterWithData(_ref11, filter) {
  var fields = _ref11.fields,
      allData = _ref11.allData;
  // match filter.name to field.name
  var fieldIdx = fields.findIndex(function (_ref12) {
    var name = _ref12.name;
    return name === filter.name;
  });

  if (fieldIdx < 0) {
    // if can't find field with same name, discharge filter
    return null;
  }

  var field = fields[fieldIdx];
  var value = filter.value; // return filter type, default value, fieldType and fieldDomain from field

  var filterPropsFromField = (0, _filterUtils.getFilterProps)(allData, field);

  var matchedFilter = _objectSpread({}, (0, _filterUtils.getDefaultFilter)(filter.dataId), {}, filter, {}, filterPropsFromField, {
    freeze: true,
    fieldIdx: fieldIdx
  });

  var _matchedFilter = matchedFilter,
      yAxis = _matchedFilter.yAxis;

  if (yAxis) {
    var matcheAxis = fields.find(function (_ref13) {
      var name = _ref13.name,
          type = _ref13.type;
      return name === yAxis.name && type === yAxis.type;
    });
    matchedFilter = matcheAxis ? _objectSpread({}, matchedFilter, {
      yAxis: matcheAxis
    }, (0, _filterUtils.getFilterPlot)(_objectSpread({}, matchedFilter, {
      yAxis: matcheAxis
    }), allData)) : matchedFilter;
  }

  matchedFilter.value = (0, _filterUtils.adjustValueToFilterDomain)(value, matchedFilter);

  if (matchedFilter.value === null) {
    // cannt adjust saved value to filter
    return null;
  }

  return matchedFilter;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWR1Y2Vycy92aXMtc3RhdGUtbWVyZ2VyLmpzIl0sIm5hbWVzIjpbIm1lcmdlRmlsdGVycyIsInN0YXRlIiwiZmlsdGVyc1RvTWVyZ2UiLCJtZXJnZWQiLCJ1bm1lcmdlZCIsImRhdGFzZXRzIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiZm9yRWFjaCIsImZpbHRlciIsImRhdGFJZCIsInZhbGlkYXRlRmlsdGVyIiwidmFsaWRhdGVGaWx0ZXJXaXRoRGF0YSIsInB1c2giLCJ1cGRhdGVkRmlsdGVycyIsImZpbHRlcnMiLCJkYXRhc2V0VG9GaWx0ZXIiLCJtYXAiLCJkIiwidXBkYXRlZERhdGFzZXQiLCJyZWR1Y2UiLCJhY2N1IiwiYWxsRGF0YSIsImZpbHRlclRvQmVNZXJnZWQiLCJtZXJnZUxheWVycyIsImxheWVyc1RvTWVyZ2UiLCJtZXJnZWRMYXllciIsImxheWVyIiwiY29uZmlnIiwidmFsaWRhdGVMYXllciIsInZhbGlkYXRlTGF5ZXJXaXRoRGF0YSIsImxheWVyQ2xhc3NlcyIsImxheWVycyIsIm5ld0xheWVyT3JkZXIiLCJfIiwiaSIsImxheWVyT3JkZXIiLCJsYXllclRvQmVNZXJnZWQiLCJtZXJnZUludGVyYWN0aW9ucyIsImludGVyYWN0aW9uVG9CZU1lcmdlZCIsIk9iamVjdCIsImtleXMiLCJrZXkiLCJpbnRlcmFjdGlvbkNvbmZpZyIsImVuYWJsZWQiLCJjb25maWdTYXZlZCIsImNvbmZpZ1RvTWVyZ2UiLCJtZXJnZUludGVyYWN0aW9uVG9vbHRpcENvbmZpZyIsIm1lcmdlZFRvb2x0aXAiLCJ1bm1lcmdlZFRvb2x0aXAiLCJmaWVsZHNUb1Nob3ciLCJ0b29sdGlwIiwibWVyZ2VTcGxpdE1hcHMiLCJzcGxpdE1hcHMiLCJzbSIsImVudHJpZXMiLCJpZCIsInZhbHVlIiwicHVzaFRvIiwiZmluZCIsImwiLCJzcGxpdE1hcHNUb0JlTWVyZ2VkIiwidG9vbHRpcENvbmZpZyIsImFsbEZpZWxkcyIsImZpZWxkcyIsIm5hbWUiLCJmb3VuZEZpZWxkc1RvU2hvdyIsImluY2x1ZGVzIiwibWVyZ2VMYXllckJsZW5kaW5nIiwibGF5ZXJCbGVuZGluZyIsIkxBWUVSX0JMRU5ESU5HUyIsIm1lcmdlQW5pbWF0aW9uQ29uZmlnIiwiYW5pbWF0aW9uIiwiY3VycmVudFRpbWUiLCJhbmltYXRpb25Db25maWciLCJkb21haW4iLCJ2YWxpZGF0ZVNhdmVkTGF5ZXJDb2x1bW5zIiwic2F2ZWRDb2xzIiwiZW1wdHlDb2xzIiwiY29sRm91bmQiLCJhbGxDb2xGb3VuZCIsImV2ZXJ5Iiwic2F2ZWQiLCJmaWVsZElkeCIsImZpbmRJbmRleCIsIm9wdGlvbmFsIiwidmFsaWRhdGVTYXZlZFRleHRMYWJlbCIsInNhdmVkVGV4dExhYmVsIiwibGF5ZXJUZXh0TGFiZWwiLCJzYXZlZFRleHRMYWJlbHMiLCJ0ZXh0TGFiZWwiLCJmaWVsZCIsImZkIiwidmFsaWRhdGVTYXZlZFZpc3VhbENoYW5uZWxzIiwidmlzdWFsQ2hhbm5lbHMiLCJzYXZlZExheWVyIiwidmFsdWVzIiwiZm91bmQiLCJzY2FsZSIsImZvdW5kRmllbGQiLCJ0eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjb2x1bW5zIiwibmV3TGF5ZXIiLCJsYWJlbCIsImNvbG9yIiwiaXNWaXNpYmxlIiwiZ2V0TGF5ZXJDb2x1bW5zIiwiZm91bmRWaXN1YWxDaGFubmVsQ29uZmlncyIsInZpc0NvbmZpZyIsImNvcHlMYXllckNvbmZpZyIsInNoYWxsb3dDb3B5IiwidXBkYXRlTGF5ZXJDb25maWciLCJmaWx0ZXJQcm9wc0Zyb21GaWVsZCIsIm1hdGNoZWRGaWx0ZXIiLCJmcmVlemUiLCJ5QXhpcyIsIm1hdGNoZUF4aXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBRUE7O0FBUUE7O0FBRUE7Ozs7OztBQUVBOzs7Ozs7OztBQVFPLFNBQVNBLFlBQVQsQ0FBc0JDLEtBQXRCLEVBQTZCQyxjQUE3QixFQUE2QztBQUNsRCxNQUFNQyxNQUFN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QixDQVZnRSxDQVloRTs7QUFDQSxNQUFNd0Qsb0JBQW9CLEdBQUcsaUNBQWUzRixPQUFmLEVBQXdCcUUsS0FBeEIsQ0FBN0I7O0FBRUEsTUFBSXVCLGFBQWEscUJBQ1osbUNBQWlCekcsTUFBTSxDQUFDQyxNQUF4QixDQURZLE1BRVpELE1BRlksTUFHWndHLG9CQUhZO0FBSWZFLElBQUFBLE1BQU0sRUFBRSxJQUpPO0FBS2ZoQyxJQUFBQSxRQUFRLEVBQVJBO0FBTGUsSUFBakI7O0FBZmdFLHVCQXVCaEQrQixhQXZCZ0Q7QUFBQSxNQXVCekRFLEtBdkJ5RCxrQkF1QnpEQSxLQXZCeUQ7O0FBd0JoRSxNQUFJQSxLQUFKLEVBQVc7QUFDVCxRQUFNQyxVQUFVLEdBQUdyRCxNQUFNLENBQUNMLElBQVAsQ0FDakI7QUFBQSxVQUFFTSxJQUFGLFVBQUVBLElBQUY7QUFBQSxVQUFRbUMsSUFBUixVQUFRQSxJQUFSO0FBQUEsYUFBa0JuQyxJQUFJLEtBQUttRCxLQUFLLENBQUNuRCxJQUFmLElBQXVCbUMsSUFBSSxLQUFLZ0IsS0FBSyxDQUFDaEIsSUFBeEQ7QUFBQSxLQURpQixDQUFuQjtBQUlBYyxJQUFBQSxhQUFhLEdBQUdHLFVBQVUscUJBRWpCSCxhQUZpQjtBQUdwQkUsTUFBQUEsS0FBSyxFQUFFQztBQUhhLE9BSWpCLGtEQUFrQkgsYUFBbEI7QUFBaUNFLE1BQUFBLEtBQUssRUFBRUM7QUFBeEMsUUFBcUQvRixPQUFyRCxDQUppQixJQU10QjRGLGFBTko7QUFPRDs7QUFFREEsRUFBQUEsYUFBYSxDQUFDekQsS0FBZCxHQUFzQiw0Q0FBMEJBLEtBQTFCLEVBQWlDeUQsYUFBakMsQ0FBdEI7O0FBRUEsTUFBSUEsYUFBYSxDQUFDekQsS0FBZCxLQUF3QixJQUE1QixFQUFrQztBQUNoQztBQUNBLFdBQU8sSUFBUDtBQUNEOztBQUVELFNBQU95RCxhQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTkgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgdW5pcSBmcm9tICdsb2Rhc2gudW5pcSc7XG5pbXBvcnQgcGljayBmcm9tICdsb2Rhc2gucGljayc7XG5cbmltcG9ydCB7XG4gIGdldERlZmF1bHRGaWx0ZXIsXG4gIGdldEZpbHRlclByb3BzLFxuICBnZXRGaWx0ZXJQbG90LFxuICBmaWx0ZXJEYXRhLFxuICBhZGp1c3RWYWx1ZVRvRmlsdGVyRG9tYWluXG59IGZyb20gJ3V0aWxzL2ZpbHRlci11dGlscyc7XG5cbmltcG9ydCB7Z2V0SW5pdGlhbE1hcExheWVyc0ZvclNwbGl0TWFwfSBmcm9tICd1dGlscy9zcGxpdC1tYXAtdXRpbHMnO1xuXG5pbXBvcnQge0xBWUVSX0JMRU5ESU5HU30gZnJvbSAnY29uc3RhbnRzL2RlZmF1bHQtc2V0dGluZ3MnO1xuXG4vKipcbiAqIE1lcmdlIGxvYWRlZCBmaWx0ZXJzIHdpdGggY3VycmVudCBzdGF0ZSwgaWYgbm8gZmllbGRzIG9yIGRhdGEgYXJlIGxvYWRlZFxuICogc2F2ZSBpdCBmb3IgbGF0ZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZmlsdGVyc1RvTWVyZ2VcbiAqIEByZXR1cm4ge09iamVjdH0gdXBkYXRlZFN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUZpbHRlcnMoc3RhdGUsIGZpbHRlcnNUb01lcmdlKSB7XG4gIGNvbnN0IG1lcmdlZCA9IFtdO1xuICBjb25zdCB1bm1lcmdlZCA9IFtdO1xuICBjb25zdCB7ZGF0YXNldHN9ID0gc3RhdGU7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGZpbHRlcnNUb01lcmdlKSB8fCAhZmlsdGVyc1RvTWVyZ2UubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgLy8gbWVyZ2UgZmlsdGVyc1xuICBmaWx0ZXJzVG9NZXJnZS5mb3JFYWNoKGZpbHRlciA9PiB7XG4gICAgLy8gbWF0Y2ggZmlsdGVyLmRhdGFJZCB3aXRoIGN1cnJlbnQgZGF0ZXNldHMgaWRcbiAgICAvLyB1cGxvYWRlZCBkYXRhIG5lZWQgdG8gaGF2ZSB0aGUgc2FtZSBkYXRhSWQgd2l0aCB0aGUgZmlsdGVyXG4gICAgaWYgKGRhdGFzZXRzW2ZpbHRlci5kYXRhSWRdKSB7XG4gICAgICAvLyBkYXRhc2V0cyBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgY29uc3QgdmFsaWRhdGVGaWx0ZXIgPSB2YWxpZGF0ZUZpbHRlcldpdGhEYXRhKFxuICAgICAgICBkYXRhc2V0c1tmaWx0ZXIuZGF0YUlkXSxcbiAgICAgICAgZmlsdGVyXG4gICAgICApO1xuXG4gICAgICBpZiAodmFsaWRhdGVGaWx0ZXIpIHtcbiAgICAgICAgbWVyZ2VkLnB1c2godmFsaWRhdGVGaWx0ZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkYXRhc2V0cyBub3QgeWV0IGxvYWRlZFxuICAgICAgdW5tZXJnZWQucHVzaChmaWx0ZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZmlsdGVyIGRhdGFcbiAgY29uc3QgdXBkYXRlZEZpbHRlcnMgPSBbLi4uKHN0YXRlLmZpbHRlcnMgfHwgW10pLCAuLi5tZXJnZWRdO1xuICBjb25zdCBkYXRhc2V0VG9GaWx0ZXIgPSB1bmlxKG1lcmdlZC5tYXAoZCA9PiBkLmRhdGFJZCkpO1xuXG4gIGNvbnN0IHVwZGF0ZWREYXRhc2V0ID0gZGF0YXNldFRvRmlsdGVyLnJlZHVjZShcbiAgICAoYWNjdSwgZGF0YUlkKSA9PiAoe1xuICAgICAgLi4uYWNjdSxcbiAgICAgIFtkYXRhSWRdOiB7XG4gICAgICAgIC4uLmRhdGFzZXRzW2RhdGFJZF0sXG4gICAgICAgIC4uLmZpbHRlckRhdGEoZGF0YXNldHNbZGF0YUlkXS5hbGxEYXRhLCBkYXRhSWQsIHVwZGF0ZWRGaWx0ZXJzKVxuICAgICAgfVxuICAgIH0pLFxuICAgIGRhdGFzZXRzXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBmaWx0ZXJzOiB1cGRhdGVkRmlsdGVycyxcbiAgICBkYXRhc2V0czogdXBkYXRlZERhdGFzZXQsXG4gICAgZmlsdGVyVG9CZU1lcmdlZDogdW5tZXJnZWRcbiAgfTtcbn1cblxuLyoqXG4gKiBNZXJnZSBsYXllcnMgZnJvbSBkZS1zZXJpYWxpemVkIHN0YXRlLCBpZiBubyBmaWVsZHMgb3IgZGF0YSBhcmUgbG9hZGVkXG4gKiBzYXZlIGl0IGZvciBsYXRlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBsYXllcnNUb01lcmdlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUxheWVycyhzdGF0ZSwgbGF5ZXJzVG9NZXJnZSkge1xuICBjb25zdCBtZXJnZWRMYXllciA9IFtdO1xuICBjb25zdCB1bm1lcmdlZCA9IFtdO1xuXG4gIGNvbnN0IHtkYXRhc2V0c30gPSBzdGF0ZTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkobGF5ZXJzVG9NZXJnZSkgfHwgIWxheWVyc1RvTWVyZ2UubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgbGF5ZXJzVG9NZXJnZS5mb3JFYWNoKGxheWVyID0+IHtcbiAgICBpZiAoZGF0YXNldHNbbGF5ZXIuY29uZmlnLmRhdGFJZF0pIHtcbiAgICAgIC8vIGRhdGFzZXRzIGFyZSBhbHJlYWR5IGxvYWRlZFxuICAgICAgY29uc3QgdmFsaWRhdGVMYXllciA9IHZhbGlkYXRlTGF5ZXJXaXRoRGF0YShcbiAgICAgICAgZGF0YXNldHNbbGF5ZXIuY29uZmlnLmRhdGFJZF0sXG4gICAgICAgIGxheWVyLFxuICAgICAgICBzdGF0ZS5sYXllckNsYXNzZXNcbiAgICAgICk7XG5cbiAgICAgIGlmICh2YWxpZGF0ZUxheWVyKSB7XG4gICAgICAgIG1lcmdlZExheWVyLnB1c2godmFsaWRhdGVMYXllcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRhdGFzZXRzIG5vdCB5ZXQgbG9hZGVkXG4gICAgICB1bm1lcmdlZC5wdXNoKGxheWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGxheWVycyA9IFsuLi5zdGF0ZS5sYXllcnMsIC4uLm1lcmdlZExheWVyXTtcbiAgY29uc3QgbmV3TGF5ZXJPcmRlciA9IG1lcmdlZExheWVyLm1hcCgoXywgaSkgPT4gc3RhdGUubGF5ZXJzLmxlbmd0aCArIGkpO1xuXG4gIC8vIHB1dCBuZXcgbGF5ZXJzIGluIGZyb250IG9mIGN1cnJlbnQgbGF5ZXJzXG4gIGNvbnN0IGxheWVyT3JkZXIgPSBbLi4ubmV3TGF5ZXJPcmRlciwgLi4uc3RhdGUubGF5ZXJPcmRlcl07XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBsYXllcnMsXG4gICAgbGF5ZXJPcmRlcixcbiAgICBsYXllclRvQmVNZXJnZWQ6IHVubWVyZ2VkXG4gIH07XG59XG5cbi8qKlxuICogTWVyZ2UgaW50ZXJhY3Rpb25zIHdpdGggc2F2ZWQgY29uZmlnXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkXG4gKiBAcmV0dXJuIHtPYmplY3R9IG1lcmdlZFN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUludGVyYWN0aW9ucyhzdGF0ZSwgaW50ZXJhY3Rpb25Ub0JlTWVyZ2VkKSB7XG4gIGNvbnN0IG1lcmdlZCA9IHt9O1xuICBjb25zdCB1bm1lcmdlZCA9IHt9O1xuXG4gIGlmIChpbnRlcmFjdGlvblRvQmVNZXJnZWQpIHtcbiAgICBPYmplY3Qua2V5cyhpbnRlcmFjdGlvblRvQmVNZXJnZWQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmICghc3RhdGUuaW50ZXJhY3Rpb25Db25maWdba2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtlbmFibGVkLCAuLi5jb25maWdTYXZlZH0gPSBpbnRlcmFjdGlvblRvQmVNZXJnZWRba2V5XSB8fCB7fTtcbiAgICAgIGxldCBjb25maWdUb01lcmdlID0gY29uZmlnU2F2ZWQ7XG5cbiAgICAgIGlmIChrZXkgPT09ICd0b29sdGlwJykge1xuICAgICAgICBjb25zdCB7bWVyZ2VkVG9vbHRpcCwgdW5tZXJnZWRUb29sdGlwfSA9IG1lcmdlSW50ZXJhY3Rpb25Ub29sdGlwQ29uZmlnKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGNvbmZpZ1NhdmVkXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gbWVyZ2UgbmV3IGRhdGFzZXQgdG9vbHRpcHMgd2l0aCBvcmlnaW5hbCBkYXRhc2V0IHRvb2x0aXBzXG4gICAgICAgIGNvbmZpZ1RvTWVyZ2UgPSB7XG4gICAgICAgICAgZmllbGRzVG9TaG93OiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZ1trZXldLmNvbmZpZy5maWVsZHNUb1Nob3csXG4gICAgICAgICAgICAuLi5tZXJnZWRUb29sdGlwXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh1bm1lcmdlZFRvb2x0aXApLmxlbmd0aCkge1xuICAgICAgICAgIHVubWVyZ2VkLnRvb2x0aXAgPSB7ZmllbGRzVG9TaG93OiB1bm1lcmdlZFRvb2x0aXAsIGVuYWJsZWR9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lcmdlZFtrZXldID0ge1xuICAgICAgICAuLi5zdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZ1trZXldLFxuICAgICAgICBlbmFibGVkLFxuICAgICAgICBjb25maWc6IHBpY2soXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4uc3RhdGUuaW50ZXJhY3Rpb25Db25maWdba2V5XS5jb25maWcsXG4gICAgICAgICAgICAuLi5jb25maWdUb01lcmdlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBPYmplY3Qua2V5cyhzdGF0ZS5pbnRlcmFjdGlvbkNvbmZpZ1trZXldLmNvbmZpZylcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgaW50ZXJhY3Rpb25Db25maWc6IHtcbiAgICAgIC4uLnN0YXRlLmludGVyYWN0aW9uQ29uZmlnLFxuICAgICAgLi4ubWVyZ2VkXG4gICAgfSxcbiAgICBpbnRlcmFjdGlvblRvQmVNZXJnZWQ6IHVubWVyZ2VkXG4gIH07XG59XG5cbi8qKlxuICogTWVyZ2Ugc3BsaXRNYXBzIGNvbmZpZyB3aXRoIGN1cnJlbnQgdmlzU3RldGUuXG4gKiAxLiBpZiBjdXJyZW50IG1hcCBpcyBzcGxpdCwgYnV0IHNwbGl0TWFwIERPRVNOT1QgY29udGFpbiBtYXBzXG4gKiAgICA6IGRvbid0IG1lcmdlIGFueXRoaW5nXG4gKiAyLiBpZiBjdXJyZW50IG1hcCBpcyBOT1Qgc3BsaXQsIGJ1dCBzcGxpdE1hcHMgY29udGFpbiBtYXBzXG4gKiAgICA6IGFkZCB0byBzcGxpdE1hcHMsIGFuZCBhZGQgY3VycmVudCBsYXllcnMgdG8gc3BsaXRNYXBzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVNwbGl0TWFwcyhzdGF0ZSwgc3BsaXRNYXBzID0gW10pIHtcbiAgY29uc3QgbWVyZ2VkID0gWy4uLnN0YXRlLnNwbGl0TWFwc107XG4gIGNvbnN0IHVubWVyZ2VkID0gW107XG4gIHNwbGl0TWFwcy5mb3JFYWNoKChzbSwgaSkgPT4ge1xuICAgIE9iamVjdC5lbnRyaWVzKHNtLmxheWVycykuZm9yRWFjaCgoW2lkLCB2YWx1ZV0pID0+IHtcbiAgICAgIC8vIGNoZWNrIGlmIGxheWVyIGV4aXN0c1xuICAgICAgY29uc3QgcHVzaFRvID0gc3RhdGUubGF5ZXJzLmZpbmQobCA9PiBsLmlkID09PSBpZCkgPyBtZXJnZWQgOiB1bm1lcmdlZDtcblxuICAgICAgLy8gY3JlYXRlIG1hcCBwYW5lbCBpZiBjdXJyZW50IG1hcCBpcyBub3Qgc3BsaXRcbiAgICAgIHB1c2hUb1tpXSA9IHB1c2hUb1tpXSB8fCB7XG4gICAgICAgIGxheWVyczogcHVzaFRvID09PSBtZXJnZWQgPyBnZXRJbml0aWFsTWFwTGF5ZXJzRm9yU3BsaXRNYXAoc3RhdGUubGF5ZXJzKSA6IFtdXG4gICAgICB9O1xuICAgICAgcHVzaFRvW2ldLmxheWVycyA9IHtcbiAgICAgICAgLi4ucHVzaFRvW2ldLmxheWVycyxcbiAgICAgICAgW2lkXTogdmFsdWVcbiAgICAgIH07XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgc3BsaXRNYXBzOiBtZXJnZWQsXG4gICAgc3BsaXRNYXBzVG9CZU1lcmdlZDogdW5tZXJnZWRcbiAgfTtcbn1cblxuLyoqXG4gKiBNZXJnZSBpbnRlcmFjdGlvbkNvbmZpZy50b29sdGlwIHdpdGggc2F2ZWQgY29uZmlnLFxuICogdmFsaWRhdGUgZmllbGRzVG9TaG93XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdG9vbHRpcENvbmZpZ1xuICogQHJldHVybiB7T2JqZWN0fSAtIHttZXJnZWRUb29sdGlwOiB7fSwgdW5tZXJnZWRUb29sdGlwOiB7fX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSW50ZXJhY3Rpb25Ub29sdGlwQ29uZmlnKHN0YXRlLCB0b29sdGlwQ29uZmlnID0ge30pIHtcbiAgY29uc3QgdW5tZXJnZWRUb29sdGlwID0ge307XG4gIGNvbnN0IG1lcmdlZFRvb2x0aXAgPSB7fTtcblxuICBpZiAoXG4gICAgIXRvb2x0aXBDb25maWcuZmllbGRzVG9TaG93IHx8XG4gICAgIU9iamVjdC5rZXlzKHRvb2x0aXBDb25maWcuZmllbGRzVG9TaG93KS5sZW5ndGhcbiAgKSB7XG4gICAgcmV0dXJuIHttZXJnZWRUb29sdGlwLCB1bm1lcmdlZFRvb2x0aXB9O1xuICB9XG5cbiAgZm9yIChjb25zdCBkYXRhSWQgaW4gdG9vbHRpcENvbmZpZy5maWVsZHNUb1Nob3cpIHtcbiAgICBpZiAoIXN0YXRlLmRhdGFzZXRzW2RhdGFJZF0pIHtcbiAgICAgIC8vIGlzIG5vdCB5ZXQgbG9hZGVkXG4gICAgICB1bm1lcmdlZFRvb2x0aXBbZGF0YUlkXSA9IHRvb2x0aXBDb25maWcuZmllbGRzVG9TaG93W2RhdGFJZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGRhdGFzZXQgaXMgbG9hZGVkXG4gICAgICBjb25zdCBhbGxGaWVsZHMgPSBzdGF0ZS5kYXRhc2V0c1tkYXRhSWRdLmZpZWxkcy5tYXAoZCA9PiBkLm5hbWUpO1xuICAgICAgY29uc3QgZm91bmRGaWVsZHNUb1Nob3cgPSB0b29sdGlwQ29uZmlnLmZpZWxkc1RvU2hvd1tkYXRhSWRdLmZpbHRlcihcbiAgICAgICAgbmFtZSA9PiBhbGxGaWVsZHMuaW5jbHVkZXMobmFtZSlcbiAgICAgICk7XG5cbiAgICAgIG1lcmdlZFRvb2x0aXBbZGF0YUlkXSA9IGZvdW5kRmllbGRzVG9TaG93O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7bWVyZ2VkVG9vbHRpcCwgdW5tZXJnZWRUb29sdGlwfTtcbn1cbi8qKlxuICogTWVyZ2UgbGF5ZXJCbGVuZGluZyB3aXRoIHNhdmVkXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJCbGVuZGluZ1xuICogQHJldHVybiB7b2JqZWN0fSBtZXJnZWQgc3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlTGF5ZXJCbGVuZGluZyhzdGF0ZSwgbGF5ZXJCbGVuZGluZykge1xuICBpZiAobGF5ZXJCbGVuZGluZyAmJiBMQVlFUl9CTEVORElOR1NbbGF5ZXJCbGVuZGluZ10pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBsYXllckJsZW5kaW5nXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBNZXJnZSBhbmltYXRpb24gY29uZmlnXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbmltYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQW5pbWF0aW9uQ29uZmlnKHN0YXRlLCBhbmltYXRpb24pIHtcbiAgaWYgKGFuaW1hdGlvbiAmJiBhbmltYXRpb24uY3VycmVudFRpbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBhbmltYXRpb25Db25maWc6IHtcbiAgICAgICAgLi4uc3RhdGUuYW5pbWF0aW9uQ29uZmlnLFxuICAgICAgICAuLi5hbmltYXRpb24sXG4gICAgICAgIGRvbWFpbjogbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBzYXZlZCBsYXllciBjb2x1bW5zIHdpdGggbmV3IGRhdGEsXG4gKiB1cGRhdGUgZmllbGRJZHggYmFzZWQgb24gbmV3IGZpZWxkc1xuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZmllbGRzXG4gKiBAcGFyYW0ge09iamVjdH0gc2F2ZWRDb2xzXG4gKiBAcGFyYW0ge09iamVjdH0gZW1wdHlDb2xzXG4gKiBAcmV0dXJuIHtudWxsIHwgT2JqZWN0fSAtIHZhbGlkYXRlZCBjb2x1bW5zIG9yIG51bGxcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTYXZlZExheWVyQ29sdW1ucyhmaWVsZHMsIHNhdmVkQ29scywgZW1wdHlDb2xzKSB7XG4gIGNvbnN0IGNvbEZvdW5kID0ge307XG4gIC8vIGZpbmQgYWN0dWFsIGNvbHVtbiBmaWVsZElkeCwgaW4gY2FzZSBpdCBoYXMgY2hhbmdlZFxuICBjb25zdCBhbGxDb2xGb3VuZCA9IE9iamVjdC5rZXlzKGVtcHR5Q29scykuZXZlcnkoa2V5ID0+IHtcbiAgICBjb25zdCBzYXZlZCA9IHNhdmVkQ29sc1trZXldO1xuICAgIGNvbEZvdW5kW2tleV0gPSB7Li4uZW1wdHlDb2xzW2tleV19O1xuXG4gICAgY29uc3QgZmllbGRJZHggPSBmaWVsZHMuZmluZEluZGV4KCh7bmFtZX0pID0+IG5hbWUgPT09IHNhdmVkKTtcblxuICAgIGlmIChmaWVsZElkeCA+IC0xKSB7XG4gICAgICAvLyB1cGRhdGUgZm91bmQgY29sdW1uc1xuICAgICAgY29sRm91bmRba2V5XS5maWVsZElkeCA9IGZpZWxkSWR4O1xuICAgICAgY29sRm91bmRba2V5XS52YWx1ZSA9IHNhdmVkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gaWYgY29sIGlzIG9wdGlvbmFsLCBhbGxvdyBudWxsIHZhbHVlXG4gICAgcmV0dXJuIGVtcHR5Q29sc1trZXldLm9wdGlvbmFsIHx8IGZhbHNlO1xuICB9KTtcblxuICByZXR1cm4gYWxsQ29sRm91bmQgJiYgY29sRm91bmQ7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgc2F2ZWQgdGV4dCBsYWJlbCBjb25maWcgd2l0aCBuZXcgZGF0YVxuICogcmVmZXIgdG8gdmlzLXN0YXRlLXNjaGVtYS5qcyBUZXh0TGFiZWxTY2hlbWFWMVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZmllbGRzXG4gKiBAcGFyYW0ge09iamVjdH0gc2F2ZWRUZXh0TGFiZWxcbiAqIEByZXR1cm4ge09iamVjdH0gLSB2YWxpZGF0ZWQgdGV4dGxhYmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVNhdmVkVGV4dExhYmVsKFxuICBmaWVsZHMsXG4gIFtsYXllclRleHRMYWJlbF0sXG4gIHNhdmVkVGV4dExhYmVsXG4pIHtcbiAgY29uc3Qgc2F2ZWRUZXh0TGFiZWxzID0gQXJyYXkuaXNBcnJheShzYXZlZFRleHRMYWJlbClcbiAgICA/IHNhdmVkVGV4dExhYmVsXG4gICAgOiBbc2F2ZWRUZXh0TGFiZWxdO1xuXG4gIC8vIHZhbGlkYXRlIGZpZWxkXG4gIHJldHVybiBzYXZlZFRleHRMYWJlbHMubWFwKHRleHRMYWJlbCA9PiB7XG4gICAgY29uc3QgZmllbGQgPSB0ZXh0TGFiZWwuZmllbGRcbiAgICAgID8gZmllbGRzLmZpbmQoZmQgPT5cbiAgICAgICAgICBPYmplY3Qua2V5cyh0ZXh0TGFiZWwuZmllbGQpLmV2ZXJ5KFxuICAgICAgICAgICAga2V5ID0+IHRleHRMYWJlbC5maWVsZFtrZXldID09PSBmZFtrZXldXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICA6IG51bGw7XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMobGF5ZXJUZXh0TGFiZWwpLnJlZHVjZShcbiAgICAgIChhY2N1LCBrZXkpID0+ICh7XG4gICAgICAgIC4uLmFjY3UsXG4gICAgICAgIFtrZXldOiBrZXkgPT09ICdmaWVsZCcgPyBmaWVsZCA6IHRleHRMYWJlbFtrZXldIHx8IGxheWVyVGV4dExhYmVsW2tleV1cbiAgICAgIH0pLFxuICAgICAge31cbiAgICApO1xuICB9KTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBzYXZlZCB2aXN1YWwgY2hhbm5lbHMgY29uZmlnIHdpdGggbmV3IGRhdGEsXG4gKiByZWZlciB0byB2aXMtc3RhdGUtc2NoZW1hLmpzIFZpc3VhbENoYW5uZWxTY2hlbWFWMVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZmllbGRzXG4gKiBAcGFyYW0ge09iamVjdH0gdmlzdWFsQ2hhbm5lbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzYXZlZExheWVyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gdmFsaWRhdGVkIHZpc3VhbCBjaGFubmVsIGluIGNvbmZpZyBvciB7fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTYXZlZFZpc3VhbENoYW5uZWxzKFxuICBmaWVsZHMsXG4gIHZpc3VhbENoYW5uZWxzLFxuICBzYXZlZExheWVyXG4pIHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXModmlzdWFsQ2hhbm5lbHMpLnJlZHVjZSgoZm91bmQsIHtmaWVsZCwgc2NhbGV9KSA9PiB7XG4gICAgbGV0IGZvdW5kRmllbGQ7XG4gICAgaWYgKHNhdmVkTGF5ZXIuY29uZmlnW2ZpZWxkXSkge1xuICAgICAgZm91bmRGaWVsZCA9IGZpZWxkcy5maW5kKGZkID0+XG4gICAgICAgIE9iamVjdC5rZXlzKHNhdmVkTGF5ZXIuY29uZmlnW2ZpZWxkXSkuZXZlcnkoXG4gICAgICAgICAga2V5ID0+IHNhdmVkTGF5ZXIuY29uZmlnW2ZpZWxkXVtrZXldID09PSBmZFtrZXldXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZvdW5kLFxuICAgICAgLi4uKGZvdW5kRmllbGQgPyB7W2ZpZWxkXTogZm91bmRGaWVsZH0gOiB7fSksXG4gICAgICAuLi4oc2F2ZWRMYXllci5jb25maWdbc2NhbGVdID8ge1tzY2FsZV06IHNhdmVkTGF5ZXIuY29uZmlnW3NjYWxlXX0gOiB7fSlcbiAgICB9O1xuICB9LCB7fSk7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgc2F2ZWQgbGF5ZXIgY29uZmlnIHdpdGggbmV3IGRhdGEsXG4gKiB1cGRhdGUgZmllbGRJZHggYmFzZWQgb24gbmV3IGZpZWxkc1xuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZmllbGRzXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YUlkXG4gKiBAcGFyYW0ge09iamVjdH0gc2F2ZWRMYXllclxuICogQHBhcmFtIHtPYmplY3R9IGxheWVyQ2xhc3Nlc1xuICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gLSB2YWxpZGF0ZWQgbGF5ZXIgb3IgbnVsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVMYXllcldpdGhEYXRhKFxuICB7ZmllbGRzLCBpZDogZGF0YUlkfSxcbiAgc2F2ZWRMYXllcixcbiAgbGF5ZXJDbGFzc2VzXG4pIHtcbiAgY29uc3Qge3R5cGV9ID0gc2F2ZWRMYXllcjtcbiAgLy8gbGF5ZXIgZG9lc250IGhhdmUgYSB2YWxpZCB0eXBlXG4gIGlmIChcbiAgICAhbGF5ZXJDbGFzc2VzLmhhc093blByb3BlcnR5KHR5cGUpIHx8XG4gICAgIXNhdmVkTGF5ZXIuY29uZmlnIHx8XG4gICAgIXNhdmVkTGF5ZXIuY29uZmlnLmNvbHVtbnNcbiAgKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBuZXdMYXllciA9IG5ldyBsYXllckNsYXNzZXNbdHlwZV0oe1xuICAgIGlkOiBzYXZlZExheWVyLmlkLFxuICAgIGRhdGFJZCxcbiAgICBsYWJlbDogc2F2ZWRMYXllci5jb25maWcubGFiZWwsXG4gICAgY29sb3I6IHNhdmVkTGF5ZXIuY29uZmlnLmNvbG9yLFxuICAgIGlzVmlzaWJsZTogc2F2ZWRMYXllci5jb25maWcuaXNWaXNpYmxlXG4gIH0pO1xuXG4gIC8vIGZpbmQgY29sdW1uIGZpZWxkSWR4XG4gIGNvbnN0IGNvbHVtbnMgPSB2YWxpZGF0ZVNhdmVkTGF5ZXJDb2x1bW5zKFxuICAgIGZpZWxkcyxcbiAgICBzYXZlZExheWVyLmNvbmZpZy5jb2x1bW5zLFxuICAgIG5ld0xheWVyLmdldExheWVyQ29sdW1ucygpXG4gICk7XG5cbiAgaWYgKCFjb2x1bW5zKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyB2aXN1YWwgY2hhbm5lbCBmaWVsZCBpcyBzYXZlZCB0byBiZSB7bmFtZSwgdHlwZX1cbiAgLy8gZmluZCB2aXN1YWwgY2hhbm5lbCBmaWVsZCBieSBtYXRjaGluZyBib3RoIG5hbWUgYW5kIHR5cGVcbiAgLy8gcmVmZXIgdG8gdmlzLXN0YXRlLXNjaGVtYS5qcyBWaXN1YWxDaGFubmVsU2NoZW1hVjFcbiAgY29uc3QgZm91bmRWaXN1YWxDaGFubmVsQ29uZmlncyA9IHZhbGlkYXRlU2F2ZWRWaXN1YWxDaGFubmVscyhcbiAgICBmaWVsZHMsXG4gICAgbmV3TGF5ZXIudmlzdWFsQ2hhbm5lbHMsXG4gICAgc2F2ZWRMYXllclxuICApO1xuXG4gIGNvbnN0IHRleHRMYWJlbCA9XG4gICAgc2F2ZWRMYXllci5jb25maWcudGV4dExhYmVsICYmIG5ld0xheWVyLmNvbmZpZy50ZXh0TGFiZWxcbiAgICAgID8gdmFsaWRhdGVTYXZlZFRleHRMYWJlbChcbiAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgbmV3TGF5ZXIuY29uZmlnLnRleHRMYWJlbCxcbiAgICAgICAgICBzYXZlZExheWVyLmNvbmZpZy50ZXh0TGFiZWxcbiAgICAgICAgKVxuICAgICAgOiBuZXdMYXllci5jb25maWcudGV4dExhYmVsO1xuXG4gIC8vIGNvcHkgdmlzQ29uZmlnIG92ZXIgdG8gZW1wdHlMYXllciB0byBtYWtlIHN1cmUgaXQgaGFzIGFsbCB0aGUgcHJvcHNcbiAgY29uc3QgdmlzQ29uZmlnID0gbmV3TGF5ZXIuY29weUxheWVyQ29uZmlnKFxuICAgIG5ld0xheWVyLmNvbmZpZy52aXNDb25maWcsXG4gICAgc2F2ZWRMYXllci5jb25maWcudmlzQ29uZmlnIHx8IHt9LFxuICAgIHtzaGFsbG93Q29weTogWydjb2xvclJhbmdlJywgJ3N0cm9rZUNvbG9yUmFuZ2UnXX1cbiAgKTtcblxuICBuZXdMYXllci51cGRhdGVMYXllckNvbmZpZyh7XG4gICAgY29sdW1ucyxcbiAgICB2aXNDb25maWcsXG4gICAgdGV4dExhYmVsLFxuICAgIC4uLmZvdW5kVmlzdWFsQ2hhbm5lbENvbmZpZ3NcbiAgfSk7XG5cbiAgcmV0dXJuIG5ld0xheWVyO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHNhdmVkIGZpbHRlciBjb25maWcgd2l0aCBuZXcgZGF0YSxcbiAqIGNhbGN1bGF0ZSBkb21haW4gYW5kIGZpZWxkSWR4IGJhc2VkIG5ldyBmaWVsZHMgYW5kIGRhdGFcbiAqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGRhdGFzZXQuZmllbGRzXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGRhdGFzZXQuYWxsRGF0YVxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlciAtIGZpbHRlciB0byBiZSB2YWxpZGF0ZVxuICogQHJldHVybiB7T2JqZWN0IHwgbnVsbH0gLSB2YWxpZGF0ZWQgZmlsdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpbHRlcldpdGhEYXRhKHtmaWVsZHMsIGFsbERhdGF9LCBmaWx0ZXIpIHtcbiAgLy8gbWF0Y2ggZmlsdGVyLm5hbWUgdG8gZmllbGQubmFtZVxuICBjb25zdCBmaWVsZElkeCA9IGZpZWxkcy5maW5kSW5kZXgoKHtuYW1lfSkgPT4gbmFtZSA9PT0gZmlsdGVyLm5hbWUpO1xuXG4gIGlmIChmaWVsZElkeCA8IDApIHtcbiAgICAvLyBpZiBjYW4ndCBmaW5kIGZpZWxkIHdpdGggc2FtZSBuYW1lLCBkaXNjaGFyZ2UgZmlsdGVyXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBmaWVsZCA9IGZpZWxkc1tmaWVsZElkeF07XG4gIGNvbnN0IHZhbHVlID0gZmlsdGVyLnZhbHVlO1xuXG4gIC8vIHJldHVybiBmaWx0ZXIgdHlwZSwgZGVmYXVsdCB2YWx1ZSwgZmllbGRUeXBlIGFuZCBmaWVsZERvbWFpbiBmcm9tIGZpZWxkXG4gIGNvbnN0IGZpbHRlclByb3BzRnJvbUZpZWxkID0gZ2V0RmlsdGVyUHJvcHMoYWxsRGF0YSwgZmllbGQpO1xuXG4gIGxldCBtYXRjaGVkRmlsdGVyID0ge1xuICAgIC4uLmdldERlZmF1bHRGaWx0ZXIoZmlsdGVyLmRhdGFJZCksXG4gICAgLi4uZmlsdGVyLFxuICAgIC4uLmZpbHRlclByb3BzRnJvbUZpZWxkLFxuICAgIGZyZWV6ZTogdHJ1ZSxcbiAgICBmaWVsZElkeFxuICB9O1xuXG4gIGNvbnN0IHt5QXhpc30gPSBtYXRjaGVkRmlsdGVyO1xuICBpZiAoeUF4aXMpIHtcbiAgICBjb25zdCBtYXRjaGVBeGlzID0gZmllbGRzLmZpbmQoXG4gICAgICAoe25hbWUsIHR5cGV9KSA9PiBuYW1lID09PSB5QXhpcy5uYW1lICYmIHR5cGUgPT09IHlBeGlzLnR5cGVcbiAgICApO1xuXG4gICAgbWF0Y2hlZEZpbHRlciA9IG1hdGNoZUF4aXNcbiAgICAgID8ge1xuICAgICAgICAgIC4uLm1hdGNoZWRGaWx0ZXIsXG4gICAgICAgICAgeUF4aXM6IG1hdGNoZUF4aXMsXG4gICAgICAgICAgLi4uZ2V0RmlsdGVyUGxvdCh7Li4ubWF0Y2hlZEZpbHRlciwgeUF4aXM6IG1hdGNoZUF4aXN9LCBhbGxEYXRhKVxuICAgICAgICB9XG4gICAgICA6IG1hdGNoZWRGaWx0ZXI7XG4gIH1cblxuICBtYXRjaGVkRmlsdGVyLnZhbHVlID0gYWRqdXN0VmFsdWVUb0ZpbHRlckRvbWFpbih2YWx1ZSwgbWF0Y2hlZEZpbHRlcik7XG5cbiAgaWYgKG1hdGNoZWRGaWx0ZXIudmFsdWUgPT09IG51bGwpIHtcbiAgICAvLyBjYW5udCBhZGp1c3Qgc2F2ZWQgdmFsdWUgdG8gZmlsdGVyXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlZEZpbHRlcjtcbn1cbiJdfQ==